/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Pulsar Admin REST API
 * This provides the REST API for admin operations
 *
 * OpenAPI spec version: v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost/admin/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AllocatorStats
 */
export interface AllocatorStats {
    /**
     * 
     * @type {number}
     * @memberof AllocatorStats
     */
    numDirectArenas?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocatorStats
     */
    numHeapArenas?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocatorStats
     */
    numThreadLocalCaches?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocatorStats
     */
    normalCacheSize?: number;
    /**
     * 
     * @type {number}
     * @memberof AllocatorStats
     */
    smallCacheSize?: number;
    /**
     * 
     * @type {Array<PoolArenaStats>}
     * @memberof AllocatorStats
     */
    directArenas?: Array<PoolArenaStats>;
    /**
     * 
     * @type {Array<PoolArenaStats>}
     * @memberof AllocatorStats
     */
    heapArenas?: Array<PoolArenaStats>;
}

/**
 * 
 * @export
 * @interface Annotation
 */
export interface Annotation {
}

/**
 * 
 * @export
 * @interface AnnotationIntrospector
 */
export interface AnnotationIntrospector {
}

/**
 * 
 * @export
 * @interface ArrayBuilders
 */
export interface ArrayBuilders {
    /**
     * 
     * @type {BooleanBuilder}
     * @memberof ArrayBuilders
     */
    booleanBuilder?: BooleanBuilder;
    /**
     * 
     * @type {ByteBuilder}
     * @memberof ArrayBuilders
     */
    byteBuilder?: ByteBuilder;
    /**
     * 
     * @type {ShortBuilder}
     * @memberof ArrayBuilders
     */
    shortBuilder?: ShortBuilder;
    /**
     * 
     * @type {IntBuilder}
     * @memberof ArrayBuilders
     */
    intBuilder?: IntBuilder;
    /**
     * 
     * @type {LongBuilder}
     * @memberof ArrayBuilders
     */
    longBuilder?: LongBuilder;
    /**
     * 
     * @type {FloatBuilder}
     * @memberof ArrayBuilders
     */
    floatBuilder?: FloatBuilder;
    /**
     * 
     * @type {DoubleBuilder}
     * @memberof ArrayBuilders
     */
    doubleBuilder?: DoubleBuilder;
}

/**
 * 
 * @export
 * @interface AuthPolicies
 */
export interface AuthPolicies {
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AuthPolicies
     */
    subscriptionAuthentication?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AuthPolicies
     */
    namespaceAuthentication?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: Array<string>; }; }}
     * @memberof AuthPolicies
     */
    topicAuthentication?: { [key: string]: { [key: string]: Array<string>; }; };
}

/**
 * @export
 * @namespace AuthPolicies
 */
export namespace AuthPolicies {
    /**
     * @export
     * @enum {string}
     */
    export enum NamespaceAuthenticationEnum {
        Produce = <any> 'produce',
        Consume = <any> 'consume',
        Functions = <any> 'functions',
        Sources = <any> 'sources',
        Sinks = <any> 'sinks',
        Packages = <any> 'packages'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TopicAuthenticationEnum {
        Produce = <any> 'produce',
        Consume = <any> 'consume',
        Functions = <any> 'functions',
        Sources = <any> 'sources',
        Sinks = <any> 'sinks',
        Packages = <any> 'packages'
    }
}

/**
 * 
 * @export
 * @interface AuthenticationDataSource
 */
export interface AuthenticationDataSource {
    /**
     * 
     * @type {SocketAddress}
     * @memberof AuthenticationDataSource
     */
    peerAddress?: SocketAddress;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationDataSource
     */
    commandData?: string;
    /**
     * 
     * @type {Array<Certificate>}
     * @memberof AuthenticationDataSource
     */
    tlsCertificates?: Array<Certificate>;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationDataSource
     */
    httpAuthType?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationDataSource
     */
    subscription?: string;
}

/**
 * 
 * @export
 * @interface AutoFailoverPolicyData
 */
export interface AutoFailoverPolicyData {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AutoFailoverPolicyData
     */
    parameters?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AutoFailoverPolicyData
     */
    policyType?: AutoFailoverPolicyData.PolicyTypeEnum;
}

/**
 * @export
 * @namespace AutoFailoverPolicyData
 */
export namespace AutoFailoverPolicyData {
    /**
     * @export
     * @enum {string}
     */
    export enum PolicyTypeEnum {
        MinAvailable = <any> 'min_available'
    }
}

/**
 * 
 * @export
 * @interface AutoSubscriptionCreationOverride
 */
export interface AutoSubscriptionCreationOverride {
    /**
     * 
     * @type {boolean}
     * @memberof AutoSubscriptionCreationOverride
     */
    allowAutoSubscriptionCreation?: boolean;
}

/**
 * 
 * @export
 * @interface AutoTopicCreationOverride
 */
export interface AutoTopicCreationOverride {
    /**
     * 
     * @type {string}
     * @memberof AutoTopicCreationOverride
     */
    topicType?: string;
    /**
     * 
     * @type {number}
     * @memberof AutoTopicCreationOverride
     */
    defaultNumPartitions?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AutoTopicCreationOverride
     */
    allowAutoTopicCreation?: boolean;
}

/**
 * 
 * @export
 * @interface BacklogQuota
 */
export interface BacklogQuota {
    /**
     * 
     * @type {string}
     * @memberof BacklogQuota
     */
    policy?: BacklogQuota.PolicyEnum;
    /**
     * 
     * @type {number}
     * @memberof BacklogQuota
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof BacklogQuota
     */
    limitSize?: number;
    /**
     * 
     * @type {number}
     * @memberof BacklogQuota
     */
    limitTime?: number;
}

/**
 * @export
 * @namespace BacklogQuota
 */
export namespace BacklogQuota {
    /**
     * @export
     * @enum {string}
     */
    export enum PolicyEnum {
        ProducerRequestHold = <any> 'producer_request_hold',
        ProducerException = <any> 'producer_exception',
        ConsumerBacklogEviction = <any> 'consumer_backlog_eviction'
    }
}

/**
 * 
 * @export
 * @interface Base64Variant
 */
export interface Base64Variant {
    /**
     * 
     * @type {string}
     * @memberof Base64Variant
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Base64Variant
     */
    maxLineLength?: number;
    /**
     * 
     * @type {string}
     * @memberof Base64Variant
     */
    paddingChar?: string;
    /**
     * 
     * @type {string}
     * @memberof Base64Variant
     */
    paddingByte?: string;
}

/**
 * 
 * @export
 * @interface BookieAffinityGroupData
 */
export interface BookieAffinityGroupData {
    /**
     * 
     * @type {string}
     * @memberof BookieAffinityGroupData
     */
    bookkeeperAffinityGroupPrimary?: string;
    /**
     * 
     * @type {string}
     * @memberof BookieAffinityGroupData
     */
    bookkeeperAffinityGroupSecondary?: string;
}

/**
 * 
 * @export
 * @interface BookieInfo
 */
export interface BookieInfo {
    /**
     * 
     * @type {string}
     * @memberof BookieInfo
     */
    hostname?: string;
    /**
     * 
     * @type {string}
     * @memberof BookieInfo
     */
    rack?: string;
}

/**
 * 
 * @export
 * @interface BookiesClusterInfo
 */
export interface BookiesClusterInfo {
    /**
     * 
     * @type {Array<RawBookieInfo>}
     * @memberof BookiesClusterInfo
     */
    bookies?: Array<RawBookieInfo>;
}

/**
 * 
 * @export
 * @interface BooleanBuilder
 */
export interface BooleanBuilder {
}

/**
 * 
 * @export
 * @interface BrokerInfo
 */
export interface BrokerInfo {
    /**
     * 
     * @type {string}
     * @memberof BrokerInfo
     */
    serviceUrl?: string;
}

/**
 * The namespace isolation data for a given broker
 * @export
 * @interface BrokerNamespaceIsolationData
 */
export interface BrokerNamespaceIsolationData {
    /**
     * The broker name
     * @type {string}
     * @memberof BrokerNamespaceIsolationData
     */
    brokerName?: string;
    /**
     * Policy name
     * @type {string}
     * @memberof BrokerNamespaceIsolationData
     */
    policyName?: string;
    /**
     * The namespace-isolation policies attached to this broker
     * @type {Array<string>}
     * @memberof BrokerNamespaceIsolationData
     */
    namespaceRegex?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BrokerNamespaceIsolationData
     */
    primary?: boolean;
}

/**
 * 
 * @export
 * @interface BundlesData
 */
export interface BundlesData {
    /**
     * 
     * @type {Array<string>}
     * @memberof BundlesData
     */
    boundaries?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof BundlesData
     */
    numBundles?: number;
}

/**
 * 
 * @export
 * @interface ByteBuilder
 */
export interface ByteBuilder {
}

/**
 * 
 * @export
 * @interface Certificate
 */
export interface Certificate {
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    type?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    encoded?: Array<string>;
    /**
     * 
     * @type {PublicKey}
     * @memberof Certificate
     */
    publicKey?: PublicKey;
}

/**
 * 
 * @export
 * @interface CharacterEscapes
 */
export interface CharacterEscapes {
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacterEscapes
     */
    escapeCodesForAscii?: Array<number>;
}

/**
 * 
 * @export
 * @interface ClassIntrospector
 */
export interface ClassIntrospector {
}

/**
 * 
 * @export
 * @interface ClassLoader
 */
export interface ClassLoader {
    /**
     * 
     * @type {string}
     * @memberof ClassLoader
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClassLoader
     */
    registeredAsParallelCapable?: boolean;
    /**
     * 
     * @type {ClassLoader}
     * @memberof ClassLoader
     */
    parent?: ClassLoader;
    /**
     * 
     * @type {Module}
     * @memberof ClassLoader
     */
    unnamedModule?: Module;
    /**
     * 
     * @type {Array<ModelPackage>}
     * @memberof ClassLoader
     */
    definedPackages?: Array<ModelPackage>;
}

/**
 * The configuration data for a cluster
 * @export
 * @interface ClusterData
 */
export interface ClusterData {
    /**
     * The HTTP rest service URL (for admin operations)
     * @type {string}
     * @memberof ClusterData
     */
    serviceUrl?: string;
    /**
     * The HTTPS rest service URL (for admin operations)
     * @type {string}
     * @memberof ClusterData
     */
    serviceUrlTls?: string;
    /**
     * The broker service url (for produce and consume operations)
     * @type {string}
     * @memberof ClusterData
     */
    brokerServiceUrl?: string;
    /**
     * The secured broker service url (for produce and consume operations)
     * @type {string}
     * @memberof ClusterData
     */
    brokerServiceUrlTls?: string;
    /**
     * Proxy-service url when client would like to connect to broker via proxy.
     * @type {string}
     * @memberof ClusterData
     */
    proxyServiceUrl?: string;
    /**
     * Authentication plugin when client would like to connect to cluster.
     * @type {string}
     * @memberof ClusterData
     */
    authenticationPlugin?: string;
    /**
     * Authentication parameters when client would like to connect to cluster.
     * @type {string}
     * @memberof ClusterData
     */
    authenticationParameters?: string;
    /**
     * protocol to decide type of proxy routing eg: SNI-routing
     * @type {string}
     * @memberof ClusterData
     */
    proxyProtocol?: ClusterData.ProxyProtocolEnum;
    /**
     * A set of peer cluster names
     * @type {Array<string>}
     * @memberof ClusterData
     */
    peerClusterNames?: Array<string>;
    /**
     * Enable TLS when talking with other brokers in the same cluster (admin operation) or different clusters (replication)
     * @type {boolean}
     * @memberof ClusterData
     */
    brokerClientTlsEnabled?: boolean;
    /**
     * Allow TLS connections to servers whose certificate cannot be be verified to have been signed by a trusted certificate authority.
     * @type {boolean}
     * @memberof ClusterData
     */
    tlsAllowInsecureConnection?: boolean;
    /**
     * Whether internal client use KeyStore type to authenticate with other Pulsar brokers
     * @type {boolean}
     * @memberof ClusterData
     */
    brokerClientTlsEnabledWithKeyStore?: boolean;
    /**
     * TLS TrustStore type configuration for internal client: JKS, PKCS12 used by the internal client to authenticate with Pulsar brokers
     * @type {string}
     * @memberof ClusterData
     */
    brokerClientTlsTrustStoreType?: string;
    /**
     * TLS TrustStore path for internal client used by the internal client to authenticate with Pulsar brokers
     * @type {string}
     * @memberof ClusterData
     */
    brokerClientTlsTrustStore?: string;
    /**
     * TLS TrustStore password for internal client used by the internal client to authenticate with Pulsar brokers
     * @type {string}
     * @memberof ClusterData
     */
    brokerClientTlsTrustStorePassword?: string;
    /**
     * Path for the trusted TLS certificate file for outgoing connection to a server (broker)
     * @type {string}
     * @memberof ClusterData
     */
    brokerClientTrustCertsFilePath?: string;
    /**
     * listenerName when client would like to connect to cluster
     * @type {string}
     * @memberof ClusterData
     */
    listenerName?: string;
}

/**
 * @export
 * @namespace ClusterData
 */
export namespace ClusterData {
    /**
     * @export
     * @enum {string}
     */
    export enum ProxyProtocolEnum {
        SNI = <any> 'SNI'
    }
}

/**
 * 
 * @export
 * @interface CompletableFuture
 */
export interface CompletableFuture {
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFuture
     */
    cancelled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFuture
     */
    done?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CompletableFuture
     */
    numberOfDependents?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFuture
     */
    completedExceptionally?: boolean;
}

/**
 * 
 * @export
 * @interface CompletableFutureClusterData
 */
export interface CompletableFutureClusterData {
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureClusterData
     */
    cancelled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureClusterData
     */
    done?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CompletableFutureClusterData
     */
    numberOfDependents?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureClusterData
     */
    completedExceptionally?: boolean;
}

/**
 * 
 * @export
 * @interface CompletableFuturePartitionedTopicMetadata
 */
export interface CompletableFuturePartitionedTopicMetadata {
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFuturePartitionedTopicMetadata
     */
    cancelled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFuturePartitionedTopicMetadata
     */
    done?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CompletableFuturePartitionedTopicMetadata
     */
    numberOfDependents?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFuturePartitionedTopicMetadata
     */
    completedExceptionally?: boolean;
}

/**
 * 
 * @export
 * @interface CompletableFutureResourceQuota
 */
export interface CompletableFutureResourceQuota {
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureResourceQuota
     */
    cancelled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureResourceQuota
     */
    done?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CompletableFutureResourceQuota
     */
    numberOfDependents?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureResourceQuota
     */
    completedExceptionally?: boolean;
}

/**
 * 
 * @export
 * @interface CompletableFutureVoid
 */
export interface CompletableFutureVoid {
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureVoid
     */
    cancelled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureVoid
     */
    done?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CompletableFutureVoid
     */
    numberOfDependents?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CompletableFutureVoid
     */
    completedExceptionally?: boolean;
}

/**
 * 
 * @export
 * @interface ConnectorDefinition
 */
export interface ConnectorDefinition {
    /**
     * 
     * @type {string}
     * @memberof ConnectorDefinition
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorDefinition
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorDefinition
     */
    sourceClass?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorDefinition
     */
    sinkClass?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorDefinition
     */
    sourceConfigClass?: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorDefinition
     */
    sinkConfigClass?: string;
}

/**
 * 
 * @export
 * @interface ContextAttributes
 */
export interface ContextAttributes {
}

/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    currencyCode?: string;
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    defaultFractionDigits?: number;
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    numericCode?: number;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    numericCodeAsString?: string;
}

/**
 * 
 * @export
 * @interface CursorDetails
 */
export interface CursorDetails {
    /**
     * 
     * @type {number}
     * @memberof CursorDetails
     */
    cursorBacklog?: number;
    /**
     * 
     * @type {number}
     * @memberof CursorDetails
     */
    cursorLedgerId?: number;
}

/**
 * 
 * @export
 * @interface CursorStats
 */
export interface CursorStats {
    /**
     * 
     * @type {string}
     * @memberof CursorStats
     */
    markDeletePosition?: string;
    /**
     * 
     * @type {string}
     * @memberof CursorStats
     */
    readPosition?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CursorStats
     */
    waitingReadOp?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CursorStats
     */
    pendingReadOps?: number;
    /**
     * 
     * @type {number}
     * @memberof CursorStats
     */
    messagesConsumedCounter?: number;
    /**
     * 
     * @type {number}
     * @memberof CursorStats
     */
    cursorLedger?: number;
    /**
     * 
     * @type {number}
     * @memberof CursorStats
     */
    cursorLedgerLastEntry?: number;
    /**
     * 
     * @type {string}
     * @memberof CursorStats
     */
    individuallyDeletedMessages?: string;
    /**
     * 
     * @type {string}
     * @memberof CursorStats
     */
    lastLedgerSwitchTimestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CursorStats
     */
    state?: string;
    /**
     * 
     * @type {number}
     * @memberof CursorStats
     */
    numberOfEntriesSinceFirstNotAckedMessage?: number;
    /**
     * 
     * @type {number}
     * @memberof CursorStats
     */
    totalNonContiguousDeletedMessagesRange?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CursorStats
     */
    subscriptionHavePendingRead?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CursorStats
     */
    subscriptionHavePendingReplayRead?: boolean;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof CursorStats
     */
    properties?: { [key: string]: number; };
}

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {Date}
     * @memberof DateFormat
     */
    calendar?: Date;
    /**
     * 
     * @type {NumberFormat}
     * @memberof DateFormat
     */
    numberFormat?: NumberFormat;
    /**
     * 
     * @type {TimeZone}
     * @memberof DateFormat
     */
    timeZone?: TimeZone;
    /**
     * 
     * @type {boolean}
     * @memberof DateFormat
     */
    lenient?: boolean;
}

/**
 * 
 * @export
 * @interface DelayedDeliveryPolicies
 */
export interface DelayedDeliveryPolicies {
    /**
     * 
     * @type {boolean}
     * @memberof DelayedDeliveryPolicies
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DelayedDeliveryPolicies
     */
    tickTime?: number;
}

/**
 * 
 * @export
 * @interface DeleteSchemaResponse
 */
export interface DeleteSchemaResponse {
    /**
     * 
     * @type {number}
     * @memberof DeleteSchemaResponse
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface DeserializationConfig
 */
export interface DeserializationConfig {
    /**
     * 
     * @type {AnnotationIntrospector}
     * @memberof DeserializationConfig
     */
    annotationIntrospector?: AnnotationIntrospector;
    /**
     * 
     * @type {Value}
     * @memberof DeserializationConfig
     */
    defaultPropertyInclusion?: Value;
    /**
     * 
     * @type {JsonNodeFactory}
     * @memberof DeserializationConfig
     */
    nodeFactory?: JsonNodeFactory;
    /**
     * 
     * @type {number}
     * @memberof DeserializationConfig
     */
    deserializationFeatures?: number;
    /**
     * 
     * @type {LinkedNodeDeserializationProblemHandler}
     * @memberof DeserializationConfig
     */
    problemHandlers?: LinkedNodeDeserializationProblemHandler;
    /**
     * 
     * @type {ContextAttributes}
     * @memberof DeserializationConfig
     */
    attributes?: ContextAttributes;
    /**
     * 
     * @type {string}
     * @memberof DeserializationConfig
     */
    rootName?: string;
    /**
     * 
     * @type {SubtypeResolver}
     * @memberof DeserializationConfig
     */
    subtypeResolver?: SubtypeResolver;
    /**
     * 
     * @type {PropertyName}
     * @memberof DeserializationConfig
     */
    fullRootName?: PropertyName;
    /**
     * 
     * @type {VisibilityCheckerObject}
     * @memberof DeserializationConfig
     */
    defaultVisibilityChecker?: VisibilityCheckerObject;
    /**
     * 
     * @type {Locale}
     * @memberof DeserializationConfig
     */
    locale?: Locale;
    /**
     * 
     * @type {TimeZone}
     * @memberof DeserializationConfig
     */
    timeZone?: TimeZone;
    /**
     * 
     * @type {TypeFactory}
     * @memberof DeserializationConfig
     */
    typeFactory?: TypeFactory;
    /**
     * 
     * @type {PropertyNamingStrategy}
     * @memberof DeserializationConfig
     */
    propertyNamingStrategy?: PropertyNamingStrategy;
    /**
     * 
     * @type {HandlerInstantiator}
     * @memberof DeserializationConfig
     */
    handlerInstantiator?: HandlerInstantiator;
    /**
     * 
     * @type {DateFormat}
     * @memberof DeserializationConfig
     */
    dateFormat?: DateFormat;
    /**
     * 
     * @type {Base64Variant}
     * @memberof DeserializationConfig
     */
    base64Variant?: Base64Variant;
    /**
     * 
     * @type {boolean}
     * @memberof DeserializationConfig
     */
    annotationProcessingEnabled?: boolean;
    /**
     * 
     * @type {ClassIntrospector}
     * @memberof DeserializationConfig
     */
    classIntrospector?: ClassIntrospector;
}

/**
 * 
 * @export
 * @interface DeserializationContext
 */
export interface DeserializationContext {
    /**
     * 
     * @type {DeserializerFactory}
     * @memberof DeserializationContext
     */
    factory?: DeserializerFactory;
    /**
     * 
     * @type {Locale}
     * @memberof DeserializationContext
     */
    locale?: Locale;
    /**
     * 
     * @type {TimeZone}
     * @memberof DeserializationContext
     */
    timeZone?: TimeZone;
    /**
     * 
     * @type {DeserializationConfig}
     * @memberof DeserializationContext
     */
    config?: DeserializationConfig;
    /**
     * 
     * @type {JsonParser}
     * @memberof DeserializationContext
     */
    parser?: JsonParser;
    /**
     * 
     * @type {TypeFactory}
     * @memberof DeserializationContext
     */
    typeFactory?: TypeFactory;
    /**
     * 
     * @type {AnnotationIntrospector}
     * @memberof DeserializationContext
     */
    annotationIntrospector?: AnnotationIntrospector;
    /**
     * 
     * @type {JsonNodeFactory}
     * @memberof DeserializationContext
     */
    nodeFactory?: JsonNodeFactory;
    /**
     * 
     * @type {JavaType}
     * @memberof DeserializationContext
     */
    contextualType?: JavaType;
    /**
     * 
     * @type {number}
     * @memberof DeserializationContext
     */
    deserializationFeatures?: number;
    /**
     * 
     * @type {Base64Variant}
     * @memberof DeserializationContext
     */
    base64Variant?: Base64Variant;
    /**
     * 
     * @type {ArrayBuilders}
     * @memberof DeserializationContext
     */
    arrayBuilders?: ArrayBuilders;
}

/**
 * 
 * @export
 * @interface DeserializerFactory
 */
export interface DeserializerFactory {
}

/**
 * 
 * @export
 * @interface DispatchRate
 */
export interface DispatchRate {
    /**
     * 
     * @type {number}
     * @memberof DispatchRate
     */
    dispatchThrottlingRateInMsg?: number;
    /**
     * 
     * @type {number}
     * @memberof DispatchRate
     */
    dispatchThrottlingRateInByte?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DispatchRate
     */
    relativeToPublishRate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DispatchRate
     */
    ratePeriodInSecond?: number;
}

/**
 * 
 * @export
 * @interface DispatchRateImpl
 */
export interface DispatchRateImpl {
    /**
     * 
     * @type {number}
     * @memberof DispatchRateImpl
     */
    dispatchThrottlingRateInMsg?: number;
    /**
     * 
     * @type {number}
     * @memberof DispatchRateImpl
     */
    dispatchThrottlingRateInByte?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DispatchRateImpl
     */
    relativeToPublishRate?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DispatchRateImpl
     */
    ratePeriodInSecond?: number;
}

/**
 * 
 * @export
 * @interface DoubleBuilder
 */
export interface DoubleBuilder {
}

/**
 * The data of a failure domain configuration in a cluster
 * @export
 * @interface FailureDomain
 */
export interface FailureDomain {
    /**
     * The collection of brokers in the same failure domain
     * @type {Array<string>}
     * @memberof FailureDomain
     */
    brokers?: Array<string>;
}

/**
 * 
 * @export
 * @interface FilterProvider
 */
export interface FilterProvider {
}

/**
 * 
 * @export
 * @interface FloatBuilder
 */
export interface FloatBuilder {
}

/**
 * 
 * @export
 * @interface FormatSchema
 */
export interface FormatSchema {
    /**
     * 
     * @type {string}
     * @memberof FormatSchema
     */
    schemaType?: string;
}

/**
 * 
 * @export
 * @interface FunctionInstanceStatsData
 */
export interface FunctionInstanceStatsData {
    /**
     * 
     * @type {FunctionInstanceStatsDataBase}
     * @memberof FunctionInstanceStatsData
     */
    oneMin?: FunctionInstanceStatsDataBase;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof FunctionInstanceStatsData
     */
    userMetrics?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsData
     */
    lastInvocation?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsData
     */
    receivedTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsData
     */
    processedSuccessfullyTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsData
     */
    systemExceptionsTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsData
     */
    userExceptionsTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsData
     */
    avgProcessLatency?: number;
}

/**
 * 
 * @export
 * @interface FunctionInstanceStatsDataBase
 */
export interface FunctionInstanceStatsDataBase {
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsDataBase
     */
    receivedTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsDataBase
     */
    processedSuccessfullyTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsDataBase
     */
    systemExceptionsTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsDataBase
     */
    userExceptionsTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionInstanceStatsDataBase
     */
    avgProcessLatency?: number;
}

/**
 * 
 * @export
 * @interface Functions
 */
export interface Functions {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof Functions
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface FunctionsV2
 */
export interface FunctionsV2 {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof FunctionsV2
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface FunctionsV2WorkerService
 */
export interface FunctionsV2WorkerService {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof FunctionsV2WorkerService
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface FunctionsWorkerService
 */
export interface FunctionsWorkerService {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof FunctionsWorkerService
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface GetAllVersionsSchemaResponse
 */
export interface GetAllVersionsSchemaResponse {
    /**
     * 
     * @type {Array<GetSchemaResponse>}
     * @memberof GetAllVersionsSchemaResponse
     */
    getSchemaResponses?: Array<GetSchemaResponse>;
}

/**
 * 
 * @export
 * @interface GetSchemaResponse
 */
export interface GetSchemaResponse {
    /**
     * 
     * @type {number}
     * @memberof GetSchemaResponse
     */
    version?: number;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaResponse
     */
    type?: GetSchemaResponse.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof GetSchemaResponse
     */
    timestamp?: number;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaResponse
     */
    data?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GetSchemaResponse
     */
    properties?: { [key: string]: string; };
}

/**
 * @export
 * @namespace GetSchemaResponse
 */
export namespace GetSchemaResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        NONE = <any> 'NONE',
        STRING = <any> 'STRING',
        JSON = <any> 'JSON',
        PROTOBUF = <any> 'PROTOBUF',
        AVRO = <any> 'AVRO',
        BOOLEAN = <any> 'BOOLEAN',
        INT8 = <any> 'INT8',
        INT16 = <any> 'INT16',
        INT32 = <any> 'INT32',
        INT64 = <any> 'INT64',
        FLOAT = <any> 'FLOAT',
        DOUBLE = <any> 'DOUBLE',
        DATE = <any> 'DATE',
        TIME = <any> 'TIME',
        TIMESTAMP = <any> 'TIMESTAMP',
        KEYVALUE = <any> 'KEY_VALUE',
        INSTANT = <any> 'INSTANT',
        LOCALDATE = <any> 'LOCAL_DATE',
        LOCALTIME = <any> 'LOCAL_TIME',
        LOCALDATETIME = <any> 'LOCAL_DATE_TIME',
        PROTOBUFNATIVE = <any> 'PROTOBUF_NATIVE',
        BYTES = <any> 'BYTES',
        AUTO = <any> 'AUTO',
        AUTOCONSUME = <any> 'AUTO_CONSUME',
        AUTOPUBLISH = <any> 'AUTO_PUBLISH'
    }
}

/**
 * 
 * @export
 * @interface HandlerInstantiator
 */
export interface HandlerInstantiator {
}

/**
 * 
 * @export
 * @interface InactiveTopicPolicies
 */
export interface InactiveTopicPolicies {
    /**
     * 
     * @type {string}
     * @memberof InactiveTopicPolicies
     */
    inactiveTopicDeleteMode?: InactiveTopicPolicies.InactiveTopicDeleteModeEnum;
    /**
     * 
     * @type {number}
     * @memberof InactiveTopicPolicies
     */
    maxInactiveDurationSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InactiveTopicPolicies
     */
    deleteWhileInactive?: boolean;
}

/**
 * @export
 * @namespace InactiveTopicPolicies
 */
export namespace InactiveTopicPolicies {
    /**
     * @export
     * @enum {string}
     */
    export enum InactiveTopicDeleteModeEnum {
        NoSubscriptions = <any> 'delete_when_no_subscriptions',
        SubscriptionsCaughtUp = <any> 'delete_when_subscriptions_caught_up'
    }
}

/**
 * 
 * @export
 * @interface InjectableValues
 */
export interface InjectableValues {
}

/**
 * 
 * @export
 * @interface InputDecorator
 */
export interface InputDecorator {
}

/**
 * 
 * @export
 * @interface IntBuilder
 */
export interface IntBuilder {
}

/**
 * 
 * @export
 * @interface InternalConfigurationData
 */
export interface InternalConfigurationData {
    /**
     * 
     * @type {string}
     * @memberof InternalConfigurationData
     */
    metadataStoreUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalConfigurationData
     */
    configurationMetadataStoreUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalConfigurationData
     */
    ledgersRootPath?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalConfigurationData
     */
    bookkeeperMetadataServiceUri?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalConfigurationData
     */
    stateStorageServiceUrl?: string;
}

/**
 * 
 * @export
 * @interface IsCompatibilityResponse
 */
export interface IsCompatibilityResponse {
    /**
     * 
     * @type {string}
     * @memberof IsCompatibilityResponse
     */
    schemaCompatibilityStrategy?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IsCompatibilityResponse
     */
    compatibility?: boolean;
}

/**
 * 
 * @export
 * @interface JavaType
 */
export interface JavaType {
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    _interface?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    primitive?: boolean;
    /**
     * 
     * @type {Array<JavaType>}
     * @memberof JavaType
     */
    interfaces?: Array<JavaType>;
    /**
     * 
     * @type {string}
     * @memberof JavaType
     */
    genericSignature?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    _final?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    _abstract?: boolean;
    /**
     * 
     * @type {TypeBindings}
     * @memberof JavaType
     */
    bindings?: TypeBindings;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    concrete?: boolean;
    /**
     * 
     * @type {JavaType}
     * @memberof JavaType
     */
    keyType?: JavaType;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    arrayType?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    throwable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    javaLangObject?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    enumType?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    containerType?: boolean;
    /**
     * 
     * @type {any}
     * @memberof JavaType
     */
    valueHandler?: any;
    /**
     * 
     * @type {any}
     * @memberof JavaType
     */
    typeHandler?: any;
    /**
     * 
     * @type {JavaType}
     * @memberof JavaType
     */
    referencedType?: JavaType;
    /**
     * 
     * @type {JavaType}
     * @memberof JavaType
     */
    superClass?: JavaType;
    /**
     * 
     * @type {any}
     * @memberof JavaType
     */
    contentValueHandler?: any;
    /**
     * 
     * @type {any}
     * @memberof JavaType
     */
    contentTypeHandler?: any;
    /**
     * 
     * @type {string}
     * @memberof JavaType
     */
    erasedSignature?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    collectionLikeType?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    mapLikeType?: boolean;
    /**
     * 
     * @type {JavaType}
     * @memberof JavaType
     */
    contentType?: JavaType;
    /**
     * 
     * @type {string}
     * @memberof JavaType
     */
    typeName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JavaType
     */
    referenceType?: boolean;
}

/**
 * 
 * @export
 * @interface JsonFactory
 */
export interface JsonFactory {
    /**
     * 
     * @type {InputDecorator}
     * @memberof JsonFactory
     */
    inputDecorator?: InputDecorator;
    /**
     * 
     * @type {CharacterEscapes}
     * @memberof JsonFactory
     */
    characterEscapes?: CharacterEscapes;
    /**
     * 
     * @type {OutputDecorator}
     * @memberof JsonFactory
     */
    outputDecorator?: OutputDecorator;
    /**
     * 
     * @type {string}
     * @memberof JsonFactory
     */
    rootValueSeparator?: string;
    /**
     * 
     * @type {ObjectCodec}
     * @memberof JsonFactory
     */
    codec?: ObjectCodec;
    /**
     * 
     * @type {string}
     * @memberof JsonFactory
     */
    formatName?: string;
}

/**
 * 
 * @export
 * @interface JsonGenerator
 */
export interface JsonGenerator {
    /**
     * 
     * @type {FormatSchema}
     * @memberof JsonGenerator
     */
    schema?: FormatSchema;
    /**
     * 
     * @type {CharacterEscapes}
     * @memberof JsonGenerator
     */
    characterEscapes?: CharacterEscapes;
    /**
     * 
     * @type {ObjectCodec}
     * @memberof JsonGenerator
     */
    codec?: ObjectCodec;
    /**
     * 
     * @type {PrettyPrinter}
     * @memberof JsonGenerator
     */
    prettyPrinter?: PrettyPrinter;
    /**
     * 
     * @type {number}
     * @memberof JsonGenerator
     */
    featureMask?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonGenerator
     */
    formatFeatures?: number;
    /**
     * 
     * @type {any}
     * @memberof JsonGenerator
     */
    currentValue?: any;
    /**
     * 
     * @type {number}
     * @memberof JsonGenerator
     */
    highestEscapedChar?: number;
    /**
     * 
     * @type {any}
     * @memberof JsonGenerator
     */
    outputTarget?: any;
    /**
     * 
     * @type {number}
     * @memberof JsonGenerator
     */
    outputBuffered?: number;
    /**
     * 
     * @type {JsonStreamContext}
     * @memberof JsonGenerator
     */
    outputContext?: JsonStreamContext;
    /**
     * 
     * @type {boolean}
     * @memberof JsonGenerator
     */
    closed?: boolean;
}

/**
 * 
 * @export
 * @interface JsonLocation
 */
export interface JsonLocation {
    /**
     * 
     * @type {number}
     * @memberof JsonLocation
     */
    byteOffset?: number;
    /**
     * 
     * @type {any}
     * @memberof JsonLocation
     */
    sourceRef?: any;
    /**
     * 
     * @type {number}
     * @memberof JsonLocation
     */
    lineNr?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonLocation
     */
    columnNr?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonLocation
     */
    charOffset?: number;
}

/**
 * 
 * @export
 * @interface JsonNodeFactory
 */
export interface JsonNodeFactory {
}

/**
 * 
 * @export
 * @interface JsonParser
 */
export interface JsonParser {
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    textLength?: number;
    /**
     * 
     * @type {string}
     * @memberof JsonParser
     */
    text?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JsonParser
     */
    textCharacters?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof JsonParser
     */
    booleanValue?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JsonParser
     */
    byteValue?: string;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    doubleValue?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    floatValue?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    longValue?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    shortValue?: number;
    /**
     * 
     * @type {any}
     * @memberof JsonParser
     */
    objectId?: any;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    intValue?: number;
    /**
     * 
     * @type {any}
     * @memberof JsonParser
     */
    typeId?: any;
    /**
     * 
     * @type {FormatSchema}
     * @memberof JsonParser
     */
    schema?: FormatSchema;
    /**
     * 
     * @type {ObjectCodec}
     * @memberof JsonParser
     */
    codec?: ObjectCodec;
    /**
     * 
     * @type {string}
     * @memberof JsonParser
     */
    currentToken?: JsonParser.CurrentTokenEnum;
    /**
     * 
     * @type {string}
     * @memberof JsonParser
     */
    currentName?: string;
    /**
     * 
     * @type {JsonLocation}
     * @memberof JsonParser
     */
    tokenLocation?: JsonLocation;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    featureMask?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    formatFeatures?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    currentTokenId?: number;
    /**
     * 
     * @type {JsonStreamContext}
     * @memberof JsonParser
     */
    parsingContext?: JsonStreamContext;
    /**
     * 
     * @type {JsonLocation}
     * @memberof JsonParser
     */
    currentLocation?: JsonLocation;
    /**
     * 
     * @type {boolean}
     * @memberof JsonParser
     */
    expectedStartArrayToken?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof JsonParser
     */
    expectedStartObjectToken?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JsonParser
     */
    lastClearedToken?: JsonParser.LastClearedTokenEnum;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    textOffset?: number;
    /**
     * 
     * @type {Number}
     * @memberof JsonParser
     */
    numberValue?: Number;
    /**
     * 
     * @type {string}
     * @memberof JsonParser
     */
    numberType?: JsonParser.NumberTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    bigIntegerValue?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    decimalValue?: number;
    /**
     * 
     * @type {any}
     * @memberof JsonParser
     */
    embeddedObject?: any;
    /**
     * 
     * @type {Array<string>}
     * @memberof JsonParser
     */
    binaryValue?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    valueAsInt?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    valueAsLong?: number;
    /**
     * 
     * @type {number}
     * @memberof JsonParser
     */
    valueAsDouble?: number;
    /**
     * 
     * @type {boolean}
     * @memberof JsonParser
     */
    valueAsBoolean?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JsonParser
     */
    valueAsString?: string;
    /**
     * 
     * @type {any}
     * @memberof JsonParser
     */
    inputSource?: any;
    /**
     * 
     * @type {any}
     * @memberof JsonParser
     */
    currentValue?: any;
    /**
     * 
     * @type {boolean}
     * @memberof JsonParser
     */
    closed?: boolean;
}

/**
 * @export
 * @namespace JsonParser
 */
export namespace JsonParser {
    /**
     * @export
     * @enum {string}
     */
    export enum CurrentTokenEnum {
        NOTAVAILABLE = <any> 'NOT_AVAILABLE',
        STARTOBJECT = <any> 'START_OBJECT',
        ENDOBJECT = <any> 'END_OBJECT',
        STARTARRAY = <any> 'START_ARRAY',
        ENDARRAY = <any> 'END_ARRAY',
        FIELDNAME = <any> 'FIELD_NAME',
        VALUEEMBEDDEDOBJECT = <any> 'VALUE_EMBEDDED_OBJECT',
        VALUESTRING = <any> 'VALUE_STRING',
        VALUENUMBERINT = <any> 'VALUE_NUMBER_INT',
        VALUENUMBERFLOAT = <any> 'VALUE_NUMBER_FLOAT',
        VALUETRUE = <any> 'VALUE_TRUE',
        VALUEFALSE = <any> 'VALUE_FALSE',
        VALUENULL = <any> 'VALUE_NULL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum LastClearedTokenEnum {
        NOTAVAILABLE = <any> 'NOT_AVAILABLE',
        STARTOBJECT = <any> 'START_OBJECT',
        ENDOBJECT = <any> 'END_OBJECT',
        STARTARRAY = <any> 'START_ARRAY',
        ENDARRAY = <any> 'END_ARRAY',
        FIELDNAME = <any> 'FIELD_NAME',
        VALUEEMBEDDEDOBJECT = <any> 'VALUE_EMBEDDED_OBJECT',
        VALUESTRING = <any> 'VALUE_STRING',
        VALUENUMBERINT = <any> 'VALUE_NUMBER_INT',
        VALUENUMBERFLOAT = <any> 'VALUE_NUMBER_FLOAT',
        VALUETRUE = <any> 'VALUE_TRUE',
        VALUEFALSE = <any> 'VALUE_FALSE',
        VALUENULL = <any> 'VALUE_NULL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum NumberTypeEnum {
        INT = <any> 'INT',
        LONG = <any> 'LONG',
        BIGINTEGER = <any> 'BIG_INTEGER',
        FLOAT = <any> 'FLOAT',
        DOUBLE = <any> 'DOUBLE',
        BIGDECIMAL = <any> 'BIG_DECIMAL'
    }
}

/**
 * 
 * @export
 * @interface JsonSerializer
 */
export interface JsonSerializer {
    /**
     * 
     * @type {boolean}
     * @memberof JsonSerializer
     */
    unwrappingSerializer?: boolean;
}

/**
 * 
 * @export
 * @interface JsonSerializerObject
 */
export interface JsonSerializerObject {
    /**
     * 
     * @type {boolean}
     * @memberof JsonSerializerObject
     */
    unwrappingSerializer?: boolean;
    /**
     * 
     * @type {JsonSerializerObject}
     * @memberof JsonSerializerObject
     */
    delegatee?: JsonSerializerObject;
}

/**
 * 
 * @export
 * @interface JsonStreamContext
 */
export interface JsonStreamContext {
    /**
     * 
     * @type {JsonStreamContext}
     * @memberof JsonStreamContext
     */
    parent?: JsonStreamContext;
    /**
     * 
     * @type {string}
     * @memberof JsonStreamContext
     */
    currentName?: string;
    /**
     * 
     * @type {any}
     * @memberof JsonStreamContext
     */
    currentValue?: any;
    /**
     * 
     * @type {number}
     * @memberof JsonStreamContext
     */
    entryCount?: number;
    /**
     * 
     * @type {string}
     * @memberof JsonStreamContext
     */
    typeDesc?: string;
    /**
     * 
     * @type {number}
     * @memberof JsonStreamContext
     */
    currentIndex?: number;
}

/**
 * 
 * @export
 * @interface KubernetesContainerFactory
 */
export interface KubernetesContainerFactory {
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    k8Uri?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    jobNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    jobName?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    pulsarDockerImageName?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesContainerFactory
     */
    functionDockerImages?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    imagePullPolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    pulsarRootDir?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    configAdminCLI?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesContainerFactory
     */
    submittingInsidePod?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    pulsarServiceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    pulsarAdminUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesContainerFactory
     */
    installUserCodeDependencies?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    pythonDependencyRepository?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    pythonExtraDependencyRepository?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    extraFunctionDependenciesDir?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesContainerFactory
     */
    customLabels?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof KubernetesContainerFactory
     */
    expectedMetricsCollectionInterval?: number;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    changeConfigMap?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    changeConfigMapNamespace?: string;
    /**
     * 
     * @type {number}
     * @memberof KubernetesContainerFactory
     */
    percentMemoryPadding?: number;
    /**
     * 
     * @type {number}
     * @memberof KubernetesContainerFactory
     */
    cpuOverCommitRatio?: number;
    /**
     * 
     * @type {number}
     * @memberof KubernetesContainerFactory
     */
    memoryOverCommitRatio?: number;
    /**
     * 
     * @type {number}
     * @memberof KubernetesContainerFactory
     */
    grpcPort?: number;
    /**
     * 
     * @type {number}
     * @memberof KubernetesContainerFactory
     */
    metricsPort?: number;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    narExtractionDirectory?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesContainerFactory
     */
    functionInstanceClassPath?: string;
    /**
     * 
     * @type {number}
     * @memberof KubernetesContainerFactory
     */
    gracePeriodSeconds?: number;
}

/**
 * 
 * @export
 * @interface LedgerDetails
 */
export interface LedgerDetails {
    /**
     * 
     * @type {number}
     * @memberof LedgerDetails
     */
    entries?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerDetails
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerDetails
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerDetails
     */
    ledgerId?: number;
}

/**
 * 
 * @export
 * @interface LedgerInfo
 */
export interface LedgerInfo {
    /**
     * 
     * @type {number}
     * @memberof LedgerInfo
     */
    ledgerId?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerInfo
     */
    entries?: number;
    /**
     * 
     * @type {number}
     * @memberof LedgerInfo
     */
    size?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LedgerInfo
     */
    offloaded?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LedgerInfo
     */
    metadata?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LedgerInfo
     */
    underReplicated?: boolean;
}

/**
 * 
 * @export
 * @interface LinkedNode
 */
export interface LinkedNode {
}

/**
 * 
 * @export
 * @interface LinkedNodeDeserializationProblemHandler
 */
export interface LinkedNodeDeserializationProblemHandler {
}

/**
 * 
 * @export
 * @interface LoadReport
 */
export interface LoadReport {
    /**
     * 
     * @type {string}
     * @memberof LoadReport
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadReport
     */
    brokerVersionString?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadReport
     */
    webServiceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadReport
     */
    webServiceUrlTls?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadReport
     */
    pulsarServiceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoadReport
     */
    pulsarServiceUrlTls?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LoadReport
     */
    persistentTopicsEnabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoadReport
     */
    nonPersistentTopicsEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    msgRateIn?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    msgRateOut?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    numTopics?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    numConsumers?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    numProducers?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    numBundles?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof LoadReport
     */
    protocols?: { [key: string]: string; };
    /**
     * 
     * @type {SystemResourceUsage}
     * @memberof LoadReport
     */
    systemResourceUsage?: SystemResourceUsage;
    /**
     * 
     * @type {{ [key: string]: NamespaceBundleStats; }}
     * @memberof LoadReport
     */
    bundleStats?: { [key: string]: NamespaceBundleStats; };
    /**
     * 
     * @type {Array<string>}
     * @memberof LoadReport
     */
    bundleGains?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoadReport
     */
    bundleLosses?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    allocatedCPU?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    allocatedMemory?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    allocatedBandwidthIn?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    allocatedBandwidthOut?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    allocatedMsgRateIn?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    allocatedMsgRateOut?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    preAllocatedCPU?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    preAllocatedMemory?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    preAllocatedBandwidthIn?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    preAllocatedBandwidthOut?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    preAllocatedMsgRateIn?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    preAllocatedMsgRateOut?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LoadReport
     */
    underLoaded?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LoadReport
     */
    overLoaded?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LoadReport
     */
    loadReportType?: string;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof LoadReport
     */
    memory?: ResourceUsage;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof LoadReport
     */
    cpu?: ResourceUsage;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof LoadReport
     */
    directMemory?: ResourceUsage;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    lastUpdate?: number;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof LoadReport
     */
    bandwidthIn?: ResourceUsage;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    msgThroughputIn?: number;
    /**
     * 
     * @type {number}
     * @memberof LoadReport
     */
    msgThroughputOut?: number;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof LoadReport
     */
    bandwidthOut?: ResourceUsage;
}

/**
 * 
 * @export
 * @interface Locale
 */
export interface Locale {
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    language?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    script?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    variant?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    country?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Locale
     */
    unicodeLocaleAttributes?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Locale
     */
    unicodeLocaleKeys?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    displayLanguage?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    displayScript?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    displayCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    displayVariant?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Locale
     */
    extensionKeys?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    iso3Language?: string;
    /**
     * 
     * @type {string}
     * @memberof Locale
     */
    iso3Country?: string;
}

/**
 * 
 * @export
 * @interface LongBuilder
 */
export interface LongBuilder {
}

/**
 * 
 * @export
 * @interface LongRunningProcessStatus
 */
export interface LongRunningProcessStatus {
    /**
     * 
     * @type {string}
     * @memberof LongRunningProcessStatus
     */
    status?: LongRunningProcessStatus.StatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LongRunningProcessStatus
     */
    lastError?: string;
}

/**
 * @export
 * @namespace LongRunningProcessStatus
 */
export namespace LongRunningProcessStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        NOTRUN = <any> 'NOT_RUN',
        RUNNING = <any> 'RUNNING',
        SUCCESS = <any> 'SUCCESS',
        ERROR = <any> 'ERROR'
    }
}

/**
 * 
 * @export
 * @interface LongSchemaVersion
 */
export interface LongSchemaVersion {
    /**
     * 
     * @type {number}
     * @memberof LongSchemaVersion
     */
    version?: number;
}

/**
 * 
 * @export
 * @interface MemoryLimit
 */
export interface MemoryLimit {
    /**
     * 
     * @type {number}
     * @memberof MemoryLimit
     */
    absoluteValue?: number;
    /**
     * 
     * @type {number}
     * @memberof MemoryLimit
     */
    percentOfMaxDirectMemory?: number;
}

/**
 * 
 * @export
 * @interface MessageId
 */
export interface MessageId {
}

/**
 * 
 * @export
 * @interface Metrics
 */
export interface Metrics {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Metrics
     */
    metrics?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Metrics
     */
    dimensions?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface ModelPackage
 */
export interface ModelPackage {
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    name?: string;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof ModelPackage
     */
    annotations?: Array<Annotation>;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof ModelPackage
     */
    declaredAnnotations?: Array<Annotation>;
    /**
     * 
     * @type {boolean}
     * @memberof ModelPackage
     */
    sealed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    specificationTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    specificationVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    specificationVendor?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    implementationTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    implementationVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPackage
     */
    implementationVendor?: string;
}

/**
 * 
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    name?: string;
    /**
     * 
     * @type {ClassLoader}
     * @memberof Module
     */
    classLoader?: ClassLoader;
    /**
     * 
     * @type {ModuleDescriptor}
     * @memberof Module
     */
    descriptor?: ModuleDescriptor;
    /**
     * 
     * @type {boolean}
     * @memberof Module
     */
    named?: boolean;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof Module
     */
    annotations?: Array<Annotation>;
    /**
     * 
     * @type {Array<Annotation>}
     * @memberof Module
     */
    declaredAnnotations?: Array<Annotation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Module
     */
    packages?: Array<string>;
    /**
     * 
     * @type {ModuleLayer}
     * @memberof Module
     */
    layer?: ModuleLayer;
}

/**
 * 
 * @export
 * @interface ModuleDescriptor
 */
export interface ModuleDescriptor {
    /**
     * 
     * @type {boolean}
     * @memberof ModuleDescriptor
     */
    open?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModuleDescriptor
     */
    automatic?: boolean;
}

/**
 * 
 * @export
 * @interface ModuleLayer
 */
export interface ModuleLayer {
}

/**
 * 
 * @export
 * @interface NamespaceBundleStats
 */
export interface NamespaceBundleStats {
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    msgRateIn?: number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    msgThroughputIn?: number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    msgRateOut?: number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    msgThroughputOut?: number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    consumerCount?: number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    producerCount?: number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    topics?: number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceBundleStats
     */
    cacheSize?: number;
}

/**
 * The data of namespace isolation configuration
 * @export
 * @interface NamespaceIsolationData
 */
export interface NamespaceIsolationData {
    /**
     * The list of namespaces to apply this namespace isolation data
     * @type {Array<string>}
     * @memberof NamespaceIsolationData
     */
    namespaces?: Array<string>;
    /**
     * The list of primary brokers for serving the list of namespaces in this isolation policy
     * @type {Array<string>}
     * @memberof NamespaceIsolationData
     */
    primary?: Array<string>;
    /**
     * The list of secondary brokers for serving the list of namespaces in this isolation policy
     * @type {Array<string>}
     * @memberof NamespaceIsolationData
     */
    secondary?: Array<string>;
    /**
     * The data of auto-failover policy configuration
     * @type {AutoFailoverPolicyData}
     * @memberof NamespaceIsolationData
     */
    autoFailoverPolicy?: AutoFailoverPolicyData;
}

/**
 * 
 * @export
 * @interface NamespaceOwnershipStatus
 */
export interface NamespaceOwnershipStatus {
    /**
     * 
     * @type {string}
     * @memberof NamespaceOwnershipStatus
     */
    brokerAssignment?: NamespaceOwnershipStatus.BrokerAssignmentEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NamespaceOwnershipStatus
     */
    isControlled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NamespaceOwnershipStatus
     */
    isActive?: boolean;
}

/**
 * @export
 * @namespace NamespaceOwnershipStatus
 */
export namespace NamespaceOwnershipStatus {
    /**
     * @export
     * @enum {string}
     */
    export enum BrokerAssignmentEnum {
        Primary = <any> 'primary',
        Secondary = <any> 'secondary',
        Shared = <any> 'shared'
    }
}

/**
 * 
 * @export
 * @interface Number
 */
export interface Number {
}

/**
 * 
 * @export
 * @interface NumberFormat
 */
export interface NumberFormat {
    /**
     * 
     * @type {boolean}
     * @memberof NumberFormat
     */
    groupingUsed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumberFormat
     */
    parseIntegerOnly?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NumberFormat
     */
    maximumIntegerDigits?: number;
    /**
     * 
     * @type {number}
     * @memberof NumberFormat
     */
    minimumIntegerDigits?: number;
    /**
     * 
     * @type {number}
     * @memberof NumberFormat
     */
    maximumFractionDigits?: number;
    /**
     * 
     * @type {number}
     * @memberof NumberFormat
     */
    minimumFractionDigits?: number;
    /**
     * 
     * @type {string}
     * @memberof NumberFormat
     */
    roundingMode?: NumberFormat.RoundingModeEnum;
    /**
     * 
     * @type {Currency}
     * @memberof NumberFormat
     */
    currency?: Currency;
}

/**
 * @export
 * @namespace NumberFormat
 */
export namespace NumberFormat {
    /**
     * @export
     * @enum {string}
     */
    export enum RoundingModeEnum {
        UP = <any> 'UP',
        DOWN = <any> 'DOWN',
        CEILING = <any> 'CEILING',
        FLOOR = <any> 'FLOOR',
        HALFUP = <any> 'HALF_UP',
        HALFDOWN = <any> 'HALF_DOWN',
        HALFEVEN = <any> 'HALF_EVEN',
        UNNECESSARY = <any> 'UNNECESSARY'
    }
}

/**
 * 
 * @export
 * @interface ObjectCodec
 */
export interface ObjectCodec {
    /**
     * 
     * @type {JsonFactory}
     * @memberof ObjectCodec
     */
    factory?: JsonFactory;
    /**
     * 
     * @type {JsonFactory}
     * @memberof ObjectCodec
     */
    jsonFactory?: JsonFactory;
}

/**
 * 
 * @export
 * @interface ObjectMapper
 */
export interface ObjectMapper {
    /**
     * 
     * @type {JsonFactory}
     * @memberof ObjectMapper
     */
    factory?: JsonFactory;
    /**
     * 
     * @type {TypeFactory}
     * @memberof ObjectMapper
     */
    typeFactory?: TypeFactory;
    /**
     * 
     * @type {SerializationConfig}
     * @memberof ObjectMapper
     */
    serializationConfig?: SerializationConfig;
    /**
     * 
     * @type {DeserializationConfig}
     * @memberof ObjectMapper
     */
    deserializationConfig?: DeserializationConfig;
    /**
     * 
     * @type {DeserializationContext}
     * @memberof ObjectMapper
     */
    deserializationContext?: DeserializationContext;
    /**
     * 
     * @type {SerializerFactory}
     * @memberof ObjectMapper
     */
    serializerFactory?: SerializerFactory;
    /**
     * 
     * @type {SerializerProvider}
     * @memberof ObjectMapper
     */
    serializerProvider?: SerializerProvider;
    /**
     * 
     * @type {SerializerProvider}
     * @memberof ObjectMapper
     */
    serializerProviderInstance?: SerializerProvider;
    /**
     * 
     * @type {VisibilityCheckerObject}
     * @memberof ObjectMapper
     */
    visibilityChecker?: VisibilityCheckerObject;
    /**
     * 
     * @type {SubtypeResolver}
     * @memberof ObjectMapper
     */
    subtypeResolver?: SubtypeResolver;
    /**
     * 
     * @type {PropertyNamingStrategy}
     * @memberof ObjectMapper
     */
    propertyNamingStrategy?: PropertyNamingStrategy;
    /**
     * 
     * @type {JsonNodeFactory}
     * @memberof ObjectMapper
     */
    nodeFactory?: JsonNodeFactory;
    /**
     * 
     * @type {JsonFactory}
     * @memberof ObjectMapper
     */
    jsonFactory?: JsonFactory;
    /**
     * 
     * @type {DateFormat}
     * @memberof ObjectMapper
     */
    dateFormat?: DateFormat;
    /**
     * 
     * @type {InjectableValues}
     * @memberof ObjectMapper
     */
    injectableValues?: InjectableValues;
}

/**
 * 
 * @export
 * @interface OffloadPolicies
 */
export interface OffloadPolicies {
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadPrefetchRounds?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadDriver?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    offloadersDirectory?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadMaxThreads?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadThresholdInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadDeletionLagInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadedReadPriority?: OffloadPolicies.ManagedLedgerOffloadedReadPriorityEnum;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadServiceEndpoint?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadMaxBlockSizeInBytes?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadCredentialId?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadCredentialSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadRole?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadRoleSessionName?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    s3ManagedLedgerOffloadReadBufferSizeInBytes?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    gcsManagedLedgerOffloadRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    gcsManagedLedgerOffloadBucket?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    gcsManagedLedgerOffloadMaxBlockSizeInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    gcsManagedLedgerOffloadReadBufferSizeInBytes?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    gcsManagedLedgerOffloadServiceAccountKeyFile?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    fileSystemProfilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    fileSystemURI?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadServiceEndpoint?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadMaxBlockSizeInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPolicies
     */
    managedLedgerOffloadReadBufferSizeInBytes?: number;
}

/**
 * @export
 * @namespace OffloadPolicies
 */
export namespace OffloadPolicies {
    /**
     * @export
     * @enum {string}
     */
    export enum ManagedLedgerOffloadedReadPriorityEnum {
        BOOKKEEPERFIRST = <any> 'BOOKKEEPER_FIRST',
        TIEREDSTORAGEFIRST = <any> 'TIERED_STORAGE_FIRST'
    }
}

/**
 * 
 * @export
 * @interface OffloadPoliciesImpl
 */
export interface OffloadPoliciesImpl {
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    offloadersDirectory?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadDriver?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadMaxThreads?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadPrefetchRounds?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadThresholdInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadDeletionLagInMillis?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadedReadPriority?: OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriorityEnum;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadServiceEndpoint?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadMaxBlockSizeInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadReadBufferSizeInBytes?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadCredentialId?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadCredentialSecret?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadRole?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    s3ManagedLedgerOffloadRoleSessionName?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    gcsManagedLedgerOffloadRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    gcsManagedLedgerOffloadBucket?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    gcsManagedLedgerOffloadMaxBlockSizeInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    gcsManagedLedgerOffloadReadBufferSizeInBytes?: number;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    gcsManagedLedgerOffloadServiceAccountKeyFile?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    fileSystemProfilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    fileSystemURI?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadServiceEndpoint?: string;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadMaxBlockSizeInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof OffloadPoliciesImpl
     */
    managedLedgerOffloadReadBufferSizeInBytes?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OffloadPoliciesImpl
     */
    s3Driver?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OffloadPoliciesImpl
     */
    gcsDriver?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OffloadPoliciesImpl
     */
    fileSystemDriver?: boolean;
}

/**
 * @export
 * @namespace OffloadPoliciesImpl
 */
export namespace OffloadPoliciesImpl {
    /**
     * @export
     * @enum {string}
     */
    export enum ManagedLedgerOffloadedReadPriorityEnum {
        BOOKKEEPERFIRST = <any> 'BOOKKEEPER_FIRST',
        TIEREDSTORAGEFIRST = <any> 'TIERED_STORAGE_FIRST'
    }
}

/**
 * 
 * @export
 * @interface OutputDecorator
 */
export interface OutputDecorator {
}

/**
 * 
 * @export
 * @interface OutputStream
 */
export interface OutputStream {
}

/**
 * 
 * @export
 * @interface PartitionedTopicMetadata
 */
export interface PartitionedTopicMetadata {
    /**
     * 
     * @type {number}
     * @memberof PartitionedTopicMetadata
     */
    partitions?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PartitionedTopicMetadata
     */
    properties?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface PendingBookieOpsStats
 */
export interface PendingBookieOpsStats {
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    dataLedgerOpenOp?: number;
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    dataLedgerCloseOp?: number;
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    dataLedgerCreateOp?: number;
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    dataLedgerDeleteOp?: number;
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    cursorLedgerOpenOp?: number;
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    cursorLedgerCloseOp?: number;
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    cursorLedgerCreateOp?: number;
    /**
     * 
     * @type {number}
     * @memberof PendingBookieOpsStats
     */
    cursorLedgerDeleteOp?: number;
}

/**
 * 
 * @export
 * @interface PersistencePolicies
 */
export interface PersistencePolicies {
    /**
     * 
     * @type {number}
     * @memberof PersistencePolicies
     */
    bookkeeperEnsemble?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistencePolicies
     */
    bookkeeperWriteQuorum?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistencePolicies
     */
    bookkeeperAckQuorum?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistencePolicies
     */
    managedLedgerMaxMarkDeleteRate?: number;
}

/**
 * 
 * @export
 * @interface PersistentOfflineTopicStats
 */
export interface PersistentOfflineTopicStats {
    /**
     * 
     * @type {number}
     * @memberof PersistentOfflineTopicStats
     */
    storageSize?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistentOfflineTopicStats
     */
    totalMessages?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistentOfflineTopicStats
     */
    messageBacklog?: number;
    /**
     * 
     * @type {string}
     * @memberof PersistentOfflineTopicStats
     */
    brokerName?: string;
    /**
     * 
     * @type {string}
     * @memberof PersistentOfflineTopicStats
     */
    topicName?: string;
    /**
     * 
     * @type {Array<LedgerDetails>}
     * @memberof PersistentOfflineTopicStats
     */
    dataLedgerDetails?: Array<LedgerDetails>;
    /**
     * 
     * @type {{ [key: string]: CursorDetails; }}
     * @memberof PersistentOfflineTopicStats
     */
    cursorDetails?: { [key: string]: CursorDetails; };
    /**
     * 
     * @type {Date}
     * @memberof PersistentOfflineTopicStats
     */
    statGeneratedAt?: Date;
}

/**
 * 
 * @export
 * @interface PersistentTopicInternalStats
 */
export interface PersistentTopicInternalStats {
    /**
     * 
     * @type {number}
     * @memberof PersistentTopicInternalStats
     */
    entriesAddedCounter?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistentTopicInternalStats
     */
    numberOfEntries?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistentTopicInternalStats
     */
    totalSize?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistentTopicInternalStats
     */
    currentLedgerEntries?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistentTopicInternalStats
     */
    currentLedgerSize?: number;
    /**
     * 
     * @type {string}
     * @memberof PersistentTopicInternalStats
     */
    lastLedgerCreatedTimestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof PersistentTopicInternalStats
     */
    lastLedgerCreationFailureTimestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof PersistentTopicInternalStats
     */
    waitingCursorsCount?: number;
    /**
     * 
     * @type {number}
     * @memberof PersistentTopicInternalStats
     */
    pendingAddEntriesCount?: number;
    /**
     * 
     * @type {string}
     * @memberof PersistentTopicInternalStats
     */
    lastConfirmedEntry?: string;
    /**
     * 
     * @type {string}
     * @memberof PersistentTopicInternalStats
     */
    state?: string;
    /**
     * 
     * @type {Array<LedgerInfo>}
     * @memberof PersistentTopicInternalStats
     */
    ledgers?: Array<LedgerInfo>;
    /**
     * 
     * @type {{ [key: string]: CursorStats; }}
     * @memberof PersistentTopicInternalStats
     */
    cursors?: { [key: string]: CursorStats; };
    /**
     * 
     * @type {Array<LedgerInfo>}
     * @memberof PersistentTopicInternalStats
     */
    schemaLedgers?: Array<LedgerInfo>;
    /**
     * 
     * @type {LedgerInfo}
     * @memberof PersistentTopicInternalStats
     */
    compactedLedger?: LedgerInfo;
}

/**
 * 
 * @export
 * @interface Policies
 */
export interface Policies {
    /**
     * 
     * @type {AuthPolicies}
     * @memberof Policies
     */
    authPolicies?: AuthPolicies;
    /**
     * 
     * @type {Array<string>}
     * @memberof Policies
     */
    replicationClusters?: Array<string>;
    /**
     * 
     * @type {BundlesData}
     * @memberof Policies
     */
    bundles?: BundlesData;
    /**
     * 
     * @type {{ [key: string]: BacklogQuota; }}
     * @memberof Policies
     */
    backlogQuotaMap?: { [key: string]: BacklogQuota; };
    /**
     * 
     * @type {{ [key: string]: DispatchRateImpl; }}
     * @memberof Policies
     */
    clusterDispatchRate?: { [key: string]: DispatchRateImpl; };
    /**
     * 
     * @type {{ [key: string]: DispatchRateImpl; }}
     * @memberof Policies
     */
    topicDispatchRate?: { [key: string]: DispatchRateImpl; };
    /**
     * 
     * @type {{ [key: string]: DispatchRateImpl; }}
     * @memberof Policies
     */
    subscriptionDispatchRate?: { [key: string]: DispatchRateImpl; };
    /**
     * 
     * @type {{ [key: string]: DispatchRateImpl; }}
     * @memberof Policies
     */
    replicatorDispatchRate?: { [key: string]: DispatchRateImpl; };
    /**
     * 
     * @type {{ [key: string]: SubscribeRate; }}
     * @memberof Policies
     */
    clusterSubscribeRate?: { [key: string]: SubscribeRate; };
    /**
     * 
     * @type {PersistencePolicies}
     * @memberof Policies
     */
    persistence?: PersistencePolicies;
    /**
     * 
     * @type {boolean}
     * @memberof Policies
     */
    deduplicationEnabled?: boolean;
    /**
     * 
     * @type {AutoTopicCreationOverride}
     * @memberof Policies
     */
    autoTopicCreationOverride?: AutoTopicCreationOverride;
    /**
     * 
     * @type {AutoSubscriptionCreationOverride}
     * @memberof Policies
     */
    autoSubscriptionCreationOverride?: AutoSubscriptionCreationOverride;
    /**
     * 
     * @type {{ [key: string]: PublishRate; }}
     * @memberof Policies
     */
    publishMaxMessageRate?: { [key: string]: PublishRate; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof Policies
     */
    latencyStatsSampleRate?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    messageTtlInSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    subscriptionExpirationTimeMinutes?: number;
    /**
     * 
     * @type {RetentionPolicies}
     * @memberof Policies
     */
    retentionPolicies?: RetentionPolicies;
    /**
     * 
     * @type {boolean}
     * @memberof Policies
     */
    deleted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Policies
     */
    encryptionRequired?: boolean;
    /**
     * 
     * @type {DelayedDeliveryPolicies}
     * @memberof Policies
     */
    delayedDeliveryPolicies?: DelayedDeliveryPolicies;
    /**
     * 
     * @type {InactiveTopicPolicies}
     * @memberof Policies
     */
    inactiveTopicPolicies?: InactiveTopicPolicies;
    /**
     * 
     * @type {string}
     * @memberof Policies
     */
    subscriptionAuthMode?: Policies.SubscriptionAuthModeEnum;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    maxProducersPerTopic?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    maxConsumersPerTopic?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    maxConsumersPerSubscription?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    maxUnackedMessagesPerConsumer?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    maxUnackedMessagesPerSubscription?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    maxSubscriptionsPerTopic?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    compactionThreshold?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    offloadThreshold?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    offloadDeletionLagMs?: number;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    maxTopicsPerNamespace?: number;
    /**
     * 
     * @type {string}
     * @memberof Policies
     */
    schemaAutoUpdateCompatibilityStrategy?: Policies.SchemaAutoUpdateCompatibilityStrategyEnum;
    /**
     * 
     * @type {string}
     * @memberof Policies
     */
    schemaCompatibilityStrategy?: Policies.SchemaCompatibilityStrategyEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Policies
     */
    isAllowAutoUpdateSchema?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Policies
     */
    schemaValidationEnforced?: boolean;
    /**
     * 
     * @type {OffloadPolicies}
     * @memberof Policies
     */
    offloadPolicies?: OffloadPolicies;
    /**
     * 
     * @type {number}
     * @memberof Policies
     */
    deduplicationSnapshotIntervalSeconds?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Policies
     */
    subscriptionTypesEnabled?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Policies
     */
    properties?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Policies
     */
    resourceGroupName?: string;
}

/**
 * @export
 * @namespace Policies
 */
export namespace Policies {
    /**
     * @export
     * @enum {string}
     */
    export enum SubscriptionAuthModeEnum {
        None = <any> 'None',
        Prefix = <any> 'Prefix'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SchemaAutoUpdateCompatibilityStrategyEnum {
        AutoUpdateDisabled = <any> 'AutoUpdateDisabled',
        Backward = <any> 'Backward',
        Forward = <any> 'Forward',
        Full = <any> 'Full',
        AlwaysCompatible = <any> 'AlwaysCompatible',
        BackwardTransitive = <any> 'BackwardTransitive',
        ForwardTransitive = <any> 'ForwardTransitive',
        FullTransitive = <any> 'FullTransitive'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SchemaCompatibilityStrategyEnum {
        UNDEFINED = <any> 'UNDEFINED',
        ALWAYSINCOMPATIBLE = <any> 'ALWAYS_INCOMPATIBLE',
        ALWAYSCOMPATIBLE = <any> 'ALWAYS_COMPATIBLE',
        BACKWARD = <any> 'BACKWARD',
        FORWARD = <any> 'FORWARD',
        FULL = <any> 'FULL',
        BACKWARDTRANSITIVE = <any> 'BACKWARD_TRANSITIVE',
        FORWARDTRANSITIVE = <any> 'FORWARD_TRANSITIVE',
        FULLTRANSITIVE = <any> 'FULL_TRANSITIVE'
    }
}

/**
 * 
 * @export
 * @interface PoolArenaStats
 */
export interface PoolArenaStats {
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numSmallSubpages?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numChunkLists?: number;
    /**
     * 
     * @type {Array<PoolSubpageStats>}
     * @memberof PoolArenaStats
     */
    smallSubpages?: Array<PoolSubpageStats>;
    /**
     * 
     * @type {Array<PoolChunkListStats>}
     * @memberof PoolArenaStats
     */
    chunkLists?: Array<PoolChunkListStats>;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numAllocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numSmallAllocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numNormalAllocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numHugeAllocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numDeallocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numSmallDeallocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numNormalDeallocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numHugeDeallocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numActiveAllocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numActiveSmallAllocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numActiveNormalAllocations?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolArenaStats
     */
    numActiveHugeAllocations?: number;
}

/**
 * 
 * @export
 * @interface PoolChunkListStats
 */
export interface PoolChunkListStats {
    /**
     * 
     * @type {number}
     * @memberof PoolChunkListStats
     */
    minUsage?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolChunkListStats
     */
    maxUsage?: number;
    /**
     * 
     * @type {Array<PoolChunkStats>}
     * @memberof PoolChunkListStats
     */
    chunks?: Array<PoolChunkStats>;
}

/**
 * 
 * @export
 * @interface PoolChunkStats
 */
export interface PoolChunkStats {
    /**
     * 
     * @type {number}
     * @memberof PoolChunkStats
     */
    usage?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolChunkStats
     */
    chunkSize?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolChunkStats
     */
    freeBytes?: number;
}

/**
 * 
 * @export
 * @interface PoolSubpageStats
 */
export interface PoolSubpageStats {
    /**
     * 
     * @type {number}
     * @memberof PoolSubpageStats
     */
    maxNumElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolSubpageStats
     */
    numAvailable?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolSubpageStats
     */
    elementSize?: number;
    /**
     * 
     * @type {number}
     * @memberof PoolSubpageStats
     */
    pageSize?: number;
}

/**
 * 
 * @export
 * @interface PostSchemaPayload
 */
export interface PostSchemaPayload {
    /**
     * 
     * @type {string}
     * @memberof PostSchemaPayload
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PostSchemaPayload
     */
    schema?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PostSchemaPayload
     */
    properties?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface PostSchemaResponse
 */
export interface PostSchemaResponse {
    /**
     * 
     * @type {SchemaVersion}
     * @memberof PostSchemaResponse
     */
    version?: SchemaVersion;
}

/**
 * 
 * @export
 * @interface PrettyPrinter
 */
export interface PrettyPrinter {
}

/**
 * 
 * @export
 * @interface ProcessContainerFactory
 */
export interface ProcessContainerFactory {
    /**
     * 
     * @type {string}
     * @memberof ProcessContainerFactory
     */
    javaInstanceJarLocation?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessContainerFactory
     */
    pythonInstanceLocation?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessContainerFactory
     */
    logDirectory?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessContainerFactory
     */
    extraFunctionDependenciesDir?: string;
}

/**
 * 
 * @export
 * @interface PropertyName
 */
export interface PropertyName {
    /**
     * 
     * @type {boolean}
     * @memberof PropertyName
     */
    empty?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PropertyName
     */
    simpleName?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyName
     */
    namespace?: string;
}

/**
 * 
 * @export
 * @interface PropertyNamingStrategy
 */
export interface PropertyNamingStrategy {
}

/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {Array<string>}
     * @memberof PublicKey
     */
    encoded?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    format?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    algorithm?: string;
}

/**
 * 
 * @export
 * @interface PublishRate
 */
export interface PublishRate {
    /**
     * 
     * @type {number}
     * @memberof PublishRate
     */
    publishThrottlingRateInMsg?: number;
    /**
     * 
     * @type {number}
     * @memberof PublishRate
     */
    publishThrottlingRateInByte?: number;
}

/**
 * 
 * @export
 * @interface RawBookieInfo
 */
export interface RawBookieInfo {
    /**
     * 
     * @type {string}
     * @memberof RawBookieInfo
     */
    bookieId?: string;
}

/**
 * 
 * @export
 * @interface ResetCursorData
 */
export interface ResetCursorData {
    /**
     * 
     * @type {number}
     * @memberof ResetCursorData
     */
    ledgerId?: number;
    /**
     * 
     * @type {number}
     * @memberof ResetCursorData
     */
    entryId?: number;
    /**
     * 
     * @type {number}
     * @memberof ResetCursorData
     */
    partitionIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof ResetCursorData
     */
    batchIndex?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ResetCursorData
     */
    properties?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof ResetCursorData
     */
    excluded?: boolean;
}

/**
 * 
 * @export
 * @interface ResourceDescription
 */
export interface ResourceDescription {
    /**
     * 
     * @type {number}
     * @memberof ResourceDescription
     */
    usagePct?: number;
    /**
     * 
     * @type {{ [key: string]: ResourceUsage; }}
     * @memberof ResourceDescription
     */
    resourceUsage?: { [key: string]: ResourceUsage; };
}

/**
 * 
 * @export
 * @interface ResourceGroup
 */
export interface ResourceGroup {
    /**
     * 
     * @type {number}
     * @memberof ResourceGroup
     */
    publishRateInMsgs?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceGroup
     */
    publishRateInBytes?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceGroup
     */
    dispatchRateInMsgs?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceGroup
     */
    dispatchRateInBytes?: number;
}

/**
 * 
 * @export
 * @interface ResourceQuota
 */
export interface ResourceQuota {
    /**
     * 
     * @type {number}
     * @memberof ResourceQuota
     */
    msgRateIn?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceQuota
     */
    msgRateOut?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceQuota
     */
    bandwidthIn?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceQuota
     */
    bandwidthOut?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceQuota
     */
    memory?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ResourceQuota
     */
    dynamic?: boolean;
}

/**
 * 
 * @export
 * @interface ResourceUnit
 */
export interface ResourceUnit {
    /**
     * 
     * @type {string}
     * @memberof ResourceUnit
     */
    resourceId?: string;
    /**
     * 
     * @type {ResourceDescription}
     * @memberof ResourceUnit
     */
    availableResource?: ResourceDescription;
}

/**
 * 
 * @export
 * @interface ResourceUsage
 */
export interface ResourceUsage {
    /**
     * 
     * @type {number}
     * @memberof ResourceUsage
     */
    usage?: number;
    /**
     * 
     * @type {number}
     * @memberof ResourceUsage
     */
    limit?: number;
}

/**
 * 
 * @export
 * @interface Resources
 */
export interface Resources {
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    cpu?: number;
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    ram?: number;
    /**
     * 
     * @type {number}
     * @memberof Resources
     */
    disk?: number;
}

/**
 * 
 * @export
 * @interface RetentionPolicies
 */
export interface RetentionPolicies {
    /**
     * 
     * @type {number}
     * @memberof RetentionPolicies
     */
    retentionTimeInMinutes?: number;
    /**
     * 
     * @type {number}
     * @memberof RetentionPolicies
     */
    retentionSizeInMB?: number;
}

/**
 * 
 * @export
 * @interface SchemaVersion
 */
export interface SchemaVersion {
}

/**
 * 
 * @export
 * @interface SerializationConfig
 */
export interface SerializationConfig {
    /**
     * 
     * @type {AnnotationIntrospector}
     * @memberof SerializationConfig
     */
    annotationIntrospector?: AnnotationIntrospector;
    /**
     * 
     * @type {Value}
     * @memberof SerializationConfig
     */
    defaultPropertyInclusion?: Value;
    /**
     * 
     * @type {FilterProvider}
     * @memberof SerializationConfig
     */
    filterProvider?: FilterProvider;
    /**
     * 
     * @type {PrettyPrinter}
     * @memberof SerializationConfig
     */
    defaultPrettyPrinter?: PrettyPrinter;
    /**
     * 
     * @type {string}
     * @memberof SerializationConfig
     */
    serializationInclusion?: SerializationConfig.SerializationInclusionEnum;
    /**
     * 
     * @type {number}
     * @memberof SerializationConfig
     */
    serializationFeatures?: number;
    /**
     * 
     * @type {ContextAttributes}
     * @memberof SerializationConfig
     */
    attributes?: ContextAttributes;
    /**
     * 
     * @type {string}
     * @memberof SerializationConfig
     */
    rootName?: string;
    /**
     * 
     * @type {SubtypeResolver}
     * @memberof SerializationConfig
     */
    subtypeResolver?: SubtypeResolver;
    /**
     * 
     * @type {PropertyName}
     * @memberof SerializationConfig
     */
    fullRootName?: PropertyName;
    /**
     * 
     * @type {VisibilityCheckerObject}
     * @memberof SerializationConfig
     */
    defaultVisibilityChecker?: VisibilityCheckerObject;
    /**
     * 
     * @type {Locale}
     * @memberof SerializationConfig
     */
    locale?: Locale;
    /**
     * 
     * @type {TimeZone}
     * @memberof SerializationConfig
     */
    timeZone?: TimeZone;
    /**
     * 
     * @type {TypeFactory}
     * @memberof SerializationConfig
     */
    typeFactory?: TypeFactory;
    /**
     * 
     * @type {PropertyNamingStrategy}
     * @memberof SerializationConfig
     */
    propertyNamingStrategy?: PropertyNamingStrategy;
    /**
     * 
     * @type {HandlerInstantiator}
     * @memberof SerializationConfig
     */
    handlerInstantiator?: HandlerInstantiator;
    /**
     * 
     * @type {DateFormat}
     * @memberof SerializationConfig
     */
    dateFormat?: DateFormat;
    /**
     * 
     * @type {Base64Variant}
     * @memberof SerializationConfig
     */
    base64Variant?: Base64Variant;
    /**
     * 
     * @type {boolean}
     * @memberof SerializationConfig
     */
    annotationProcessingEnabled?: boolean;
    /**
     * 
     * @type {ClassIntrospector}
     * @memberof SerializationConfig
     */
    classIntrospector?: ClassIntrospector;
}

/**
 * @export
 * @namespace SerializationConfig
 */
export namespace SerializationConfig {
    /**
     * @export
     * @enum {string}
     */
    export enum SerializationInclusionEnum {
        ALWAYS = <any> 'ALWAYS',
        NONNULL = <any> 'NON_NULL',
        NONABSENT = <any> 'NON_ABSENT',
        NONEMPTY = <any> 'NON_EMPTY',
        NONDEFAULT = <any> 'NON_DEFAULT',
        USEDEFAULTS = <any> 'USE_DEFAULTS'
    }
}

/**
 * 
 * @export
 * @interface SerializerFactory
 */
export interface SerializerFactory {
}

/**
 * 
 * @export
 * @interface SerializerProvider
 */
export interface SerializerProvider {
    /**
     * 
     * @type {Locale}
     * @memberof SerializerProvider
     */
    locale?: Locale;
    /**
     * 
     * @type {TimeZone}
     * @memberof SerializerProvider
     */
    timeZone?: TimeZone;
    /**
     * 
     * @type {SerializationConfig}
     * @memberof SerializerProvider
     */
    config?: SerializationConfig;
    /**
     * 
     * @type {TypeFactory}
     * @memberof SerializerProvider
     */
    typeFactory?: TypeFactory;
    /**
     * 
     * @type {AnnotationIntrospector}
     * @memberof SerializerProvider
     */
    annotationIntrospector?: AnnotationIntrospector;
    /**
     * 
     * @type {JsonSerializerObject}
     * @memberof SerializerProvider
     */
    defaultNullValueSerializer?: JsonSerializerObject;
    /**
     * 
     * @type {FilterProvider}
     * @memberof SerializerProvider
     */
    filterProvider?: FilterProvider;
    /**
     * 
     * @type {JsonSerializerObject}
     * @memberof SerializerProvider
     */
    defaultNullKeySerializer?: JsonSerializerObject;
    /**
     * 
     * @type {JsonGenerator}
     * @memberof SerializerProvider
     */
    generator?: JsonGenerator;
}

/**
 * 
 * @export
 * @interface ShortBuilder
 */
export interface ShortBuilder {
}

/**
 * 
 * @export
 * @interface Sinks
 */
export interface Sinks {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof Sinks
     */
    sinkList?: Array<ConnectorDefinition>;
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof Sinks
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface SinksWorkerService
 */
export interface SinksWorkerService {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof SinksWorkerService
     */
    sinkList?: Array<ConnectorDefinition>;
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof SinksWorkerService
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface SocketAddress
 */
export interface SocketAddress {
}

/**
 * 
 * @export
 * @interface Sources
 */
export interface Sources {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof Sources
     */
    sourceList?: Array<ConnectorDefinition>;
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof Sources
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface SourcesWorkerService
 */
export interface SourcesWorkerService {
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof SourcesWorkerService
     */
    sourceList?: Array<ConnectorDefinition>;
    /**
     * 
     * @type {Array<ConnectorDefinition>}
     * @memberof SourcesWorkerService
     */
    listOfConnectors?: Array<ConnectorDefinition>;
}

/**
 * 
 * @export
 * @interface SubscribeRate
 */
export interface SubscribeRate {
    /**
     * 
     * @type {number}
     * @memberof SubscribeRate
     */
    subscribeThrottlingRatePerConsumer?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscribeRate
     */
    ratePeriodInSecond?: number;
}

/**
 * 
 * @export
 * @interface SubtypeResolver
 */
export interface SubtypeResolver {
}

/**
 * 
 * @export
 * @interface SystemResourceUsage
 */
export interface SystemResourceUsage {
    /**
     * 
     * @type {ResourceUsage}
     * @memberof SystemResourceUsage
     */
    bandwidthIn?: ResourceUsage;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof SystemResourceUsage
     */
    bandwidthOut?: ResourceUsage;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof SystemResourceUsage
     */
    cpu?: ResourceUsage;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof SystemResourceUsage
     */
    memory?: ResourceUsage;
    /**
     * 
     * @type {ResourceUsage}
     * @memberof SystemResourceUsage
     */
    directMemory?: ResourceUsage;
}

/**
 * Information of adminRoles and allowedClusters for tenant
 * @export
 * @interface TenantInfo
 */
export interface TenantInfo {
    /**
     * Comma separated list of auth principal allowed to administrate the tenant.
     * @type {Array<string>}
     * @memberof TenantInfo
     */
    adminRoles?: Array<string>;
    /**
     * Comma separated allowed clusters.
     * @type {Array<string>}
     * @memberof TenantInfo
     */
    allowedClusters?: Array<string>;
}

/**
 * 
 * @export
 * @interface ThreadContainerFactory
 */
export interface ThreadContainerFactory {
    /**
     * 
     * @type {string}
     * @memberof ThreadContainerFactory
     */
    threadGroupName?: string;
    /**
     * 
     * @type {MemoryLimit}
     * @memberof ThreadContainerFactory
     */
    pulsarClientMemoryLimit?: MemoryLimit;
}

/**
 * 
 * @export
 * @interface TimeZone
 */
export interface TimeZone {
    /**
     * 
     * @type {string}
     * @memberof TimeZone
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeZone
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeZone
     */
    dstsavings?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeZone
     */
    rawOffset?: number;
}

/**
 * 
 * @export
 * @interface TypeBindings
 */
export interface TypeBindings {
    /**
     * 
     * @type {boolean}
     * @memberof TypeBindings
     */
    empty?: boolean;
    /**
     * 
     * @type {Array<JavaType>}
     * @memberof TypeBindings
     */
    typeParameters?: Array<JavaType>;
}

/**
 * 
 * @export
 * @interface TypeFactory
 */
export interface TypeFactory {
    /**
     * 
     * @type {ClassLoader}
     * @memberof TypeFactory
     */
    classLoader?: ClassLoader;
}

/**
 * 
 * @export
 * @interface Value
 */
export interface Value {
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    contentInclusion?: Value.ContentInclusionEnum;
    /**
     * 
     * @type {string}
     * @memberof Value
     */
    valueInclusion?: Value.ValueInclusionEnum;
}

/**
 * @export
 * @namespace Value
 */
export namespace Value {
    /**
     * @export
     * @enum {string}
     */
    export enum ContentInclusionEnum {
        ALWAYS = <any> 'ALWAYS',
        NONNULL = <any> 'NON_NULL',
        NONABSENT = <any> 'NON_ABSENT',
        NONEMPTY = <any> 'NON_EMPTY',
        NONDEFAULT = <any> 'NON_DEFAULT',
        USEDEFAULTS = <any> 'USE_DEFAULTS'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ValueInclusionEnum {
        ALWAYS = <any> 'ALWAYS',
        NONNULL = <any> 'NON_NULL',
        NONABSENT = <any> 'NON_ABSENT',
        NONEMPTY = <any> 'NON_EMPTY',
        NONDEFAULT = <any> 'NON_DEFAULT',
        USEDEFAULTS = <any> 'USE_DEFAULTS'
    }
}

/**
 * 
 * @export
 * @interface VisibilityChecker
 */
export interface VisibilityChecker {
}

/**
 * 
 * @export
 * @interface VisibilityCheckerObject
 */
export interface VisibilityCheckerObject {
}

/**
 * 
 * @export
 * @interface WorkerConfig
 */
export interface WorkerConfig {
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    workerId?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    workerHostname?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    workerPort?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    workerPortTls?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    authenticateMetricsEndpoint?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    includeStandardPrometheusMetrics?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    jvmGCMetricsLoggerClassName?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    numHttpServerThreads?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    httpRequestsLimitEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    httpRequestsMaxPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    maxConcurrentHttpRequests?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    httpServerThreadPoolQueueSize?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    httpServerAcceptQueueSize?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    maxHttpServerConnections?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    configurationStoreServers?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    configurationMetadataStoreUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    metadataStoreSessionTimeoutMillis?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    metadataStoreOperationTimeoutSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    metadataStoreCacheExpirySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    zooKeeperSessionTimeoutMillis?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    zooKeeperOperationTimeoutSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    zooKeeperCacheExpirySeconds?: number;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    connectorsDirectory?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    narExtractionDirectory?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    validateConnectorConfig?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    uploadBuiltinSinksSources?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionsDirectory?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionMetadataTopicName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    useCompactedMetadataTopic?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionWebServiceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    pulsarServiceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    pulsarWebServiceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    clusterCoordinationTopicName?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    pulsarFunctionsNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    pulsarFunctionsCluster?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    numFunctionPackageReplicas?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    functionsWorkerEnablePackageManagement?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    downloadDirectory?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    stateStorageServiceUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    stateStorageProviderImplementation?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionAssignmentTopicName?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    schedulerClassName?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    failureCheckFreqMs?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    rescheduleTimeoutMs?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    rebalanceCheckFreqSec?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    workerListProbeIntervalSec?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    initialBrokerReconnectMaxRetries?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    assignmentWriteMaxRetries?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    instanceLivenessCheckFreqMs?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    brokerClientAuthenticationEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    brokerClientAuthenticationPlugin?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    brokerClientAuthenticationParameters?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    bookkeeperClientAuthenticationPlugin?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    bookkeeperClientAuthenticationParametersName?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    bookkeeperClientAuthenticationParameters?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    topicCompactionFrequencySec?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    tlsEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsCertificateFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsKeyFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsTrustCertsFilePath?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    tlsAllowInsecureConnection?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    tlsRequireTrustedClientCertOnConnect?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    useTls?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    tlsEnableHostnameVerification?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    tlsCertRefreshCheckDurationSec?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    tlsEnabledWithKeyStore?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsProvider?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsKeyStoreType?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsKeyStore?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsKeyStorePassword?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsTrustStoreType?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsTrustStore?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    tlsTrustStorePassword?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerConfig
     */
    webServiceTlsProtocols?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerConfig
     */
    webServiceTlsCiphers?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    authenticationEnabled?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerConfig
     */
    authenticationProviders?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    authorizationEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    authorizationProvider?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerConfig
     */
    superUserRoles?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    saslJaasClientAllowedIds?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    saslJaasServerSectionName?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    saslJaasServerRoleTokenSignerSecretPath?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    kinitCommand?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WorkerConfig
     */
    properties?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    initializedDlogMetadata?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    brokerClientTrustCertsFilePath?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionRuntimeFactoryClassName?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkerConfig
     */
    functionRuntimeFactoryConfigs?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    secretsProviderConfiguratorClassName?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WorkerConfig
     */
    secretsProviderConfiguratorConfig?: { [key: string]: string; };
    /**
     * 
     * @type {Resources}
     * @memberof WorkerConfig
     */
    functionInstanceMinResources?: Resources;
    /**
     * 
     * @type {Resources}
     * @memberof WorkerConfig
     */
    functionInstanceMaxResources?: Resources;
    /**
     * 
     * @type {Resources}
     * @memberof WorkerConfig
     */
    functionInstanceResourceGranularities?: Resources;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    functionInstanceResourceChangeInLockStep?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionAuthProviderClassName?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    runtimeCustomizerClassName?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkerConfig
     */
    runtimeCustomizerConfig?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof WorkerConfig
     */
    maxPendingAsyncRequests?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    forwardSourceMessageProperty?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerConfig
     */
    additionalJavaRuntimeArguments?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionsWorkerServiceNarPackage?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof WorkerConfig
     */
    functionsWorkerServiceCustomConfigs?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof WorkerConfig
     */
    exposeAdminClientEnabled?: boolean;
    /**
     * 
     * @type {ThreadContainerFactory}
     * @memberof WorkerConfig
     */
    threadContainerFactory?: ThreadContainerFactory;
    /**
     * 
     * @type {ProcessContainerFactory}
     * @memberof WorkerConfig
     */
    processContainerFactory?: ProcessContainerFactory;
    /**
     * 
     * @type {KubernetesContainerFactory}
     * @memberof WorkerConfig
     */
    kubernetesContainerFactory?: KubernetesContainerFactory;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    clientAuthenticationParameters?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    clientAuthenticationPlugin?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionMetadataTopic?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    clusterCoordinationTopic?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    functionAssignmentTopic?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkerConfig
     */
    tlsTrustChainBytes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    workerWebAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerConfig
     */
    workerWebAddressTls?: string;
}

/**
 * 
 * @export
 * @interface WorkerFunctionInstanceStats
 */
export interface WorkerFunctionInstanceStats {
    /**
     * 
     * @type {string}
     * @memberof WorkerFunctionInstanceStats
     */
    name?: string;
    /**
     * 
     * @type {FunctionInstanceStatsData}
     * @memberof WorkerFunctionInstanceStats
     */
    metrics?: FunctionInstanceStatsData;
}

/**
 * 
 * @export
 * @interface WorkerInfo
 */
export interface WorkerInfo {
    /**
     * 
     * @type {string}
     * @memberof WorkerInfo
     */
    workerId?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerInfo
     */
    workerHostname?: string;
    /**
     * 
     * @type {number}
     * @memberof WorkerInfo
     */
    port?: number;
}

/**
 * 
 * @export
 * @interface WorkerService
 */
export interface WorkerService {
    /**
     * 
     * @type {SourcesWorkerService}
     * @memberof WorkerService
     */
    sources?: SourcesWorkerService;
    /**
     * 
     * @type {boolean}
     * @memberof WorkerService
     */
    initialized?: boolean;
    /**
     * 
     * @type {WorkerConfig}
     * @memberof WorkerService
     */
    workerConfig?: WorkerConfig;
    /**
     * 
     * @type {FunctionsV2WorkerService}
     * @memberof WorkerService
     */
    functionsV2?: FunctionsV2WorkerService;
    /**
     * 
     * @type {WorkersWorkerService}
     * @memberof WorkerService
     */
    workers?: WorkersWorkerService;
    /**
     * 
     * @type {FunctionsWorkerService}
     * @memberof WorkerService
     */
    functions?: FunctionsWorkerService;
    /**
     * 
     * @type {SinksWorkerService}
     * @memberof WorkerService
     */
    sinks?: SinksWorkerService;
}

/**
 * 
 * @export
 * @interface Workers
 */
export interface Workers {
}

/**
 * 
 * @export
 * @interface WorkersWorkerService
 */
export interface WorkersWorkerService {
}


/**
 * BookiesApi - fetch parameter creator
 * @export
 */
export const BookiesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removed the rack placement information for a specific bookie in the cluster
         * @param {string} bookie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookieRackInfo(bookie: string, options: any = {}): FetchArgs {
            // verify required parameter 'bookie' is not null or undefined
            if (bookie === null || bookie === undefined) {
                throw new RequiredError('bookie','Required parameter bookie was null or undefined when calling deleteBookieRackInfo.');
            }
            const localVarPath = `/bookies/racks-info/{bookie}`
                .replace(`{${"bookie"}}`, encodeURIComponent(String(bookie)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets raw information for all the bookies in the cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBookies(options: any = {}): FetchArgs {
            const localVarPath = `/bookies/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the rack placement information for a specific bookie in the cluster
         * @param {string} bookie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookieRackInfo(bookie: string, options: any = {}): FetchArgs {
            // verify required parameter 'bookie' is not null or undefined
            if (bookie === null || bookie === undefined) {
                throw new RequiredError('bookie','Required parameter bookie was null or undefined when calling getBookieRackInfo.');
            }
            const localVarPath = `/bookies/racks-info/{bookie}`
                .replace(`{${"bookie"}}`, encodeURIComponent(String(bookie)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the rack placement information for all the bookies in the cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookiesRackInfo(options: any = {}): FetchArgs {
            const localVarPath = `/bookies/racks-info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
         * @param {string} bookie 
         * @param {string} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookieRackInfo(bookie: string, group?: string, options: any = {}): FetchArgs {
            // verify required parameter 'bookie' is not null or undefined
            if (bookie === null || bookie === undefined) {
                throw new RequiredError('bookie','Required parameter bookie was null or undefined when calling updateBookieRackInfo.');
            }
            const localVarPath = `/bookies/racks-info/{bookie}`
                .replace(`{${"bookie"}}`, encodeURIComponent(String(bookie)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookiesApi - functional programming interface
 * @export
 */
export const BookiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Removed the rack placement information for a specific bookie in the cluster
         * @param {string} bookie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookieRackInfo(bookie: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BookiesApiFetchParamCreator(configuration).deleteBookieRackInfo(bookie, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets raw information for all the bookies in the cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBookies(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BookiesClusterInfo> {
            const localVarFetchArgs = BookiesApiFetchParamCreator(configuration).getAllBookies(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the rack placement information for a specific bookie in the cluster
         * @param {string} bookie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookieRackInfo(bookie: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BookieInfo> {
            const localVarFetchArgs = BookiesApiFetchParamCreator(configuration).getBookieRackInfo(bookie, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the rack placement information for all the bookies in the cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookiesRackInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: { [key: string]: BookieInfo; }; }> {
            const localVarFetchArgs = BookiesApiFetchParamCreator(configuration).getBookiesRackInfo(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
         * @param {string} bookie 
         * @param {string} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookieRackInfo(bookie: string, group?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BookiesApiFetchParamCreator(configuration).updateBookieRackInfo(bookie, group, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BookiesApi - factory interface
 * @export
 */
export const BookiesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Removed the rack placement information for a specific bookie in the cluster
         * @param {string} bookie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookieRackInfo(bookie: string, options?: any) {
            return BookiesApiFp(configuration).deleteBookieRackInfo(bookie, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets raw information for all the bookies in the cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBookies(options?: any) {
            return BookiesApiFp(configuration).getAllBookies(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the rack placement information for a specific bookie in the cluster
         * @param {string} bookie 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookieRackInfo(bookie: string, options?: any) {
            return BookiesApiFp(configuration).getBookieRackInfo(bookie, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the rack placement information for all the bookies in the cluster
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookiesRackInfo(options?: any) {
            return BookiesApiFp(configuration).getBookiesRackInfo(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
         * @param {string} bookie 
         * @param {string} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookieRackInfo(bookie: string, group?: string, options?: any) {
            return BookiesApiFp(configuration).updateBookieRackInfo(bookie, group, options)(fetch, basePath);
        },
    };
};

/**
 * BookiesApi - object-oriented interface
 * @export
 * @class BookiesApi
 * @extends {BaseAPI}
 */
export class BookiesApi extends BaseAPI {
    /**
     * 
     * @summary Removed the rack placement information for a specific bookie in the cluster
     * @param {string} bookie 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookiesApi
     */
    public deleteBookieRackInfo(bookie: string, options?: any) {
        return BookiesApiFp(this.configuration).deleteBookieRackInfo(bookie, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets raw information for all the bookies in the cluster
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookiesApi
     */
    public getAllBookies(options?: any) {
        return BookiesApiFp(this.configuration).getAllBookies(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the rack placement information for a specific bookie in the cluster
     * @param {string} bookie 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookiesApi
     */
    public getBookieRackInfo(bookie: string, options?: any) {
        return BookiesApiFp(this.configuration).getBookieRackInfo(bookie, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the rack placement information for all the bookies in the cluster
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookiesApi
     */
    public getBookiesRackInfo(options?: any) {
        return BookiesApiFp(this.configuration).getBookiesRackInfo(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
     * @param {string} bookie 
     * @param {string} [group] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookiesApi
     */
    public updateBookieRackInfo(bookie: string, group?: string, options?: any) {
        return BookiesApiFp(this.configuration).updateBookieRackInfo(bookie, group, options)(this.fetch, this.basePath);
    }

}

/**
 * BrokerStatsApi - fetch parameter creator
 * @export
 */
export const BrokerStatsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
         * @param {string} allocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocatorStats(allocator: string, options: any = {}): FetchArgs {
            // verify required parameter 'allocator' is not null or undefined
            if (allocator === null || allocator === undefined) {
                throw new RequiredError('allocator','Required parameter allocator was null or undefined when calling getAllocatorStats.');
            }
            const localVarPath = `/broker-stats/allocator-stats/{allocator}`
                .replace(`{${"allocator"}}`, encodeURIComponent(String(allocator)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This API gives the current broker availability in percent, each resource percentage usage is calculated and thensum of all of the resource usage percent is called broker-resource-availability<br/><br/>THIS API IS ONLY FOR USE BY TESTING FOR CONFIRMING NAMESPACE ALLOCATION ALGORITHM
         * @summary Broker availability report
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokerResourceAvailability(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBrokerResourceAvailability.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBrokerResourceAvailability.');
            }
            const localVarPath = `/broker-stats/broker-resource-availability/{tenant}/{namespace}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * consists of topics stats & systemResourceUsage
         * @summary Get Load for this broker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoadReport(options: any = {}): FetchArgs {
            const localVarPath = `/broker-stats/load-report`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the mbean details of this broker JVM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMBeans(options: any = {}): FetchArgs {
            const localVarPath = `/broker-stats/mbeans`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requested should be executed by Monitoring agent on each broker to fetch the metrics
         * @summary Gets the metrics for Monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options: any = {}): FetchArgs {
            const localVarPath = `/broker-stats/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pending bookie client op stats by namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingBookieOpsStats(options: any = {}): FetchArgs {
            const localVarPath = `/broker-stats/bookieops`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the topic stats by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics2(options: any = {}): FetchArgs {
            const localVarPath = `/broker-stats/topics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrokerStatsApi - functional programming interface
 * @export
 */
export const BrokerStatsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
         * @param {string} allocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocatorStats(allocator: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AllocatorStats> {
            const localVarFetchArgs = BrokerStatsApiFetchParamCreator(configuration).getAllocatorStats(allocator, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This API gives the current broker availability in percent, each resource percentage usage is calculated and thensum of all of the resource usage percent is called broker-resource-availability<br/><br/>THIS API IS ONLY FOR USE BY TESTING FOR CONFIRMING NAMESPACE ALLOCATION ALGORITHM
         * @summary Broker availability report
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokerResourceAvailability(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: ResourceUnit; }> {
            const localVarFetchArgs = BrokerStatsApiFetchParamCreator(configuration).getBrokerResourceAvailability(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * consists of topics stats & systemResourceUsage
         * @summary Get Load for this broker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoadReport(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LoadReport> {
            const localVarFetchArgs = BrokerStatsApiFetchParamCreator(configuration).getLoadReport(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all the mbean details of this broker JVM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMBeans(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Metrics>> {
            const localVarFetchArgs = BrokerStatsApiFetchParamCreator(configuration).getMBeans(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Requested should be executed by Monitoring agent on each broker to fetch the metrics
         * @summary Gets the metrics for Monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Metrics>> {
            const localVarFetchArgs = BrokerStatsApiFetchParamCreator(configuration).getMetrics(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get pending bookie client op stats by namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingBookieOpsStats(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: PendingBookieOpsStats; }> {
            const localVarFetchArgs = BrokerStatsApiFetchParamCreator(configuration).getPendingBookieOpsStats(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all the topic stats by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OutputStream> {
            const localVarFetchArgs = BrokerStatsApiFetchParamCreator(configuration).getTopics2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BrokerStatsApi - factory interface
 * @export
 */
export const BrokerStatsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
         * @param {string} allocator 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllocatorStats(allocator: string, options?: any) {
            return BrokerStatsApiFp(configuration).getAllocatorStats(allocator, options)(fetch, basePath);
        },
        /**
         * This API gives the current broker availability in percent, each resource percentage usage is calculated and thensum of all of the resource usage percent is called broker-resource-availability<br/><br/>THIS API IS ONLY FOR USE BY TESTING FOR CONFIRMING NAMESPACE ALLOCATION ALGORITHM
         * @summary Broker availability report
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokerResourceAvailability(tenant: string, namespace: string, options?: any) {
            return BrokerStatsApiFp(configuration).getBrokerResourceAvailability(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * consists of topics stats & systemResourceUsage
         * @summary Get Load for this broker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoadReport(options?: any) {
            return BrokerStatsApiFp(configuration).getLoadReport(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all the mbean details of this broker JVM
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMBeans(options?: any) {
            return BrokerStatsApiFp(configuration).getMBeans(options)(fetch, basePath);
        },
        /**
         * Requested should be executed by Monitoring agent on each broker to fetch the metrics
         * @summary Gets the metrics for Monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any) {
            return BrokerStatsApiFp(configuration).getMetrics(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get pending bookie client op stats by namesapce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingBookieOpsStats(options?: any) {
            return BrokerStatsApiFp(configuration).getPendingBookieOpsStats(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all the topic stats by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics2(options?: any) {
            return BrokerStatsApiFp(configuration).getTopics2(options)(fetch, basePath);
        },
    };
};

/**
 * BrokerStatsApi - object-oriented interface
 * @export
 * @class BrokerStatsApi
 * @extends {BaseAPI}
 */
export class BrokerStatsApi extends BaseAPI {
    /**
     * 
     * @summary Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
     * @param {string} allocator 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokerStatsApi
     */
    public getAllocatorStats(allocator: string, options?: any) {
        return BrokerStatsApiFp(this.configuration).getAllocatorStats(allocator, options)(this.fetch, this.basePath);
    }

    /**
     * This API gives the current broker availability in percent, each resource percentage usage is calculated and thensum of all of the resource usage percent is called broker-resource-availability<br/><br/>THIS API IS ONLY FOR USE BY TESTING FOR CONFIRMING NAMESPACE ALLOCATION ALGORITHM
     * @summary Broker availability report
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokerStatsApi
     */
    public getBrokerResourceAvailability(tenant: string, namespace: string, options?: any) {
        return BrokerStatsApiFp(this.configuration).getBrokerResourceAvailability(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * consists of topics stats & systemResourceUsage
     * @summary Get Load for this broker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokerStatsApi
     */
    public getLoadReport(options?: any) {
        return BrokerStatsApiFp(this.configuration).getLoadReport(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all the mbean details of this broker JVM
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokerStatsApi
     */
    public getMBeans(options?: any) {
        return BrokerStatsApiFp(this.configuration).getMBeans(options)(this.fetch, this.basePath);
    }

    /**
     * Requested should be executed by Monitoring agent on each broker to fetch the metrics
     * @summary Gets the metrics for Monitoring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokerStatsApi
     */
    public getMetrics(options?: any) {
        return BrokerStatsApiFp(this.configuration).getMetrics(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get pending bookie client op stats by namesapce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokerStatsApi
     */
    public getPendingBookieOpsStats(options?: any) {
        return BrokerStatsApiFp(this.configuration).getPendingBookieOpsStats(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all the topic stats by namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokerStatsApi
     */
    public getTopics2(options?: any) {
        return BrokerStatsApiFp(this.configuration).getTopics2(options)(this.fetch, this.basePath);
    }

}

/**
 * BrokersApi - fetch parameter creator
 * @export
 */
export const BrokersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary An REST endpoint to trigger backlogQuotaCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backlogQuotaCheck(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/backlog-quota-check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
         * @param {string} configName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDynamicConfiguration(configName: string, options: any = {}): FetchArgs {
            // verify required parameter 'configName' is not null or undefined
            if (configName === null || configName === undefined) {
                throw new RequiredError('configName','Required parameter configName was null or undefined when calling deleteDynamicConfiguration.');
            }
            const localVarPath = `/brokers/configuration/{configName}`
                .replace(`{${"configName"}}`, encodeURIComponent(String(configName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBrokers(cluster: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getActiveBrokers.');
            }
            const localVarPath = `/brokers/{cluster}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get value of all dynamic configurations' value overridden on local config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDynamicConfigurations(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/configuration/values`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all updatable dynamic configurations's name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDynamicConfigurationName(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the internal configuration data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalConfigurationData(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/internal-configuration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the information of the leader broker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderBroker(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/leaderBroker`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of namespaces served by the specific broker
         * @param {string} clusterName 
         * @param {string} brokerWebserviceurl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnedNamespaces(clusterName: string, brokerWebserviceurl: string, options: any = {}): FetchArgs {
            // verify required parameter 'clusterName' is not null or undefined
            if (clusterName === null || clusterName === undefined) {
                throw new RequiredError('clusterName','Required parameter clusterName was null or undefined when calling getOwnedNamespaces.');
            }
            // verify required parameter 'brokerWebserviceurl' is not null or undefined
            if (brokerWebserviceurl === null || brokerWebserviceurl === undefined) {
                throw new RequiredError('brokerWebserviceurl','Required parameter brokerWebserviceurl was null or undefined when calling getOwnedNamespaces.');
            }
            const localVarPath = `/brokers/{clusterName}/{broker-webserviceurl}/ownedNamespaces`
                .replace(`{${"clusterName"}}`, encodeURIComponent(String(clusterName)))
                .replace(`{${"broker-webserviceurl"}}`, encodeURIComponent(String(brokerWebserviceurl)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all runtime configurations. This operation requires Pulsar super-user privileges.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntimeConfiguration(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/configuration/runtime`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run a healthCheck against the broker
         * @param {'V1' | 'V2'} [topicVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(topicVersion?: 'V1' | 'V2', options: any = {}): FetchArgs {
            const localVarPath = `/brokers/health`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topicVersion !== undefined) {
                localVarQueryParameter['topicVersion'] = topicVersion;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if the broker is fully initialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/ready`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Shutdown broker gracefully.
         * @param {number} [maxConcurrentUnloadPerSec] if the value absent(value&#x3D;0) means no concurrent limitation.
         * @param {boolean} [forcedTerminateTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutDownBrokerGracefully(maxConcurrentUnloadPerSec?: number, forcedTerminateTopic?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/brokers/shutdown`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxConcurrentUnloadPerSec !== undefined) {
                localVarQueryParameter['maxConcurrentUnloadPerSec'] = maxConcurrentUnloadPerSec;
            }

            if (forcedTerminateTopic !== undefined) {
                localVarQueryParameter['forcedTerminateTopic'] = forcedTerminateTopic;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
         * @param {string} configName 
         * @param {string} configValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDynamicConfiguration(configName: string, configValue: string, options: any = {}): FetchArgs {
            // verify required parameter 'configName' is not null or undefined
            if (configName === null || configName === undefined) {
                throw new RequiredError('configName','Required parameter configName was null or undefined when calling updateDynamicConfiguration.');
            }
            // verify required parameter 'configValue' is not null or undefined
            if (configValue === null || configValue === undefined) {
                throw new RequiredError('configValue','Required parameter configValue was null or undefined when calling updateDynamicConfiguration.');
            }
            const localVarPath = `/brokers/configuration/{configName}/{configValue}`
                .replace(`{${"configName"}}`, encodeURIComponent(String(configName)))
                .replace(`{${"configValue"}}`, encodeURIComponent(String(configValue)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get version of current broker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options: any = {}): FetchArgs {
            const localVarPath = `/brokers/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrokersApi - functional programming interface
 * @export
 */
export const BrokersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary An REST endpoint to trigger backlogQuotaCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backlogQuotaCheck(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).backlogQuotaCheck(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
         * @param {string} configName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDynamicConfiguration(configName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).deleteDynamicConfiguration(configName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBrokers(cluster: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).getActiveBrokers(cluster, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get value of all dynamic configurations' value overridden on local config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDynamicConfigurations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).getAllDynamicConfigurations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all updatable dynamic configurations's name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDynamicConfigurationName(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).getDynamicConfigurationName(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the internal configuration data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalConfigurationData(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InternalConfigurationData> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).getInternalConfigurationData(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the information of the leader broker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderBroker(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BrokerInfo> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).getLeaderBroker(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of namespaces served by the specific broker
         * @param {string} clusterName 
         * @param {string} brokerWebserviceurl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnedNamespaces(clusterName: string, brokerWebserviceurl: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: NamespaceOwnershipStatus; }> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).getOwnedNamespaces(clusterName, brokerWebserviceurl, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all runtime configurations. This operation requires Pulsar super-user privileges.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntimeConfiguration(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).getRuntimeConfiguration(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Run a healthCheck against the broker
         * @param {'V1' | 'V2'} [topicVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(topicVersion?: 'V1' | 'V2', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).healthCheck(topicVersion, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check if the broker is fully initialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).isReady(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Shutdown broker gracefully.
         * @param {number} [maxConcurrentUnloadPerSec] if the value absent(value&#x3D;0) means no concurrent limitation.
         * @param {boolean} [forcedTerminateTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutDownBrokerGracefully(maxConcurrentUnloadPerSec?: number, forcedTerminateTopic?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).shutDownBrokerGracefully(maxConcurrentUnloadPerSec, forcedTerminateTopic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
         * @param {string} configName 
         * @param {string} configValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDynamicConfiguration(configName: string, configValue: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).updateDynamicConfiguration(configName, configValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get version of current broker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BrokersApiFetchParamCreator(configuration).version(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BrokersApi - factory interface
 * @export
 */
export const BrokersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary An REST endpoint to trigger backlogQuotaCheck
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backlogQuotaCheck(options?: any) {
            return BrokersApiFp(configuration).backlogQuotaCheck(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
         * @param {string} configName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDynamicConfiguration(configName: string, options?: any) {
            return BrokersApiFp(configuration).deleteDynamicConfiguration(configName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
         * @param {string} cluster 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBrokers(cluster: string, options?: any) {
            return BrokersApiFp(configuration).getActiveBrokers(cluster, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get value of all dynamic configurations' value overridden on local config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDynamicConfigurations(options?: any) {
            return BrokersApiFp(configuration).getAllDynamicConfigurations(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all updatable dynamic configurations's name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDynamicConfigurationName(options?: any) {
            return BrokersApiFp(configuration).getDynamicConfigurationName(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the internal configuration data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalConfigurationData(options?: any) {
            return BrokersApiFp(configuration).getInternalConfigurationData(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the information of the leader broker.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeaderBroker(options?: any) {
            return BrokersApiFp(configuration).getLeaderBroker(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of namespaces served by the specific broker
         * @param {string} clusterName 
         * @param {string} brokerWebserviceurl 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOwnedNamespaces(clusterName: string, brokerWebserviceurl: string, options?: any) {
            return BrokersApiFp(configuration).getOwnedNamespaces(clusterName, brokerWebserviceurl, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all runtime configurations. This operation requires Pulsar super-user privileges.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRuntimeConfiguration(options?: any) {
            return BrokersApiFp(configuration).getRuntimeConfiguration(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Run a healthCheck against the broker
         * @param {'V1' | 'V2'} [topicVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(topicVersion?: 'V1' | 'V2', options?: any) {
            return BrokersApiFp(configuration).healthCheck(topicVersion, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check if the broker is fully initialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady(options?: any) {
            return BrokersApiFp(configuration).isReady(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Shutdown broker gracefully.
         * @param {number} [maxConcurrentUnloadPerSec] if the value absent(value&#x3D;0) means no concurrent limitation.
         * @param {boolean} [forcedTerminateTopic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutDownBrokerGracefully(maxConcurrentUnloadPerSec?: number, forcedTerminateTopic?: boolean, options?: any) {
            return BrokersApiFp(configuration).shutDownBrokerGracefully(maxConcurrentUnloadPerSec, forcedTerminateTopic, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
         * @param {string} configName 
         * @param {string} configValue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDynamicConfiguration(configName: string, configValue: string, options?: any) {
            return BrokersApiFp(configuration).updateDynamicConfiguration(configName, configValue, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get version of current broker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options?: any) {
            return BrokersApiFp(configuration).version(options)(fetch, basePath);
        },
    };
};

/**
 * BrokersApi - object-oriented interface
 * @export
 * @class BrokersApi
 * @extends {BaseAPI}
 */
export class BrokersApi extends BaseAPI {
    /**
     * 
     * @summary An REST endpoint to trigger backlogQuotaCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public backlogQuotaCheck(options?: any) {
        return BrokersApiFp(this.configuration).backlogQuotaCheck(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
     * @param {string} configName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public deleteDynamicConfiguration(configName: string, options?: any) {
        return BrokersApiFp(this.configuration).deleteDynamicConfiguration(configName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
     * @param {string} cluster 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public getActiveBrokers(cluster: string, options?: any) {
        return BrokersApiFp(this.configuration).getActiveBrokers(cluster, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get value of all dynamic configurations' value overridden on local config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public getAllDynamicConfigurations(options?: any) {
        return BrokersApiFp(this.configuration).getAllDynamicConfigurations(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all updatable dynamic configurations's name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public getDynamicConfigurationName(options?: any) {
        return BrokersApiFp(this.configuration).getDynamicConfigurationName(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the internal configuration data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public getInternalConfigurationData(options?: any) {
        return BrokersApiFp(this.configuration).getInternalConfigurationData(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the information of the leader broker.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public getLeaderBroker(options?: any) {
        return BrokersApiFp(this.configuration).getLeaderBroker(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of namespaces served by the specific broker
     * @param {string} clusterName 
     * @param {string} brokerWebserviceurl 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public getOwnedNamespaces(clusterName: string, brokerWebserviceurl: string, options?: any) {
        return BrokersApiFp(this.configuration).getOwnedNamespaces(clusterName, brokerWebserviceurl, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all runtime configurations. This operation requires Pulsar super-user privileges.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public getRuntimeConfiguration(options?: any) {
        return BrokersApiFp(this.configuration).getRuntimeConfiguration(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Run a healthCheck against the broker
     * @param {'V1' | 'V2'} [topicVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public healthCheck(topicVersion?: 'V1' | 'V2', options?: any) {
        return BrokersApiFp(this.configuration).healthCheck(topicVersion, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check if the broker is fully initialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public isReady(options?: any) {
        return BrokersApiFp(this.configuration).isReady(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Shutdown broker gracefully.
     * @param {number} [maxConcurrentUnloadPerSec] if the value absent(value&#x3D;0) means no concurrent limitation.
     * @param {boolean} [forcedTerminateTopic] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public shutDownBrokerGracefully(maxConcurrentUnloadPerSec?: number, forcedTerminateTopic?: boolean, options?: any) {
        return BrokersApiFp(this.configuration).shutDownBrokerGracefully(maxConcurrentUnloadPerSec, forcedTerminateTopic, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
     * @param {string} configName 
     * @param {string} configValue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public updateDynamicConfiguration(configName: string, configValue: string, options?: any) {
        return BrokersApiFp(this.configuration).updateDynamicConfiguration(configName, configValue, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get version of current broker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokersApi
     */
    public version(options?: any) {
        return BrokersApiFp(this.configuration).version(options)(this.fetch, this.basePath);
    }

}

/**
 * ClustersApi - fetch parameter creator
 * @export
 */
export const ClustersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation requires Pulsar superuser privileges, and the name cannot contain the '/' characters.
         * @summary Create a new cluster.
         * @param {string} cluster The cluster name
         * @param {ClusterData} body The cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(cluster: string, body: ClusterData, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling createCluster.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCluster.');
            }
            const localVarPath = `/clusters/{cluster}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClusterData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete an existing cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(cluster: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling deleteCluster.');
            }
            const localVarPath = `/clusters/{cluster}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete the failure domain of the cluster
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFailureDomain(cluster: string, domainName: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling deleteFailureDomain.');
            }
            // verify required parameter 'domainName' is not null or undefined
            if (domainName === null || domainName === undefined) {
                throw new RequiredError('domainName','Required parameter domainName was null or undefined when calling deleteFailureDomain.');
            }
            const localVarPath = `/clusters/{cluster}/failureDomains/{domainName}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"domainName"}}`, encodeURIComponent(String(domainName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete namespace isolation policy.
         * @param {string} cluster The cluster name
         * @param {string} policyName The namespace isolation policy name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceIsolationPolicy(cluster: string, policyName: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling deleteNamespaceIsolationPolicy.');
            }
            // verify required parameter 'policyName' is not null or undefined
            if (policyName === null || policyName === undefined) {
                throw new RequiredError('policyName','Required parameter policyName was null or undefined when calling deleteNamespaceIsolationPolicy.');
            }
            const localVarPath = `/clusters/{cluster}/namespaceIsolationPolicies/{policyName}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"policyName"}}`, encodeURIComponent(String(policyName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get a broker with namespace-isolation policies attached to it.
         * @param {string} cluster The cluster name
         * @param {string} broker The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokerWithNamespaceIsolationPolicy(cluster: string, broker: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getBrokerWithNamespaceIsolationPolicy.');
            }
            // verify required parameter 'broker' is not null or undefined
            if (broker === null || broker === undefined) {
                throw new RequiredError('broker','Required parameter broker was null or undefined when calling getBrokerWithNamespaceIsolationPolicy.');
            }
            const localVarPath = `/clusters/{cluster}/namespaceIsolationPolicies/brokers/{broker}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"broker"}}`, encodeURIComponent(String(broker)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get list of brokers with namespace-isolation policies attached to them.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokersWithNamespaceIsolationPolicy(cluster: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getBrokersWithNamespaceIsolationPolicy.');
            }
            const localVarPath = `/clusters/{cluster}/namespaceIsolationPolicies/brokers`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the configuration for the specified cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(cluster: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getCluster.');
            }
            const localVarPath = `/clusters/{cluster}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all the Pulsar clusters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusters(options: any = {}): FetchArgs {
            const localVarPath = `/clusters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get a domain in a cluster
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(cluster: string, domainName: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getDomain.');
            }
            // verify required parameter 'domainName' is not null or undefined
            if (domainName === null || domainName === undefined) {
                throw new RequiredError('domainName','Required parameter domainName was null or undefined when calling getDomain.');
            }
            const localVarPath = `/clusters/{cluster}/failureDomains/{domainName}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"domainName"}}`, encodeURIComponent(String(domainName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the cluster failure domains.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailureDomains(cluster: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getFailureDomains.');
            }
            const localVarPath = `/clusters/{cluster}/failureDomains`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the namespace isolation policies assigned to the cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceIsolationPolicies(cluster: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getNamespaceIsolationPolicies.');
            }
            const localVarPath = `/clusters/{cluster}/namespaceIsolationPolicies`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the single namespace isolation policy assigned to the cluster.
         * @param {string} cluster The cluster name
         * @param {string} policyName The name of the namespace isolation policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceIsolationPolicy(cluster: string, policyName: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getNamespaceIsolationPolicy.');
            }
            // verify required parameter 'policyName' is not null or undefined
            if (policyName === null || policyName === undefined) {
                throw new RequiredError('policyName','Required parameter policyName was null or undefined when calling getNamespaceIsolationPolicy.');
            }
            const localVarPath = `/clusters/{cluster}/namespaceIsolationPolicies/{policyName}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"policyName"}}`, encodeURIComponent(String(policyName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the peer-cluster data for the specified cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeerCluster(cluster: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getPeerCluster.');
            }
            const localVarPath = `/clusters/{cluster}/peers`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Set the failure domain of the cluster.
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {FailureDomain} body The configuration data of a failure domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFailureDomain(cluster: string, domainName: string, body: FailureDomain, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling setFailureDomain.');
            }
            // verify required parameter 'domainName' is not null or undefined
            if (domainName === null || domainName === undefined) {
                throw new RequiredError('domainName','Required parameter domainName was null or undefined when calling setFailureDomain.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setFailureDomain.');
            }
            const localVarPath = `/clusters/{cluster}/failureDomains/{domainName}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"domainName"}}`, encodeURIComponent(String(domainName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FailureDomain" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Set namespace isolation policy.
         * @param {string} cluster The cluster name
         * @param {string} policyName The namespace isolation policy name
         * @param {NamespaceIsolationData} body The namespace isolation policy data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceIsolationPolicy(cluster: string, policyName: string, body: NamespaceIsolationData, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling setNamespaceIsolationPolicy.');
            }
            // verify required parameter 'policyName' is not null or undefined
            if (policyName === null || policyName === undefined) {
                throw new RequiredError('policyName','Required parameter policyName was null or undefined when calling setNamespaceIsolationPolicy.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setNamespaceIsolationPolicy.');
            }
            const localVarPath = `/clusters/{cluster}/namespaceIsolationPolicies/{policyName}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"policyName"}}`, encodeURIComponent(String(policyName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NamespaceIsolationData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Update peer-cluster-list for a cluster.
         * @param {string} cluster The cluster name
         * @param {Array<string>} body The list of peer cluster names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPeerClusterNames(cluster: string, body: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling setPeerClusterNames.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setPeerClusterNames.');
            }
            const localVarPath = `/clusters/{cluster}/peers`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Update the configuration for a cluster.
         * @param {string} cluster The cluster name
         * @param {ClusterData} body The cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster(cluster: string, body: ClusterData, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling updateCluster.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateCluster.');
            }
            const localVarPath = `/clusters/{cluster}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClusterData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This operation requires Pulsar superuser privileges, and the name cannot contain the '/' characters.
         * @summary Create a new cluster.
         * @param {string} cluster The cluster name
         * @param {ClusterData} body The cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(cluster: string, body: ClusterData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).createCluster(cluster, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete an existing cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(cluster: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).deleteCluster(cluster, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete the failure domain of the cluster
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFailureDomain(cluster: string, domainName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).deleteFailureDomain(cluster, domainName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete namespace isolation policy.
         * @param {string} cluster The cluster name
         * @param {string} policyName The namespace isolation policy name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceIsolationPolicy(cluster: string, policyName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).deleteNamespaceIsolationPolicy(cluster, policyName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get a broker with namespace-isolation policies attached to it.
         * @param {string} cluster The cluster name
         * @param {string} broker The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokerWithNamespaceIsolationPolicy(cluster: string, broker: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BrokerNamespaceIsolationData> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getBrokerWithNamespaceIsolationPolicy(cluster, broker, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get list of brokers with namespace-isolation policies attached to them.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokersWithNamespaceIsolationPolicy(cluster: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BrokerNamespaceIsolationData>> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getBrokersWithNamespaceIsolationPolicy(cluster, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the configuration for the specified cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(cluster: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClusterData> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getCluster(cluster, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of all the Pulsar clusters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusters(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getClusters(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get a domain in a cluster
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(cluster: string, domainName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FailureDomain> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getDomain(cluster, domainName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the cluster failure domains.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailureDomains(cluster: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: FailureDomain; }> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getFailureDomains(cluster, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the namespace isolation policies assigned to the cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceIsolationPolicies(cluster: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: NamespaceIsolationData; }> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getNamespaceIsolationPolicies(cluster, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the single namespace isolation policy assigned to the cluster.
         * @param {string} cluster The cluster name
         * @param {string} policyName The name of the namespace isolation policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceIsolationPolicy(cluster: string, policyName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NamespaceIsolationData> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getNamespaceIsolationPolicy(cluster, policyName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the peer-cluster data for the specified cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeerCluster(cluster: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getPeerCluster(cluster, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Set the failure domain of the cluster.
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {FailureDomain} body The configuration data of a failure domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFailureDomain(cluster: string, domainName: string, body: FailureDomain, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).setFailureDomain(cluster, domainName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Set namespace isolation policy.
         * @param {string} cluster The cluster name
         * @param {string} policyName The namespace isolation policy name
         * @param {NamespaceIsolationData} body The namespace isolation policy data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceIsolationPolicy(cluster: string, policyName: string, body: NamespaceIsolationData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).setNamespaceIsolationPolicy(cluster, policyName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Update peer-cluster-list for a cluster.
         * @param {string} cluster The cluster name
         * @param {Array<string>} body The list of peer cluster names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPeerClusterNames(cluster: string, body: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).setPeerClusterNames(cluster, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Update the configuration for a cluster.
         * @param {string} cluster The cluster name
         * @param {ClusterData} body The cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster(cluster: string, body: ClusterData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).updateCluster(cluster, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This operation requires Pulsar superuser privileges, and the name cannot contain the '/' characters.
         * @summary Create a new cluster.
         * @param {string} cluster The cluster name
         * @param {ClusterData} body The cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(cluster: string, body: ClusterData, options?: any) {
            return ClustersApiFp(configuration).createCluster(cluster, body, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete an existing cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(cluster: string, options?: any) {
            return ClustersApiFp(configuration).deleteCluster(cluster, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete the failure domain of the cluster
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFailureDomain(cluster: string, domainName: string, options?: any) {
            return ClustersApiFp(configuration).deleteFailureDomain(cluster, domainName, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Delete namespace isolation policy.
         * @param {string} cluster The cluster name
         * @param {string} policyName The namespace isolation policy name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceIsolationPolicy(cluster: string, policyName: string, options?: any) {
            return ClustersApiFp(configuration).deleteNamespaceIsolationPolicy(cluster, policyName, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get a broker with namespace-isolation policies attached to it.
         * @param {string} cluster The cluster name
         * @param {string} broker The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokerWithNamespaceIsolationPolicy(cluster: string, broker: string, options?: any) {
            return ClustersApiFp(configuration).getBrokerWithNamespaceIsolationPolicy(cluster, broker, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get list of brokers with namespace-isolation policies attached to them.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrokersWithNamespaceIsolationPolicy(cluster: string, options?: any) {
            return ClustersApiFp(configuration).getBrokersWithNamespaceIsolationPolicy(cluster, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the configuration for the specified cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(cluster: string, options?: any) {
            return ClustersApiFp(configuration).getCluster(cluster, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of all the Pulsar clusters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusters(options?: any) {
            return ClustersApiFp(configuration).getClusters(options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get a domain in a cluster
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(cluster: string, domainName: string, options?: any) {
            return ClustersApiFp(configuration).getDomain(cluster, domainName, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the cluster failure domains.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailureDomains(cluster: string, options?: any) {
            return ClustersApiFp(configuration).getFailureDomains(cluster, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the namespace isolation policies assigned to the cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceIsolationPolicies(cluster: string, options?: any) {
            return ClustersApiFp(configuration).getNamespaceIsolationPolicies(cluster, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the single namespace isolation policy assigned to the cluster.
         * @param {string} cluster The cluster name
         * @param {string} policyName The name of the namespace isolation policy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceIsolationPolicy(cluster: string, policyName: string, options?: any) {
            return ClustersApiFp(configuration).getNamespaceIsolationPolicy(cluster, policyName, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Get the peer-cluster data for the specified cluster.
         * @param {string} cluster The cluster name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeerCluster(cluster: string, options?: any) {
            return ClustersApiFp(configuration).getPeerCluster(cluster, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Set the failure domain of the cluster.
         * @param {string} cluster The cluster name
         * @param {string} domainName The failure domain name
         * @param {FailureDomain} body The configuration data of a failure domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setFailureDomain(cluster: string, domainName: string, body: FailureDomain, options?: any) {
            return ClustersApiFp(configuration).setFailureDomain(cluster, domainName, body, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Set namespace isolation policy.
         * @param {string} cluster The cluster name
         * @param {string} policyName The namespace isolation policy name
         * @param {NamespaceIsolationData} body The namespace isolation policy data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceIsolationPolicy(cluster: string, policyName: string, body: NamespaceIsolationData, options?: any) {
            return ClustersApiFp(configuration).setNamespaceIsolationPolicy(cluster, policyName, body, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Update peer-cluster-list for a cluster.
         * @param {string} cluster The cluster name
         * @param {Array<string>} body The list of peer cluster names
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPeerClusterNames(cluster: string, body: Array<string>, options?: any) {
            return ClustersApiFp(configuration).setPeerClusterNames(cluster, body, options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar superuser privileges.
         * @summary Update the configuration for a cluster.
         * @param {string} cluster The cluster name
         * @param {ClusterData} body The cluster data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCluster(cluster: string, body: ClusterData, options?: any) {
            return ClustersApiFp(configuration).updateCluster(cluster, body, options)(fetch, basePath);
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * This operation requires Pulsar superuser privileges, and the name cannot contain the '/' characters.
     * @summary Create a new cluster.
     * @param {string} cluster The cluster name
     * @param {ClusterData} body The cluster data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createCluster(cluster: string, body: ClusterData, options?: any) {
        return ClustersApiFp(this.configuration).createCluster(cluster, body, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Delete an existing cluster.
     * @param {string} cluster The cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteCluster(cluster: string, options?: any) {
        return ClustersApiFp(this.configuration).deleteCluster(cluster, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Delete the failure domain of the cluster
     * @param {string} cluster The cluster name
     * @param {string} domainName The failure domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteFailureDomain(cluster: string, domainName: string, options?: any) {
        return ClustersApiFp(this.configuration).deleteFailureDomain(cluster, domainName, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Delete namespace isolation policy.
     * @param {string} cluster The cluster name
     * @param {string} policyName The namespace isolation policy name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteNamespaceIsolationPolicy(cluster: string, policyName: string, options?: any) {
        return ClustersApiFp(this.configuration).deleteNamespaceIsolationPolicy(cluster, policyName, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get a broker with namespace-isolation policies attached to it.
     * @param {string} cluster The cluster name
     * @param {string} broker The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getBrokerWithNamespaceIsolationPolicy(cluster: string, broker: string, options?: any) {
        return ClustersApiFp(this.configuration).getBrokerWithNamespaceIsolationPolicy(cluster, broker, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get list of brokers with namespace-isolation policies attached to them.
     * @param {string} cluster The cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getBrokersWithNamespaceIsolationPolicy(cluster: string, options?: any) {
        return ClustersApiFp(this.configuration).getBrokersWithNamespaceIsolationPolicy(cluster, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get the configuration for the specified cluster.
     * @param {string} cluster The cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getCluster(cluster: string, options?: any) {
        return ClustersApiFp(this.configuration).getCluster(cluster, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of all the Pulsar clusters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusters(options?: any) {
        return ClustersApiFp(this.configuration).getClusters(options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get a domain in a cluster
     * @param {string} cluster The cluster name
     * @param {string} domainName The failure domain name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getDomain(cluster: string, domainName: string, options?: any) {
        return ClustersApiFp(this.configuration).getDomain(cluster, domainName, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get the cluster failure domains.
     * @param {string} cluster The cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getFailureDomains(cluster: string, options?: any) {
        return ClustersApiFp(this.configuration).getFailureDomains(cluster, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get the namespace isolation policies assigned to the cluster.
     * @param {string} cluster The cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getNamespaceIsolationPolicies(cluster: string, options?: any) {
        return ClustersApiFp(this.configuration).getNamespaceIsolationPolicies(cluster, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get the single namespace isolation policy assigned to the cluster.
     * @param {string} cluster The cluster name
     * @param {string} policyName The name of the namespace isolation policy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getNamespaceIsolationPolicy(cluster: string, policyName: string, options?: any) {
        return ClustersApiFp(this.configuration).getNamespaceIsolationPolicy(cluster, policyName, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Get the peer-cluster data for the specified cluster.
     * @param {string} cluster The cluster name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getPeerCluster(cluster: string, options?: any) {
        return ClustersApiFp(this.configuration).getPeerCluster(cluster, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Set the failure domain of the cluster.
     * @param {string} cluster The cluster name
     * @param {string} domainName The failure domain name
     * @param {FailureDomain} body The configuration data of a failure domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public setFailureDomain(cluster: string, domainName: string, body: FailureDomain, options?: any) {
        return ClustersApiFp(this.configuration).setFailureDomain(cluster, domainName, body, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Set namespace isolation policy.
     * @param {string} cluster The cluster name
     * @param {string} policyName The namespace isolation policy name
     * @param {NamespaceIsolationData} body The namespace isolation policy data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public setNamespaceIsolationPolicy(cluster: string, policyName: string, body: NamespaceIsolationData, options?: any) {
        return ClustersApiFp(this.configuration).setNamespaceIsolationPolicy(cluster, policyName, body, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Update peer-cluster-list for a cluster.
     * @param {string} cluster The cluster name
     * @param {Array<string>} body The list of peer cluster names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public setPeerClusterNames(cluster: string, body: Array<string>, options?: any) {
        return ClustersApiFp(this.configuration).setPeerClusterNames(cluster, body, options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar superuser privileges.
     * @summary Update the configuration for a cluster.
     * @param {string} cluster The cluster name
     * @param {ClusterData} body The cluster data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public updateCluster(cluster: string, body: ClusterData, options?: any) {
        return ClustersApiFp(this.configuration).updateCluster(cluster, body, options)(this.fetch, this.basePath);
    }

}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Drains this worker, i.e., moves its work-assignments to other workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        drain(options: any = {}): FetchArgs {
            const localVarPath = `/worker/drain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Drains the specified worker, i.e., moves its work-assignments to other workers
         * @param {string} [workerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        drainAtLeader(workerId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/worker/leader/drain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignments(options: any = {}): FetchArgs {
            const localVarPath = `/worker/assignments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches information about the Pulsar cluster running Pulsar Functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(options: any = {}): FetchArgs {
            const localVarPath = `/worker/cluster`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterLeader(options: any = {}): FetchArgs {
            const localVarPath = `/worker/cluster/leader`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetches a list of supported Pulsar IO connectors currently running in cluster mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorsList(options: any = {}): FetchArgs {
            const localVarPath = `/worker/connectors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of any ongoing drain operation at this worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrainStatus(options: any = {}): FetchArgs {
            const localVarPath = `/worker/drain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of any ongoing drain operation at the specified worker
         * @param {string} [workerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrainStatusFromLeader(workerId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/worker/leader/drain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request should be executed by Monitoring agent on each worker to fetch the worker-metrics
         * @summary Gets the metrics for Monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options: any = {}): FetchArgs {
            const localVarPath = `/worker-stats/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requested should be executed by Monitoring agent on each worker to fetch the metrics
         * @summary Get metrics for all functions owned by worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options: any = {}): FetchArgs {
            const localVarPath = `/worker-stats/functionsmetrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if this node is the leader and is ready to service requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLeaderReady(options: any = {}): FetchArgs {
            const localVarPath = `/worker/cluster/leader/ready`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Triggers a rebalance of functions to workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalance(options: any = {}): FetchArgs {
            const localVarPath = `/worker/rebalance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Drains this worker, i.e., moves its work-assignments to other workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        drain(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).drain(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Drains the specified worker, i.e., moves its work-assignments to other workers
         * @param {string} [workerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        drainAtLeader(workerId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).drainAtLeader(workerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignments(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: any; }> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getAssignments(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetches information about the Pulsar cluster running Pulsar Functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WorkerInfo>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getCluster(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterLeader(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WorkerInfo> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getClusterLeader(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Fetches a list of supported Pulsar IO connectors currently running in cluster mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorsList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getConnectorsList(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the status of any ongoing drain operation at this worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrainStatus(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LongRunningProcessStatus> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getDrainStatus(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the status of any ongoing drain operation at the specified worker
         * @param {string} [workerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrainStatusFromLeader(workerId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LongRunningProcessStatus> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getDrainStatusFromLeader(workerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request should be executed by Monitoring agent on each worker to fetch the worker-metrics
         * @summary Gets the metrics for Monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Metrics>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getMetrics(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Requested should be executed by Monitoring agent on each worker to fetch the metrics
         * @summary Get metrics for all functions owned by worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WorkerFunctionInstanceStats>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getStats(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Checks if this node is the leader and is ready to service requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLeaderReady(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).isLeaderReady(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Triggers a rebalance of functions to workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalance(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).rebalance(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Drains this worker, i.e., moves its work-assignments to other workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        drain(options?: any) {
            return DefaultApiFp(configuration).drain(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Drains the specified worker, i.e., moves its work-assignments to other workers
         * @param {string} [workerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        drainAtLeader(workerId?: string, options?: any) {
            return DefaultApiFp(configuration).drainAtLeader(workerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignments(options?: any) {
            return DefaultApiFp(configuration).getAssignments(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches information about the Pulsar cluster running Pulsar Functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(options?: any) {
            return DefaultApiFp(configuration).getCluster(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterLeader(options?: any) {
            return DefaultApiFp(configuration).getClusterLeader(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches a list of supported Pulsar IO connectors currently running in cluster mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectorsList(options?: any) {
            return DefaultApiFp(configuration).getConnectorsList(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the status of any ongoing drain operation at this worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrainStatus(options?: any) {
            return DefaultApiFp(configuration).getDrainStatus(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the status of any ongoing drain operation at the specified worker
         * @param {string} [workerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDrainStatusFromLeader(workerId?: string, options?: any) {
            return DefaultApiFp(configuration).getDrainStatusFromLeader(workerId, options)(fetch, basePath);
        },
        /**
         * Request should be executed by Monitoring agent on each worker to fetch the worker-metrics
         * @summary Gets the metrics for Monitoring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(options?: any) {
            return DefaultApiFp(configuration).getMetrics(options)(fetch, basePath);
        },
        /**
         * Requested should be executed by Monitoring agent on each worker to fetch the metrics
         * @summary Get metrics for all functions owned by worker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options?: any) {
            return DefaultApiFp(configuration).getStats(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Checks if this node is the leader and is ready to service requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLeaderReady(options?: any) {
            return DefaultApiFp(configuration).isLeaderReady(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Triggers a rebalance of functions to workers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalance(options?: any) {
            return DefaultApiFp(configuration).rebalance(options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Drains this worker, i.e., moves its work-assignments to other workers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public drain(options?: any) {
        return DefaultApiFp(this.configuration).drain(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Drains the specified worker, i.e., moves its work-assignments to other workers
     * @param {string} [workerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public drainAtLeader(workerId?: string, options?: any) {
        return DefaultApiFp(this.configuration).drainAtLeader(workerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAssignments(options?: any) {
        return DefaultApiFp(this.configuration).getAssignments(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetches information about the Pulsar cluster running Pulsar Functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCluster(options?: any) {
        return DefaultApiFp(this.configuration).getCluster(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getClusterLeader(options?: any) {
        return DefaultApiFp(this.configuration).getClusterLeader(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Fetches a list of supported Pulsar IO connectors currently running in cluster mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConnectorsList(options?: any) {
        return DefaultApiFp(this.configuration).getConnectorsList(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the status of any ongoing drain operation at this worker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDrainStatus(options?: any) {
        return DefaultApiFp(this.configuration).getDrainStatus(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the status of any ongoing drain operation at the specified worker
     * @param {string} [workerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getDrainStatusFromLeader(workerId?: string, options?: any) {
        return DefaultApiFp(this.configuration).getDrainStatusFromLeader(workerId, options)(this.fetch, this.basePath);
    }

    /**
     * Request should be executed by Monitoring agent on each worker to fetch the worker-metrics
     * @summary Gets the metrics for Monitoring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMetrics(options?: any) {
        return DefaultApiFp(this.configuration).getMetrics(options)(this.fetch, this.basePath);
    }

    /**
     * Requested should be executed by Monitoring agent on each worker to fetch the metrics
     * @summary Get metrics for all functions owned by worker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStats(options?: any) {
        return DefaultApiFp(this.configuration).getStats(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Checks if this node is the leader and is ready to service requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public isLeaderReady(options?: any) {
        return DefaultApiFp(this.configuration).isLeaderReady(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Triggers a rebalance of functions to workers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rebalance(options?: any) {
        return DefaultApiFp(this.configuration).rebalance(options)(this.fetch, this.basePath);
    }

}

/**
 * NamespacesApi - fetch parameter creator
 * @export
 */
export const NamespacesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear backlog for all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBacklog(tenant: string, namespace: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling clearNamespaceBacklog.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling clearNamespaceBacklog.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/clearBacklog`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear backlog for a given subscription on all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBacklogForSubscription(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling clearNamespaceBacklogForSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling clearNamespaceBacklogForSubscription.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription','Required parameter subscription was null or undefined when calling clearNamespaceBacklogForSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/clearBacklog/{subscription}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear backlog for all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBundleBacklog(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling clearNamespaceBundleBacklog.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling clearNamespaceBundleBacklog.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling clearNamespaceBundleBacklog.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear backlog for a given subscription on all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBundleBacklogForSubscription(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling clearNamespaceBundleBacklogForSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling clearNamespaceBundleBacklogForSubscription.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription','Required parameter subscription was null or undefined when calling clearNamespaceBundleBacklogForSubscription.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling clearNamespaceBundleBacklogForSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog/{subscription}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearOffloadDeletionLag(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling clearOffloadDeletionLag.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling clearOffloadDeletionLag.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/offloadDeletionLagMs`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearProperties(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling clearProperties.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling clearProperties.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/properties`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new namespace with the specified policies
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Policies} [body] Policies for the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(tenant: string, namespace: string, body?: Policies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createNamespace.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Policies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the bookie-affinity-group from namespace-local policy.
         * @param {string} property 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookieAffinityGroup(property: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'property' is not null or undefined
            if (property === null || property === undefined) {
                throw new RequiredError('property','Required parameter property was null or undefined when calling deleteBookieAffinityGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteBookieAffinityGroup.');
            }
            const localVarPath = `/namespaces/{property}/{namespace}/persistence/bookieAffinity`
                .replace(`{${"property"}}`, encodeURIComponent(String(property)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompactionThreshold(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteCompactionThreshold.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDispatchRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a namespace and all the topics under it.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [force] 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, namespace: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteNamespace.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a namespace bundle and all the topics under it.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [force] 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceBundle(tenant: string, namespace: string, bundle: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteNamespaceBundle.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteNamespaceBundle.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling deleteNamespaceBundle.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/{bundle}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the persistence configuration for all topics on a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersistence(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deletePersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deletePersistence.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete subscribe-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribeRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteSubscribeRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Subscription dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionDispatchRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteSubscriptionDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
         * @param {string} cluster 
         * @param {string} group 
         * @param {string} [tenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAntiAffinityNamespaces(cluster: string, group: string, tenant?: string, options: any = {}): FetchArgs {
            // verify required parameter 'cluster' is not null or undefined
            if (cluster === null || cluster === undefined) {
                throw new RequiredError('cluster','Required parameter cluster was null or undefined when calling getAntiAffinityNamespaces.');
            }
            // verify required parameter 'group' is not null or undefined
            if (group === null || group === undefined) {
                throw new RequiredError('group','Required parameter group was null or undefined when calling getAntiAffinityNamespaces.');
            }
            const localVarPath = `/namespaces/{cluster}/antiAffinity/{group}`
                .replace(`{${"cluster"}}`, encodeURIComponent(String(cluster)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get autoSubscriptionCreation info in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoSubscriptionCreation(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getAutoSubscriptionCreation.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getAutoSubscriptionCreation.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/autoSubscriptionCreation`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get autoTopicCreation info in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTopicCreation(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getAutoTopicCreation.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getAutoTopicCreation.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/autoTopicCreation`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get backlog quota map on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBacklogQuotaMap.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBacklogQuotaMap.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/backlogQuotaMap`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the bookie-affinity-group from namespace-local policy.
         * @param {string} property 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookieAffinityGroup(property: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'property' is not null or undefined
            if (property === null || property === undefined) {
                throw new RequiredError('property','Required parameter property was null or undefined when calling getBookieAffinityGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBookieAffinityGroup.');
            }
            const localVarPath = `/namespaces/{property}/{namespace}/persistence/bookieAffinity`
                .replace(`{${"property"}}`, encodeURIComponent(String(property)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the bundles split data.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlesData(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBundlesData.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBundlesData.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/bundles`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Maximum number of uncompacted bytes in topics before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getCompactionThreshold.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDeduplication.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/deduplication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message encryption required status in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncryptionRequired(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getEncryptionRequired.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getEncryptionRequired.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/encryptionRequired`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inactive topic policies config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getInactiveTopicPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The flag of whether allow auto update schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsAllowAutoUpdateSchema(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getIsAllowAutoUpdateSchema.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getIsAllowAutoUpdateSchema.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxConsumersPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxConsumersPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerTopic(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxConsumersPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxConsumersPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxConsumersPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxProducersPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducersPerTopic(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxProducersPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxProducersPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxProducersPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxTopicsPerNamespace(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxTopicsPerNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxTopicsPerNamespace.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxTopicsPerNamespace`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxUnackedMessagesPerConsumer config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxUnackedMessagesPerConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxUnackedMessagesPerConsumer.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxUnackedMessagesPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxUnackedmessagesPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxUnackedmessagesPerSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get anti-affinity group of a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAntiAffinityGroup(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getNamespaceAntiAffinityGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getNamespaceAntiAffinityGroup.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/antiAffinity`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the message TTL for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceMessageTTL(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getNamespaceMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getNamespaceMessageTTL.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the replication clusters for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceReplicationClusters(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getNamespaceReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getNamespaceReplicationClusters.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the resourcegroup attached to the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceResourceGroup(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getNamespaceResourceGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getNamespaceResourceGroup.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/resourcegroup`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A negative value denotes that deletion has been completely disabled. 'null' denotes that the topics in the namespace will fall back to the broker default for deletion lag.
         * @summary Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadDeletionLag(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getOffloadDeletionLag.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getOffloadDeletionLag.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/offloadDeletionLagMs`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getOffloadPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A negative value disables automatic offloading
         * @summary Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadThreshold(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getOffloadThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getOffloadThreshold.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/offloadThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the permissions for a subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionOnSubscription(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPermissionOnSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPermissionOnSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/permissions/subscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the permissions for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPermissions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPermissions.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/permissions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the persistence configuration for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPersistence.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the dump all the policies specified for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get key value pair properties for a given namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getProperties.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getProperties.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/properties`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperty(tenant: string, namespace: string, key: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getProperty.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getProperty.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProperty.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/property/{key}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getReplicatorDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get retention config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRetention.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
         * @summary The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchemaAutoUpdateCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchemaAutoUpdateCompatibilityStrategy.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The strategy of the namespace schema compatibility 
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
         * @summary Get schema validation enforced flag for namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [applied] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidtionEnforced(tenant: string, namespace: string, applied?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchemaValidtionEnforced.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchemaValidtionEnforced.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/schemaValidationEnforced`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subscribe-rate configured for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscribeRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subscription auth mode in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuthMode(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionAuthMode.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionAuthMode.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionAuthMode`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the subscription expiration time for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionExpirationTime(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionExpirationTime.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionExpirationTime.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionExpirationTime`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The set of whether allow subscription types
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all the namespaces for a certain tenant.
         * @param {string} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantNamespaces(tenant: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getTenantNamespaces.');
            }
            const localVarPath = `/namespaces/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get hash positions for topics
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicHashPositions(tenant: string, namespace: string, bundle: string, topics?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getTopicHashPositions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getTopicHashPositions.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling getTopicHashPositions.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/{bundle}/topicHashPositions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (topics) {
                localVarQueryParameter['topics'] = topics;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all the topics under a certain namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'PERSISTENT' | 'NON_PERSISTENT' | 'ALL'} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics(tenant: string, namespace: string, mode?: 'PERSISTENT' | 'NON_PERSISTENT' | 'ALL', options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getTopics.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getTopics.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/topics`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant a new permission to a role on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} role 
         * @param {Array<string>} [body] List of permissions for the specified role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionOnNamespace(tenant: string, namespace: string, role: string, body?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling grantPermissionOnNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling grantPermissionOnNamespace.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling grantPermissionOnNamespace.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/permissions/{role}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable or disable broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag for disabling or enabling broker side deduplication for all topics in the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyDeduplication(tenant: string, namespace: string, body: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling modifyDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling modifyDeduplication.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyDeduplication.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/deduplication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Message encryption is required or not for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag defining if message encryption is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEncryptionRequired(tenant: string, namespace: string, body: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling modifyEncryptionRequired.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling modifyEncryptionRequired.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyEncryptionRequired.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/encryptionRequired`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove override of broker's allowAutoSubscriptionCreation in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAutoSubscriptionCreation(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeAutoSubscriptionCreation.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeAutoSubscriptionCreation.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/autoSubscriptionCreation`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove override of broker's allowAutoTopicCreation in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAutoTopicCreation(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeAutoTopicCreation.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeAutoTopicCreation.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/autoTopicCreation`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeBacklogQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeBacklogQuota.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/backlogQuota`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeDeduplication.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/deduplication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDelayedDeliveryPolicies(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeDelayedDeliveryPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove inactive topic policies from a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeInactiveTopicPolicies(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeInactiveTopicPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerTopic(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxConsumersPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxConsumersPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxConsumersPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxProducersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducersPerTopic(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxProducersPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxProducersPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxProducersPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxUnackedMessagesPerConsumer config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxUnackedmessagesPerConsumer(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxUnackedmessagesPerConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxUnackedmessagesPerConsumer.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxUnackedMessagesPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxUnackedmessagesPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxUnackedmessagesPerSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove anti-affinity group of a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceAntiAffinityGroup(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeNamespaceAntiAffinityGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeNamespaceAntiAffinityGroup.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/antiAffinity`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message TTL in seconds for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMessageTTL(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeNamespaceMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeNamespaceMessageTTL.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete resourcegroup for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceResourceGroup(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeNamespaceResourceGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeNamespaceResourceGroup.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/resourcegroup`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeOffloadPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/removeOffloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProperty(tenant: string, namespace: string, key: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeProperty.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeProperty.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling removeProperty.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/property/{key}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove replicator dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeReplicatorDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Remove retention configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, body?: RetentionPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeRetention.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetentionPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove subscription expiration time for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionExpirationTime(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionExpirationTime.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionExpirationTime.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionExpirationTime`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Remove subscription types enabled on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all permissions to a role on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnNamespace(tenant: string, namespace: string, role: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling revokePermissionsOnNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling revokePermissionsOnNamespace.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling revokePermissionsOnNamespace.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/permissions/{role}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanOffloadedLedgers(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling scanOffloadedLedgers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling scanOffloadedLedgers.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/scanOffloadedLedgers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Override broker's allowAutoSubscriptionCreation setting for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {AutoSubscriptionCreationOverride} [body] Settings for automatic subscription creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoSubscriptionCreation(tenant: string, namespace: string, body?: AutoSubscriptionCreationOverride, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setAutoSubscriptionCreation.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setAutoSubscriptionCreation.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/autoSubscriptionCreation`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoSubscriptionCreationOverride" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Override broker's allowAutoTopicCreation setting for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {AutoTopicCreationOverride} body Settings for automatic topic creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoTopicCreation(tenant: string, namespace: string, body: AutoTopicCreationOverride, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setAutoTopicCreation.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setAutoTopicCreation.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setAutoTopicCreation.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/autoTopicCreation`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AutoTopicCreationOverride" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set a backlog quota for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {BacklogQuota} [body] Backlog quota for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', body?: BacklogQuota, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setBacklogQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setBacklogQuota.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/backlogQuota`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BacklogQuota" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the bookie-affinity-group to namespace-persistent policy.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {BookieAffinityGroupData} [body] Bookie affinity group for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBookieAffinityGroup(tenant: string, namespace: string, body?: BookieAffinityGroupData, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setBookieAffinityGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setBookieAffinityGroup.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/persistence/bookieAffinity`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BookieAffinityGroupData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Set maximum number of uncompacted bytes in a topic before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Maximum number of uncompacted bytes in a topic of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setCompactionThreshold.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setCompactionThreshold.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Interval to take deduplication snapshot per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, body?: DelayedDeliveryPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DelayedDeliveryPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set inactive topic policies config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {InactiveTopicPolicies} [body] Inactive topic policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, body?: InactiveTopicPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setInactiveTopicPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InactiveTopicPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum topics for specific namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies_1(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setInactiveTopicPolicies_1.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setInactiveTopicPolicies_1.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setInactiveTopicPolicies_1.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxTopicsPerNamespace`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies_2(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setInactiveTopicPolicies_2.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setInactiveTopicPolicies_2.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxTopicsPerNamespace`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update flag of whether allow auto update schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag of whether to allow auto update schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIsAllowAutoUpdateSchema(tenant: string, namespace: string, body: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setIsAllowAutoUpdateSchema.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setIsAllowAutoUpdateSchema.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setIsAllowAutoUpdateSchema.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum consumers per subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum consumers per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerTopic(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxConsumersPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxConsumersPerTopic.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setMaxConsumersPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxConsumersPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set maxProducersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum producers per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducersPerTopic(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxProducersPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxProducersPerTopic.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setMaxProducersPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxProducersPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set maxSubscriptionsPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum subscriptions per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum unacked messages per consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxUnackedMessagesPerConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxUnackedMessagesPerConsumer.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setMaxUnackedMessagesPerConsumer.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set maxUnackedMessagesPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum unacked messages per subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesPerSubscription(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxUnackedMessagesPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxUnackedMessagesPerSubscription.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setMaxUnackedMessagesPerSubscription.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set anti-affinity group for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} body Anti-affinity group for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceAntiAffinityGroup(tenant: string, namespace: string, body: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setNamespaceAntiAffinityGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setNamespaceAntiAffinityGroup.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setNamespaceAntiAffinityGroup.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/antiAffinity`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message TTL in seconds for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body TTL in seconds for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceMessageTTL(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setNamespaceMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setNamespaceMessageTTL.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setNamespaceMessageTTL.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the replication clusters for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Array<string>} body List of replication clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceReplicationClusters(tenant: string, namespace: string, body: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setNamespaceReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setNamespaceReplicationClusters.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setNamespaceReplicationClusters.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set resourcegroup for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceResourceGroup(tenant: string, namespace: string, resourcegroup: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setNamespaceResourceGroup.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setNamespaceResourceGroup.');
            }
            // verify required parameter 'resourcegroup' is not null or undefined
            if (resourcegroup === null || resourcegroup === undefined) {
                throw new RequiredError('resourcegroup','Required parameter resourcegroup was null or undefined when calling setNamespaceResourceGroup.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/resourcegroup/{resourcegroup}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"resourcegroup"}}`, encodeURIComponent(String(resourcegroup)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A negative value disables the deletion completely.
         * @summary Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body New number of milliseconds to wait before deleting a ledger segment which has been offloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadDeletionLag(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setOffloadDeletionLag.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setOffloadDeletionLag.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setOffloadDeletionLag.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/offloadDeletionLagMs`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {OffloadPoliciesImpl} body Offload policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, body: OffloadPoliciesImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setOffloadPolicies.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setOffloadPolicies.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OffloadPoliciesImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * -1 will revert to using the cluster default. A negative value disables automatic offloading. 
         * @summary Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadThreshold(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setOffloadThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setOffloadThreshold.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setOffloadThreshold.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/offloadThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the persistence configuration for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {PersistencePolicies} body Persistence policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, body: PersistencePolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setPersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setPersistence.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setPersistence.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PersistencePolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put key value pairs property on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {any} body Key value pair properties for the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperties(tenant: string, namespace: string, body: any, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setProperties.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setProperties.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setProperties.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/properties`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put a key value pair property on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperty(tenant: string, namespace: string, key: string, value: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setProperty.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setProperty.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling setProperty.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling setProperty.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/property/{key}/{value}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set replicator dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Replicator dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setReplicatorDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set retention configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, body?: RetentionPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setRetention.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetentionPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
         * @summary Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Strategy used to check the compatibility of new schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSchemaAutoUpdateCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSchemaAutoUpdateCompatibilityStrategy.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the strategy used to check the compatibility of new schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
         * @summary Set schema validation enforced flag on namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag of whether validation is enforced on the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, body: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setSchemaValidationEnforced.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/schemaValidationEnforced`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set subscribe-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {SubscribeRate} [body] Subscribe rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, body?: SubscribeRate, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscribeRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscribeRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary  Set a subscription auth mode for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Subscription auth mode for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionAuthMode(tenant: string, namespace: string, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionAuthMode.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionAuthMode.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionAuthMode`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Subscription dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Subscription dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionDispatchRate.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set subscription expiration time in minutes for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Expiration time in minutes for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionExpirationTime(tenant: string, namespace: string, body: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionExpirationTime.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionExpirationTime.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setSubscriptionExpirationTime.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionExpirationTime`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update set of whether allow share sub type
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Array<string>} body Set of whether allow subscription types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, body: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Split a namespace bundle
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {boolean} [unload] 
         * @param {string} [splitAlgorithmName] 
         * @param {Array<number>} [body] splitBoundaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, unload?: boolean, splitAlgorithmName?: string, body?: Array<number>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling splitNamespaceBundle.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling splitNamespaceBundle.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling splitNamespaceBundle.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/{bundle}/split`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (unload !== undefined) {
                localVarQueryParameter['unload'] = unload;
            }

            if (splitAlgorithmName !== undefined) {
                localVarQueryParameter['splitAlgorithmName'] = splitAlgorithmName;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;number&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unload an active namespace from the current broker serving it. Performing this operation will let the brokerremoves all producers, consumers, and connections using this namespace, and close all topics (includingtheir persistent store). During that operation, the namespace is marked as tentatively unavailable until thebroker completes the unloading action. This operation requires strictly super user privileges, since it wouldresult in non-persistent message loss and unexpected connection closure to the clients.
         * @summary Unload namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadNamespace(tenant: string, namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling unloadNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling unloadNamespace.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/unload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unload a namespace bundle
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling unloadNamespaceBundle.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling unloadNamespaceBundle.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling unloadNamespaceBundle.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/{bundle}/unload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribes the given subscription on all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeNamespace(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling unsubscribeNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling unsubscribeNamespace.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription','Required parameter subscription was null or undefined when calling unsubscribeNamespace.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/unsubscribe/{subscription}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribes the given subscription on all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeNamespaceBundle(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling unsubscribeNamespaceBundle.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling unsubscribeNamespaceBundle.');
            }
            // verify required parameter 'subscription' is not null or undefined
            if (subscription === null || subscription === undefined) {
                throw new RequiredError('subscription','Required parameter subscription was null or undefined when calling unsubscribeNamespaceBundle.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling unsubscribeNamespaceBundle.');
            }
            const localVarPath = `/namespaces/{tenant}/{namespace}/{bundle}/unsubscribe/{subscription}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"subscription"}}`, encodeURIComponent(String(subscription)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NamespacesApi - functional programming interface
 * @export
 */
export const NamespacesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Clear backlog for all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBacklog(tenant: string, namespace: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).clearNamespaceBacklog(tenant, namespace, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clear backlog for a given subscription on all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBacklogForSubscription(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).clearNamespaceBacklogForSubscription(tenant, namespace, subscription, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clear backlog for all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBundleBacklog(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).clearNamespaceBundleBacklog(tenant, namespace, bundle, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clear backlog for a given subscription on all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBundleBacklogForSubscription(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).clearNamespaceBundleBacklogForSubscription(tenant, namespace, subscription, bundle, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearOffloadDeletionLag(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).clearOffloadDeletionLag(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearProperties(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).clearProperties(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new namespace with the specified policies
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Policies} [body] Policies for the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(tenant: string, namespace: string, body?: Policies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).createNamespace(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the bookie-affinity-group from namespace-local policy.
         * @param {string} property 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookieAffinityGroup(property: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteBookieAffinityGroup(property, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompactionThreshold(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteCompactionThreshold(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDispatchRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteDispatchRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a namespace and all the topics under it.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [force] 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, namespace: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteNamespace(tenant, namespace, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a namespace bundle and all the topics under it.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [force] 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceBundle(tenant: string, namespace: string, bundle: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteNamespaceBundle(tenant, namespace, bundle, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the persistence configuration for all topics on a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersistence(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deletePersistence(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete subscribe-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribeRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteSubscribeRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete Subscription dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionDispatchRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).deleteSubscriptionDispatchRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
         * @param {string} cluster 
         * @param {string} group 
         * @param {string} [tenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAntiAffinityNamespaces(cluster: string, group: string, tenant?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getAntiAffinityNamespaces(cluster, group, tenant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get autoSubscriptionCreation info in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoSubscriptionCreation(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AutoSubscriptionCreationOverride> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getAutoSubscriptionCreation(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get autoTopicCreation info in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTopicCreation(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getAutoTopicCreation(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get backlog quota map on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: BacklogQuota; }> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getBacklogQuotaMap(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the bookie-affinity-group from namespace-local policy.
         * @param {string} property 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookieAffinityGroup(property: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BookieAffinityGroupData> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getBookieAffinityGroup(property, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the bundles split data.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlesData(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BundlesData> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getBundlesData(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Maximum number of uncompacted bytes in topics before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getCompactionThreshold(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getDeduplication(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getDeduplicationSnapshotInterval(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DelayedDeliveryPolicies> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getDelayedDeliveryPolicies(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DispatchRate> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getDispatchRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message encryption required status in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncryptionRequired(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getEncryptionRequired(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get inactive topic policies config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InactiveTopicPolicies> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getInactiveTopicPolicies(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary The flag of whether allow auto update schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsAllowAutoUpdateSchema(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getIsAllowAutoUpdateSchema(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxConsumersPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getMaxConsumersPerSubscription(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxConsumersPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerTopic(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getMaxConsumersPerTopic(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxProducersPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducersPerTopic(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getMaxProducersPerTopic(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getMaxSubscriptionsPerTopic(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxTopicsPerNamespace(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getMaxTopicsPerNamespace(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxUnackedMessagesPerConsumer config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getMaxUnackedMessagesPerConsumer(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxUnackedMessagesPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getMaxUnackedmessagesPerSubscription(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get anti-affinity group of a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAntiAffinityGroup(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getNamespaceAntiAffinityGroup(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the message TTL for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceMessageTTL(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getNamespaceMessageTTL(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the replication clusters for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceReplicationClusters(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getNamespaceReplicationClusters(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the resourcegroup attached to the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceResourceGroup(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getNamespaceResourceGroup(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A negative value denotes that deletion has been completely disabled. 'null' denotes that the topics in the namespace will fall back to the broker default for deletion lag.
         * @summary Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadDeletionLag(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getOffloadDeletionLag(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OffloadPoliciesImpl> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getOffloadPolicies(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A negative value disables automatic offloading
         * @summary Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadThreshold(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getOffloadThreshold(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve the permissions for a subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionOnSubscription(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Array<string>; }> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getPermissionOnSubscription(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Retrieve the permissions for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getPermissions(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the persistence configuration for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersistencePolicies> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getPersistence(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the dump all the policies specified for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Policies> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getPolicies(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get key value pair properties for a given namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getProperties(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperty(tenant: string, namespace: string, key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getProperty(tenant, namespace, key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DispatchRate> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getReplicatorDispatchRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get retention config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RetentionPolicies> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getRetention(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
         * @summary The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSchemaAutoUpdateCompatibilityStrategy(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary The strategy of the namespace schema compatibility 
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSchemaCompatibilityStrategy(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
         * @summary Get schema validation enforced flag for namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [applied] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidtionEnforced(tenant: string, namespace: string, applied?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSchemaValidtionEnforced(tenant, namespace, applied, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subscribe-rate configured for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubscribeRate> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSubscribeRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subscription auth mode in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuthMode(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSubscriptionAuthMode(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DispatchRate> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSubscriptionDispatchRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the subscription expiration time for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionExpirationTime(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSubscriptionExpirationTime(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary The set of whether allow subscription types
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getSubscriptionTypesEnabled(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of all the namespaces for a certain tenant.
         * @param {string} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantNamespaces(tenant: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getTenantNamespaces(tenant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get hash positions for topics
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicHashPositions(tenant: string, namespace: string, bundle: string, topics?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getTopicHashPositions(tenant, namespace, bundle, topics, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of all the topics under a certain namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'PERSISTENT' | 'NON_PERSISTENT' | 'ALL'} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics(tenant: string, namespace: string, mode?: 'PERSISTENT' | 'NON_PERSISTENT' | 'ALL', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).getTopics(tenant, namespace, mode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Grant a new permission to a role on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} role 
         * @param {Array<string>} [body] List of permissions for the specified role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionOnNamespace(tenant: string, namespace: string, role: string, body?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).grantPermissionOnNamespace(tenant, namespace, role, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable or disable broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag for disabling or enabling broker side deduplication for all topics in the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyDeduplication(tenant: string, namespace: string, body: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).modifyDeduplication(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Message encryption is required or not for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag defining if message encryption is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEncryptionRequired(tenant: string, namespace: string, body: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).modifyEncryptionRequired(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove override of broker's allowAutoSubscriptionCreation in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAutoSubscriptionCreation(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeAutoSubscriptionCreation(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove override of broker's allowAutoTopicCreation in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAutoTopicCreation(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeAutoTopicCreation(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeBacklogQuota(tenant, namespace, backlogQuotaType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeDeduplication(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDelayedDeliveryPolicies(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeDelayedDeliveryPolicies(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove inactive topic policies from a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeInactiveTopicPolicies(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeInactiveTopicPolicies(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeMaxConsumersPerSubscription(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerTopic(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeMaxConsumersPerTopic(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxProducersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducersPerTopic(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeMaxProducersPerTopic(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxUnackedMessagesPerConsumer config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxUnackedmessagesPerConsumer(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeMaxUnackedmessagesPerConsumer(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxUnackedMessagesPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeMaxUnackedmessagesPerSubscription(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove anti-affinity group of a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceAntiAffinityGroup(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeNamespaceAntiAffinityGroup(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message TTL in seconds for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMessageTTL(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeNamespaceMessageTTL(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete resourcegroup for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceResourceGroup(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeNamespaceResourceGroup(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeOffloadPolicies(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProperty(tenant: string, namespace: string, key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeProperty(tenant, namespace, key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove replicator dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeReplicatorDispatchRate(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Remove retention configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, body?: RetentionPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeRetention(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove subscription expiration time for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionExpirationTime(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeSubscriptionExpirationTime(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Remove subscription types enabled on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).removeSubscriptionTypesEnabled(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Revoke all permissions to a role on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnNamespace(tenant: string, namespace: string, role: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).revokePermissionsOnNamespace(tenant, namespace, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanOffloadedLedgers(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).scanOffloadedLedgers(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Override broker's allowAutoSubscriptionCreation setting for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {AutoSubscriptionCreationOverride} [body] Settings for automatic subscription creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoSubscriptionCreation(tenant: string, namespace: string, body?: AutoSubscriptionCreationOverride, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setAutoSubscriptionCreation(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Override broker's allowAutoTopicCreation setting for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {AutoTopicCreationOverride} body Settings for automatic topic creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoTopicCreation(tenant: string, namespace: string, body: AutoTopicCreationOverride, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setAutoTopicCreation(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set a backlog quota for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {BacklogQuota} [body] Backlog quota for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', body?: BacklogQuota, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setBacklogQuota(tenant, namespace, backlogQuotaType, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the bookie-affinity-group to namespace-persistent policy.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {BookieAffinityGroupData} [body] Bookie affinity group for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBookieAffinityGroup(tenant: string, namespace: string, body?: BookieAffinityGroupData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setBookieAffinityGroup(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Set maximum number of uncompacted bytes in a topic before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Maximum number of uncompacted bytes in a topic of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setCompactionThreshold(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Interval to take deduplication snapshot per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setDeduplicationSnapshotInterval(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, body?: DelayedDeliveryPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setDelayedDeliveryPolicies(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setDispatchRate(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set inactive topic policies config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {InactiveTopicPolicies} [body] Inactive topic policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, body?: InactiveTopicPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setInactiveTopicPolicies(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum topics for specific namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies_1(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setInactiveTopicPolicies_1(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies_2(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setInactiveTopicPolicies_2(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update flag of whether allow auto update schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag of whether to allow auto update schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIsAllowAutoUpdateSchema(tenant: string, namespace: string, body: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setIsAllowAutoUpdateSchema(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum consumers per subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setMaxConsumersPerSubscription(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum consumers per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerTopic(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setMaxConsumersPerTopic(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set maxProducersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum producers per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducersPerTopic(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setMaxProducersPerTopic(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set maxSubscriptionsPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum subscriptions per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setMaxSubscriptionsPerTopic(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum unacked messages per consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setMaxUnackedMessagesPerConsumer(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set maxUnackedMessagesPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum unacked messages per subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesPerSubscription(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setMaxUnackedMessagesPerSubscription(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set anti-affinity group for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} body Anti-affinity group for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceAntiAffinityGroup(tenant: string, namespace: string, body: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setNamespaceAntiAffinityGroup(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message TTL in seconds for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body TTL in seconds for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceMessageTTL(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setNamespaceMessageTTL(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the replication clusters for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Array<string>} body List of replication clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceReplicationClusters(tenant: string, namespace: string, body: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setNamespaceReplicationClusters(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set resourcegroup for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceResourceGroup(tenant: string, namespace: string, resourcegroup: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setNamespaceResourceGroup(tenant, namespace, resourcegroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A negative value disables the deletion completely.
         * @summary Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body New number of milliseconds to wait before deleting a ledger segment which has been offloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadDeletionLag(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setOffloadDeletionLag(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {OffloadPoliciesImpl} body Offload policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, body: OffloadPoliciesImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setOffloadPolicies(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * -1 will revert to using the cluster default. A negative value disables automatic offloading. 
         * @summary Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadThreshold(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setOffloadThreshold(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the persistence configuration for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {PersistencePolicies} body Persistence policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, body: PersistencePolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setPersistence(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Put key value pairs property on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {any} body Key value pair properties for the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperties(tenant: string, namespace: string, body: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setProperties(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Put a key value pair property on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperty(tenant: string, namespace: string, key: string, value: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setProperty(tenant, namespace, key, value, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set replicator dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Replicator dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setReplicatorDispatchRate(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set retention configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, body?: RetentionPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setRetention(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
         * @summary Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Strategy used to check the compatibility of new schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSchemaAutoUpdateCompatibilityStrategy(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the strategy used to check the compatibility of new schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSchemaCompatibilityStrategy(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
         * @summary Set schema validation enforced flag on namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag of whether validation is enforced on the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, body: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSchemaValidationEnforced(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set subscribe-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {SubscribeRate} [body] Subscribe rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, body?: SubscribeRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSubscribeRate(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary  Set a subscription auth mode for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Subscription auth mode for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionAuthMode(tenant: string, namespace: string, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSubscriptionAuthMode(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set Subscription dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Subscription dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSubscriptionDispatchRate(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set subscription expiration time in minutes for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Expiration time in minutes for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionExpirationTime(tenant: string, namespace: string, body: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSubscriptionExpirationTime(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update set of whether allow share sub type
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Array<string>} body Set of whether allow subscription types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, body: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).setSubscriptionTypesEnabled(tenant, namespace, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Split a namespace bundle
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {boolean} [unload] 
         * @param {string} [splitAlgorithmName] 
         * @param {Array<number>} [body] splitBoundaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, unload?: boolean, splitAlgorithmName?: string, body?: Array<number>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).splitNamespaceBundle(tenant, namespace, bundle, authoritative, unload, splitAlgorithmName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unload an active namespace from the current broker serving it. Performing this operation will let the brokerremoves all producers, consumers, and connections using this namespace, and close all topics (includingtheir persistent store). During that operation, the namespace is marked as tentatively unavailable until thebroker completes the unloading action. This operation requires strictly super user privileges, since it wouldresult in non-persistent message loss and unexpected connection closure to the clients.
         * @summary Unload namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadNamespace(tenant: string, namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).unloadNamespace(tenant, namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unload a namespace bundle
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).unloadNamespaceBundle(tenant, namespace, bundle, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unsubscribes the given subscription on all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeNamespace(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).unsubscribeNamespace(tenant, namespace, subscription, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unsubscribes the given subscription on all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeNamespaceBundle(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NamespacesApiFetchParamCreator(configuration).unsubscribeNamespaceBundle(tenant, namespace, subscription, bundle, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NamespacesApi - factory interface
 * @export
 */
export const NamespacesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Clear backlog for all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBacklog(tenant: string, namespace: string, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).clearNamespaceBacklog(tenant, namespace, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clear backlog for a given subscription on all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBacklogForSubscription(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).clearNamespaceBacklogForSubscription(tenant, namespace, subscription, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clear backlog for all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBundleBacklog(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).clearNamespaceBundleBacklog(tenant, namespace, bundle, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clear backlog for a given subscription on all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearNamespaceBundleBacklogForSubscription(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).clearNamespaceBundleBacklogForSubscription(tenant, namespace, subscription, bundle, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearOffloadDeletionLag(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).clearOffloadDeletionLag(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearProperties(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).clearProperties(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new namespace with the specified policies
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Policies} [body] Policies for the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNamespace(tenant: string, namespace: string, body?: Policies, options?: any) {
            return NamespacesApiFp(configuration).createNamespace(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the bookie-affinity-group from namespace-local policy.
         * @param {string} property 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookieAffinityGroup(property: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).deleteBookieAffinityGroup(property, namespace, options)(fetch, basePath);
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompactionThreshold(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).deleteCompactionThreshold(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDispatchRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).deleteDispatchRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a namespace and all the topics under it.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [force] 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespace(tenant: string, namespace: string, force?: boolean, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).deleteNamespace(tenant, namespace, force, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a namespace bundle and all the topics under it.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [force] 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNamespaceBundle(tenant: string, namespace: string, bundle: string, force?: boolean, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).deleteNamespaceBundle(tenant, namespace, bundle, force, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the persistence configuration for all topics on a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePersistence(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).deletePersistence(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete subscribe-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscribeRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).deleteSubscribeRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete Subscription dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionDispatchRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).deleteSubscriptionDispatchRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
         * @param {string} cluster 
         * @param {string} group 
         * @param {string} [tenant] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAntiAffinityNamespaces(cluster: string, group: string, tenant?: string, options?: any) {
            return NamespacesApiFp(configuration).getAntiAffinityNamespaces(cluster, group, tenant, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get autoSubscriptionCreation info in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoSubscriptionCreation(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getAutoSubscriptionCreation(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get autoTopicCreation info in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoTopicCreation(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getAutoTopicCreation(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get backlog quota map on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getBacklogQuotaMap(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the bookie-affinity-group from namespace-local policy.
         * @param {string} property 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookieAffinityGroup(property: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getBookieAffinityGroup(property, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the bundles split data.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundlesData(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getBundlesData(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Maximum number of uncompacted bytes in topics before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getCompactionThreshold(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getDeduplication(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getDeduplicationSnapshotInterval(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getDelayedDeliveryPolicies(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getDispatchRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message encryption required status in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEncryptionRequired(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getEncryptionRequired(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get inactive topic policies config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getInactiveTopicPolicies(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary The flag of whether allow auto update schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIsAllowAutoUpdateSchema(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getIsAllowAutoUpdateSchema(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxConsumersPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getMaxConsumersPerSubscription(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxConsumersPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerTopic(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getMaxConsumersPerTopic(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxProducersPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducersPerTopic(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getMaxProducersPerTopic(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getMaxSubscriptionsPerTopic(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxTopicsPerNamespace(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getMaxTopicsPerNamespace(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxUnackedMessagesPerConsumer config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getMaxUnackedMessagesPerConsumer(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxUnackedMessagesPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getMaxUnackedmessagesPerSubscription(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get anti-affinity group of a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceAntiAffinityGroup(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getNamespaceAntiAffinityGroup(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the message TTL for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceMessageTTL(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getNamespaceMessageTTL(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the replication clusters for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceReplicationClusters(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getNamespaceReplicationClusters(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the resourcegroup attached to the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceResourceGroup(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getNamespaceResourceGroup(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * A negative value denotes that deletion has been completely disabled. 'null' denotes that the topics in the namespace will fall back to the broker default for deletion lag.
         * @summary Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadDeletionLag(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getOffloadDeletionLag(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getOffloadPolicies(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * A negative value disables automatic offloading
         * @summary Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadThreshold(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getOffloadThreshold(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve the permissions for a subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionOnSubscription(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getPermissionOnSubscription(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Retrieve the permissions for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissions(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getPermissions(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the persistence configuration for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getPersistence(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the dump all the policies specified for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getPolicies(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get key value pair properties for a given namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperties(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getProperties(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProperty(tenant: string, namespace: string, key: string, options?: any) {
            return NamespacesApiFp(configuration).getProperty(tenant, namespace, key, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getReplicatorDispatchRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get retention config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getRetention(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
         * @summary The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getSchemaAutoUpdateCompatibilityStrategy(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary The strategy of the namespace schema compatibility 
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getSchemaCompatibilityStrategy(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
         * @summary Get schema validation enforced flag for namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} [applied] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidtionEnforced(tenant: string, namespace: string, applied?: boolean, options?: any) {
            return NamespacesApiFp(configuration).getSchemaValidtionEnforced(tenant, namespace, applied, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subscribe-rate configured for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getSubscribeRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subscription auth mode in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuthMode(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getSubscriptionAuthMode(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getSubscriptionDispatchRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the subscription expiration time for the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionExpirationTime(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getSubscriptionExpirationTime(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary The set of whether allow subscription types
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).getSubscriptionTypesEnabled(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of all the namespaces for a certain tenant.
         * @param {string} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantNamespaces(tenant: string, options?: any) {
            return NamespacesApiFp(configuration).getTenantNamespaces(tenant, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get hash positions for topics
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {Array<string>} [topics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicHashPositions(tenant: string, namespace: string, bundle: string, topics?: Array<string>, options?: any) {
            return NamespacesApiFp(configuration).getTopicHashPositions(tenant, namespace, bundle, topics, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of all the topics under a certain namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'PERSISTENT' | 'NON_PERSISTENT' | 'ALL'} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopics(tenant: string, namespace: string, mode?: 'PERSISTENT' | 'NON_PERSISTENT' | 'ALL', options?: any) {
            return NamespacesApiFp(configuration).getTopics(tenant, namespace, mode, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Grant a new permission to a role on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} role 
         * @param {Array<string>} [body] List of permissions for the specified role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionOnNamespace(tenant: string, namespace: string, role: string, body?: Array<string>, options?: any) {
            return NamespacesApiFp(configuration).grantPermissionOnNamespace(tenant, namespace, role, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable or disable broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag for disabling or enabling broker side deduplication for all topics in the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyDeduplication(tenant: string, namespace: string, body: boolean, options?: any) {
            return NamespacesApiFp(configuration).modifyDeduplication(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Message encryption is required or not for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag defining if message encryption is required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyEncryptionRequired(tenant: string, namespace: string, body: boolean, options?: any) {
            return NamespacesApiFp(configuration).modifyEncryptionRequired(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove override of broker's allowAutoSubscriptionCreation in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAutoSubscriptionCreation(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeAutoSubscriptionCreation(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove override of broker's allowAutoTopicCreation in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAutoTopicCreation(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeAutoTopicCreation(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any) {
            return NamespacesApiFp(configuration).removeBacklogQuota(tenant, namespace, backlogQuotaType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove broker side deduplication for all topics in a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeDeduplication(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDelayedDeliveryPolicies(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeDelayedDeliveryPolicies(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove inactive topic policies from a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeInactiveTopicPolicies(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeInactiveTopicPolicies(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set maxConsumersPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeMaxConsumersPerSubscription(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerTopic(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeMaxConsumersPerTopic(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxProducersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducersPerTopic(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeMaxProducersPerTopic(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxUnackedMessagesPerConsumer config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxUnackedmessagesPerConsumer(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeMaxUnackedmessagesPerConsumer(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxUnackedMessagesPerSubscription config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeMaxUnackedmessagesPerSubscription(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove anti-affinity group of a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceAntiAffinityGroup(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeNamespaceAntiAffinityGroup(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message TTL in seconds for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceMessageTTL(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeNamespaceMessageTTL(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete resourcegroup for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceResourceGroup(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeNamespaceResourceGroup(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeOffloadPolicies(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get property value for a given key on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProperty(tenant: string, namespace: string, key: string, options?: any) {
            return NamespacesApiFp(configuration).removeProperty(tenant, namespace, key, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove replicator dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeReplicatorDispatchRate(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Remove retention configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, body?: RetentionPolicies, options?: any) {
            return NamespacesApiFp(configuration).removeRetention(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove subscription expiration time for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionExpirationTime(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeSubscriptionExpirationTime(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Remove subscription types enabled on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).removeSubscriptionTypesEnabled(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Revoke all permissions to a role on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnNamespace(tenant: string, namespace: string, role: string, options?: any) {
            return NamespacesApiFp(configuration).revokePermissionsOnNamespace(tenant, namespace, role, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanOffloadedLedgers(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).scanOffloadedLedgers(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Override broker's allowAutoSubscriptionCreation setting for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {AutoSubscriptionCreationOverride} [body] Settings for automatic subscription creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoSubscriptionCreation(tenant: string, namespace: string, body?: AutoSubscriptionCreationOverride, options?: any) {
            return NamespacesApiFp(configuration).setAutoSubscriptionCreation(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Override broker's allowAutoTopicCreation setting for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {AutoTopicCreationOverride} body Settings for automatic topic creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoTopicCreation(tenant: string, namespace: string, body: AutoTopicCreationOverride, options?: any) {
            return NamespacesApiFp(configuration).setAutoTopicCreation(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set a backlog quota for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {BacklogQuota} [body] Backlog quota for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', body?: BacklogQuota, options?: any) {
            return NamespacesApiFp(configuration).setBacklogQuota(tenant, namespace, backlogQuotaType, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the bookie-affinity-group to namespace-persistent policy.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {BookieAffinityGroupData} [body] Bookie affinity group for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBookieAffinityGroup(tenant: string, namespace: string, body?: BookieAffinityGroupData, options?: any) {
            return NamespacesApiFp(configuration).setBookieAffinityGroup(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
         * @summary Set maximum number of uncompacted bytes in a topic before compaction is triggered.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Maximum number of uncompacted bytes in a topic of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setCompactionThreshold(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Interval to take deduplication snapshot per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setDeduplicationSnapshotInterval(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, body?: DelayedDeliveryPolicies, options?: any) {
            return NamespacesApiFp(configuration).setDelayedDeliveryPolicies(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any) {
            return NamespacesApiFp(configuration).setDispatchRate(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set inactive topic policies config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {InactiveTopicPolicies} [body] Inactive topic policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, body?: InactiveTopicPolicies, options?: any) {
            return NamespacesApiFp(configuration).setInactiveTopicPolicies(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum topics for specific namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies_1(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setInactiveTopicPolicies_1(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxTopicsPerNamespace config on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies_2(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).setInactiveTopicPolicies_2(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update flag of whether allow auto update schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag of whether to allow auto update schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIsAllowAutoUpdateSchema(tenant: string, namespace: string, body: boolean, options?: any) {
            return NamespacesApiFp(configuration).setIsAllowAutoUpdateSchema(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set maxConsumersPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum consumers per subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setMaxConsumersPerSubscription(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum consumers per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerTopic(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setMaxConsumersPerTopic(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set maxProducersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum producers per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducersPerTopic(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setMaxProducersPerTopic(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set maxSubscriptionsPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum subscriptions per topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setMaxSubscriptionsPerTopic(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set maxConsumersPerTopic configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum unacked messages per consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setMaxUnackedMessagesPerConsumer(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set maxUnackedMessagesPerSubscription configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Number of maximum unacked messages per subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesPerSubscription(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setMaxUnackedMessagesPerSubscription(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set anti-affinity group for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} body Anti-affinity group for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceAntiAffinityGroup(tenant: string, namespace: string, body: string, options?: any) {
            return NamespacesApiFp(configuration).setNamespaceAntiAffinityGroup(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message TTL in seconds for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body TTL in seconds for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceMessageTTL(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setNamespaceMessageTTL(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the replication clusters for a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Array<string>} body List of replication clusters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceReplicationClusters(tenant: string, namespace: string, body: Array<string>, options?: any) {
            return NamespacesApiFp(configuration).setNamespaceReplicationClusters(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set resourcegroup for a namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceResourceGroup(tenant: string, namespace: string, resourcegroup: string, options?: any) {
            return NamespacesApiFp(configuration).setNamespaceResourceGroup(tenant, namespace, resourcegroup, options)(fetch, basePath);
        },
        /**
         * A negative value disables the deletion completely.
         * @summary Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body New number of milliseconds to wait before deleting a ledger segment which has been offloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadDeletionLag(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setOffloadDeletionLag(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set offload configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {OffloadPoliciesImpl} body Offload policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, body: OffloadPoliciesImpl, options?: any) {
            return NamespacesApiFp(configuration).setOffloadPolicies(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * -1 will revert to using the cluster default. A negative value disables automatic offloading. 
         * @summary Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadThreshold(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setOffloadThreshold(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the persistence configuration for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {PersistencePolicies} body Persistence policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, body: PersistencePolicies, options?: any) {
            return NamespacesApiFp(configuration).setPersistence(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Put key value pairs property on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {any} body Key value pair properties for the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperties(tenant: string, namespace: string, body: any, options?: any) {
            return NamespacesApiFp(configuration).setProperties(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Put a key value pair property on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} key 
         * @param {string} value 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProperty(tenant: string, namespace: string, key: string, value: string, options?: any) {
            return NamespacesApiFp(configuration).setProperty(tenant, namespace, key, value, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set replicator dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Replicator dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any) {
            return NamespacesApiFp(configuration).setReplicatorDispatchRate(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set retention configuration on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, body?: RetentionPolicies, options?: any) {
            return NamespacesApiFp(configuration).setRetention(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
         * @summary Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Strategy used to check the compatibility of new schemas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, body?: string, options?: any) {
            return NamespacesApiFp(configuration).setSchemaAutoUpdateCompatibilityStrategy(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the strategy used to check the compatibility of new schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, body?: string, options?: any) {
            return NamespacesApiFp(configuration).setSchemaCompatibilityStrategy(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
         * @summary Set schema validation enforced flag on namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {boolean} body Flag of whether validation is enforced on the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, body: boolean, options?: any) {
            return NamespacesApiFp(configuration).setSchemaValidationEnforced(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set subscribe-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {SubscribeRate} [body] Subscribe rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, body?: SubscribeRate, options?: any) {
            return NamespacesApiFp(configuration).setSubscribeRate(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary  Set a subscription auth mode for all the topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} [body] Subscription auth mode for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionAuthMode(tenant: string, namespace: string, body?: string, options?: any) {
            return NamespacesApiFp(configuration).setSubscriptionAuthMode(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set Subscription dispatch-rate throttling for all topics of the namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {DispatchRateImpl} [body] Subscription dispatch rate for all topics of the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any) {
            return NamespacesApiFp(configuration).setSubscriptionDispatchRate(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set subscription expiration time in minutes for namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {number} body Expiration time in minutes for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionExpirationTime(tenant: string, namespace: string, body: number, options?: any) {
            return NamespacesApiFp(configuration).setSubscriptionExpirationTime(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update set of whether allow share sub type
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {Array<string>} body Set of whether allow subscription types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, body: Array<string>, options?: any) {
            return NamespacesApiFp(configuration).setSubscriptionTypesEnabled(tenant, namespace, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Split a namespace bundle
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {boolean} [unload] 
         * @param {string} [splitAlgorithmName] 
         * @param {Array<number>} [body] splitBoundaries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        splitNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, unload?: boolean, splitAlgorithmName?: string, body?: Array<number>, options?: any) {
            return NamespacesApiFp(configuration).splitNamespaceBundle(tenant, namespace, bundle, authoritative, unload, splitAlgorithmName, body, options)(fetch, basePath);
        },
        /**
         * Unload an active namespace from the current broker serving it. Performing this operation will let the brokerremoves all producers, consumers, and connections using this namespace, and close all topics (includingtheir persistent store). During that operation, the namespace is marked as tentatively unavailable until thebroker completes the unloading action. This operation requires strictly super user privileges, since it wouldresult in non-persistent message loss and unexpected connection closure to the clients.
         * @summary Unload namespace
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadNamespace(tenant: string, namespace: string, options?: any) {
            return NamespacesApiFp(configuration).unloadNamespace(tenant, namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unload a namespace bundle
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).unloadNamespaceBundle(tenant, namespace, bundle, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unsubscribes the given subscription on all topics on a namespace.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeNamespace(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).unsubscribeNamespace(tenant, namespace, subscription, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unsubscribes the given subscription on all topics on a namespace bundle.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} subscription 
         * @param {string} bundle 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribeNamespaceBundle(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options?: any) {
            return NamespacesApiFp(configuration).unsubscribeNamespaceBundle(tenant, namespace, subscription, bundle, authoritative, options)(fetch, basePath);
        },
    };
};

/**
 * NamespacesApi - object-oriented interface
 * @export
 * @class NamespacesApi
 * @extends {BaseAPI}
 */
export class NamespacesApi extends BaseAPI {
    /**
     * 
     * @summary Clear backlog for all topics on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public clearNamespaceBacklog(tenant: string, namespace: string, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).clearNamespaceBacklog(tenant, namespace, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clear backlog for a given subscription on all topics on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} subscription 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public clearNamespaceBacklogForSubscription(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).clearNamespaceBacklogForSubscription(tenant, namespace, subscription, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clear backlog for all topics on a namespace bundle.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} bundle 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public clearNamespaceBundleBacklog(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).clearNamespaceBundleBacklog(tenant, namespace, bundle, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clear backlog for a given subscription on all topics on a namespace bundle.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} subscription 
     * @param {string} bundle 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public clearNamespaceBundleBacklogForSubscription(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).clearNamespaceBundleBacklogForSubscription(tenant, namespace, subscription, bundle, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public clearOffloadDeletionLag(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).clearOffloadDeletionLag(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get property value for a given key on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public clearProperties(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).clearProperties(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new namespace with the specified policies
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {Policies} [body] Policies for the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public createNamespace(tenant: string, namespace: string, body?: Policies, options?: any) {
        return NamespacesApiFp(this.configuration).createNamespace(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the bookie-affinity-group from namespace-local policy.
     * @param {string} property 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteBookieAffinityGroup(property: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).deleteBookieAffinityGroup(property, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
     * @summary Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteCompactionThreshold(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).deleteCompactionThreshold(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete dispatch-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteDispatchRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).deleteDispatchRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a namespace and all the topics under it.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {boolean} [force] 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespace(tenant: string, namespace: string, force?: boolean, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).deleteNamespace(tenant, namespace, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a namespace bundle and all the topics under it.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} bundle 
     * @param {boolean} [force] 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteNamespaceBundle(tenant: string, namespace: string, bundle: string, force?: boolean, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).deleteNamespaceBundle(tenant, namespace, bundle, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the persistence configuration for all topics on a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deletePersistence(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).deletePersistence(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete subscribe-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteSubscribeRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).deleteSubscribeRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete Subscription dispatch-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public deleteSubscriptionDispatchRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).deleteSubscriptionDispatchRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
     * @param {string} cluster 
     * @param {string} group 
     * @param {string} [tenant] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getAntiAffinityNamespaces(cluster: string, group: string, tenant?: string, options?: any) {
        return NamespacesApiFp(this.configuration).getAntiAffinityNamespaces(cluster, group, tenant, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get autoSubscriptionCreation info in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getAutoSubscriptionCreation(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getAutoSubscriptionCreation(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get autoTopicCreation info in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getAutoTopicCreation(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getAutoTopicCreation(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get backlog quota map on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getBacklogQuotaMap(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getBacklogQuotaMap(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the bookie-affinity-group from namespace-local policy.
     * @param {string} property 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getBookieAffinityGroup(property: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getBookieAffinityGroup(property, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the bundles split data.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getBundlesData(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getBundlesData(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
     * @summary Maximum number of uncompacted bytes in topics before compaction is triggered.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getCompactionThreshold(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getCompactionThreshold(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get broker side deduplication for all topics in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getDeduplication(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getDeduplication(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get deduplicationSnapshotInterval config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getDeduplicationSnapshotInterval(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getDeduplicationSnapshotInterval(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get delayed delivery messages config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getDelayedDeliveryPolicies(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getDelayedDeliveryPolicies(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getDispatchRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getDispatchRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message encryption required status in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getEncryptionRequired(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getEncryptionRequired(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get inactive topic policies config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getInactiveTopicPolicies(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getInactiveTopicPolicies(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary The flag of whether allow auto update schema
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getIsAllowAutoUpdateSchema(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getIsAllowAutoUpdateSchema(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxConsumersPerSubscription config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getMaxConsumersPerSubscription(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getMaxConsumersPerSubscription(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxConsumersPerTopic config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getMaxConsumersPerTopic(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getMaxConsumersPerTopic(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxProducersPerTopic config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getMaxProducersPerTopic(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getMaxProducersPerTopic(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxSubscriptionsPerTopic config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getMaxSubscriptionsPerTopic(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getMaxSubscriptionsPerTopic(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxTopicsPerNamespace config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getMaxTopicsPerNamespace(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getMaxTopicsPerNamespace(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxUnackedMessagesPerConsumer config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getMaxUnackedMessagesPerConsumer(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxUnackedMessagesPerSubscription config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getMaxUnackedmessagesPerSubscription(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get anti-affinity group of a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceAntiAffinityGroup(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getNamespaceAntiAffinityGroup(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the message TTL for the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceMessageTTL(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getNamespaceMessageTTL(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the replication clusters for a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceReplicationClusters(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getNamespaceReplicationClusters(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the resourcegroup attached to the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getNamespaceResourceGroup(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getNamespaceResourceGroup(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * A negative value denotes that deletion has been completely disabled. 'null' denotes that the topics in the namespace will fall back to the broker default for deletion lag.
     * @summary Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getOffloadDeletionLag(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getOffloadDeletionLag(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get offload configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getOffloadPolicies(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getOffloadPolicies(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * A negative value disables automatic offloading
     * @summary Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getOffloadThreshold(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getOffloadThreshold(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve the permissions for a subscription.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getPermissionOnSubscription(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getPermissionOnSubscription(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Retrieve the permissions for a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getPermissions(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getPermissions(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the persistence configuration for a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getPersistence(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getPersistence(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the dump all the policies specified for a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getPolicies(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getPolicies(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get key value pair properties for a given namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getProperties(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getProperties(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get property value for a given key on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getProperty(tenant: string, namespace: string, key: string, options?: any) {
        return NamespacesApiFp(this.configuration).getProperty(tenant, namespace, key, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getReplicatorDispatchRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getReplicatorDispatchRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get retention config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getRetention(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getRetention(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
     * @summary The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getSchemaAutoUpdateCompatibilityStrategy(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary The strategy of the namespace schema compatibility 
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSchemaCompatibilityStrategy(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getSchemaCompatibilityStrategy(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
     * @summary Get schema validation enforced flag for namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {boolean} [applied] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSchemaValidtionEnforced(tenant: string, namespace: string, applied?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).getSchemaValidtionEnforced(tenant, namespace, applied, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subscribe-rate configured for the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSubscribeRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getSubscribeRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subscription auth mode in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSubscriptionAuthMode(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getSubscriptionAuthMode(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSubscriptionDispatchRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getSubscriptionDispatchRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the subscription expiration time for the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSubscriptionExpirationTime(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getSubscriptionExpirationTime(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary The set of whether allow subscription types
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getSubscriptionTypesEnabled(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).getSubscriptionTypesEnabled(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of all the namespaces for a certain tenant.
     * @param {string} tenant 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getTenantNamespaces(tenant: string, options?: any) {
        return NamespacesApiFp(this.configuration).getTenantNamespaces(tenant, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get hash positions for topics
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} bundle 
     * @param {Array<string>} [topics] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getTopicHashPositions(tenant: string, namespace: string, bundle: string, topics?: Array<string>, options?: any) {
        return NamespacesApiFp(this.configuration).getTopicHashPositions(tenant, namespace, bundle, topics, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of all the topics under a certain namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {'PERSISTENT' | 'NON_PERSISTENT' | 'ALL'} [mode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public getTopics(tenant: string, namespace: string, mode?: 'PERSISTENT' | 'NON_PERSISTENT' | 'ALL', options?: any) {
        return NamespacesApiFp(this.configuration).getTopics(tenant, namespace, mode, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Grant a new permission to a role on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} role 
     * @param {Array<string>} [body] List of permissions for the specified role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public grantPermissionOnNamespace(tenant: string, namespace: string, role: string, body?: Array<string>, options?: any) {
        return NamespacesApiFp(this.configuration).grantPermissionOnNamespace(tenant, namespace, role, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable or disable broker side deduplication for all topics in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {boolean} body Flag for disabling or enabling broker side deduplication for all topics in the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public modifyDeduplication(tenant: string, namespace: string, body: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).modifyDeduplication(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Message encryption is required or not for all topics in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {boolean} body Flag defining if message encryption is required
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public modifyEncryptionRequired(tenant: string, namespace: string, body: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).modifyEncryptionRequired(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove override of broker's allowAutoSubscriptionCreation in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeAutoSubscriptionCreation(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeAutoSubscriptionCreation(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove override of broker's allowAutoTopicCreation in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeAutoTopicCreation(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeAutoTopicCreation(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a backlog quota policy from a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any) {
        return NamespacesApiFp(this.configuration).removeBacklogQuota(tenant, namespace, backlogQuotaType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove broker side deduplication for all topics in a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeDeduplication(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeDeduplication(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete delayed delivery messages config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeDelayedDeliveryPolicies(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeDelayedDeliveryPolicies(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove inactive topic policies from a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeInactiveTopicPolicies(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeInactiveTopicPolicies(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set maxConsumersPerSubscription configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeMaxConsumersPerSubscription(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeMaxConsumersPerSubscription(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxConsumersPerTopic configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeMaxConsumersPerTopic(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeMaxConsumersPerTopic(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxProducersPerTopic configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeMaxProducersPerTopic(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeMaxProducersPerTopic(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxSubscriptionsPerTopic configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxUnackedMessagesPerConsumer config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeMaxUnackedmessagesPerConsumer(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeMaxUnackedmessagesPerConsumer(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxUnackedMessagesPerSubscription config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeMaxUnackedmessagesPerSubscription(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeMaxUnackedmessagesPerSubscription(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove anti-affinity group of a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceAntiAffinityGroup(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeNamespaceAntiAffinityGroup(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message TTL in seconds for namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceMessageTTL(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeNamespaceMessageTTL(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete resourcegroup for a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeNamespaceResourceGroup(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeNamespaceResourceGroup(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set offload configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeOffloadPolicies(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeOffloadPolicies(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get property value for a given key on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeProperty(tenant: string, namespace: string, key: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeProperty(tenant, namespace, key, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove replicator dispatch-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeReplicatorDispatchRate(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeReplicatorDispatchRate(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Remove retention configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {RetentionPolicies} [body] Retention policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeRetention(tenant: string, namespace: string, body?: RetentionPolicies, options?: any) {
        return NamespacesApiFp(this.configuration).removeRetention(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove subscription expiration time for namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeSubscriptionExpirationTime(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeSubscriptionExpirationTime(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Remove subscription types enabled on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public removeSubscriptionTypesEnabled(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).removeSubscriptionTypesEnabled(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Revoke all permissions to a role on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public revokePermissionsOnNamespace(tenant: string, namespace: string, role: string, options?: any) {
        return NamespacesApiFp(this.configuration).revokePermissionsOnNamespace(tenant, namespace, role, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public scanOffloadedLedgers(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).scanOffloadedLedgers(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Override broker's allowAutoSubscriptionCreation setting for a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {AutoSubscriptionCreationOverride} [body] Settings for automatic subscription creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setAutoSubscriptionCreation(tenant: string, namespace: string, body?: AutoSubscriptionCreationOverride, options?: any) {
        return NamespacesApiFp(this.configuration).setAutoSubscriptionCreation(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Override broker's allowAutoTopicCreation setting for a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {AutoTopicCreationOverride} body Settings for automatic topic creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setAutoTopicCreation(tenant: string, namespace: string, body: AutoTopicCreationOverride, options?: any) {
        return NamespacesApiFp(this.configuration).setAutoTopicCreation(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set a backlog quota for all the topics on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {BacklogQuota} [body] Backlog quota for all topics of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setBacklogQuota(tenant: string, namespace: string, backlogQuotaType?: 'destination_storage' | 'message_age', body?: BacklogQuota, options?: any) {
        return NamespacesApiFp(this.configuration).setBacklogQuota(tenant, namespace, backlogQuotaType, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the bookie-affinity-group to namespace-persistent policy.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {BookieAffinityGroupData} [body] Bookie affinity group for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setBookieAffinityGroup(tenant: string, namespace: string, body?: BookieAffinityGroupData, options?: any) {
        return NamespacesApiFp(this.configuration).setBookieAffinityGroup(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
     * @summary Set maximum number of uncompacted bytes in a topic before compaction is triggered.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Maximum number of uncompacted bytes in a topic of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setCompactionThreshold(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setCompactionThreshold(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set deduplicationSnapshotInterval config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Interval to take deduplication snapshot per topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setDeduplicationSnapshotInterval(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setDeduplicationSnapshotInterval(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set delayed delivery messages config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setDelayedDeliveryPolicies(tenant: string, namespace: string, body?: DelayedDeliveryPolicies, options?: any) {
        return NamespacesApiFp(this.configuration).setDelayedDeliveryPolicies(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set dispatch-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {DispatchRateImpl} [body] Dispatch rate for all topics of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any) {
        return NamespacesApiFp(this.configuration).setDispatchRate(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set inactive topic policies config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {InactiveTopicPolicies} [body] Inactive topic policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setInactiveTopicPolicies(tenant: string, namespace: string, body?: InactiveTopicPolicies, options?: any) {
        return NamespacesApiFp(this.configuration).setInactiveTopicPolicies(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxTopicsPerNamespace config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Number of maximum topics for specific namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setInactiveTopicPolicies_1(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setInactiveTopicPolicies_1(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxTopicsPerNamespace config on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setInactiveTopicPolicies_2(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).setInactiveTopicPolicies_2(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update flag of whether allow auto update schema
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {boolean} body Flag of whether to allow auto update schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setIsAllowAutoUpdateSchema(tenant: string, namespace: string, body: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).setIsAllowAutoUpdateSchema(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set maxConsumersPerSubscription configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Number of maximum consumers per subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setMaxConsumersPerSubscription(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setMaxConsumersPerSubscription(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set maxConsumersPerTopic configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Number of maximum consumers per topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setMaxConsumersPerTopic(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setMaxConsumersPerTopic(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set maxProducersPerTopic configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Number of maximum producers per topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setMaxProducersPerTopic(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setMaxProducersPerTopic(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set maxSubscriptionsPerTopic configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Number of maximum subscriptions per topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setMaxSubscriptionsPerTopic(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setMaxSubscriptionsPerTopic(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set maxConsumersPerTopic configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Number of maximum unacked messages per consumer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setMaxUnackedMessagesPerConsumer(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setMaxUnackedMessagesPerConsumer(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set maxUnackedMessagesPerSubscription configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Number of maximum unacked messages per subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setMaxUnackedMessagesPerSubscription(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setMaxUnackedMessagesPerSubscription(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set anti-affinity group for a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} body Anti-affinity group for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setNamespaceAntiAffinityGroup(tenant: string, namespace: string, body: string, options?: any) {
        return NamespacesApiFp(this.configuration).setNamespaceAntiAffinityGroup(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message TTL in seconds for namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body TTL in seconds for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setNamespaceMessageTTL(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setNamespaceMessageTTL(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the replication clusters for a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {Array<string>} body List of replication clusters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setNamespaceReplicationClusters(tenant: string, namespace: string, body: Array<string>, options?: any) {
        return NamespacesApiFp(this.configuration).setNamespaceReplicationClusters(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set resourcegroup for a namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} resourcegroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setNamespaceResourceGroup(tenant: string, namespace: string, resourcegroup: string, options?: any) {
        return NamespacesApiFp(this.configuration).setNamespaceResourceGroup(tenant, namespace, resourcegroup, options)(this.fetch, this.basePath);
    }

    /**
     * A negative value disables the deletion completely.
     * @summary Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body New number of milliseconds to wait before deleting a ledger segment which has been offloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setOffloadDeletionLag(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setOffloadDeletionLag(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set offload configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {OffloadPoliciesImpl} body Offload policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setOffloadPolicies(tenant: string, namespace: string, body: OffloadPoliciesImpl, options?: any) {
        return NamespacesApiFp(this.configuration).setOffloadPolicies(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * -1 will revert to using the cluster default. A negative value disables automatic offloading. 
     * @summary Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setOffloadThreshold(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setOffloadThreshold(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the persistence configuration for all the topics on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {PersistencePolicies} body Persistence policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setPersistence(tenant: string, namespace: string, body: PersistencePolicies, options?: any) {
        return NamespacesApiFp(this.configuration).setPersistence(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Put key value pairs property on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {any} body Key value pair properties for the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setProperties(tenant: string, namespace: string, body: any, options?: any) {
        return NamespacesApiFp(this.configuration).setProperties(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Put a key value pair property on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} key 
     * @param {string} value 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setProperty(tenant: string, namespace: string, key: string, value: string, options?: any) {
        return NamespacesApiFp(this.configuration).setProperty(tenant, namespace, key, value, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set replicator dispatch-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {DispatchRateImpl} [body] Replicator dispatch rate for all topics of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setReplicatorDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any) {
        return NamespacesApiFp(this.configuration).setReplicatorDispatchRate(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set retention configuration on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {RetentionPolicies} [body] Retention policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setRetention(tenant: string, namespace: string, body?: RetentionPolicies, options?: any) {
        return NamespacesApiFp(this.configuration).setRetention(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
     * @summary Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} [body] Strategy used to check the compatibility of new schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSchemaAutoUpdateCompatibilityStrategy(tenant: string, namespace: string, body?: string, options?: any) {
        return NamespacesApiFp(this.configuration).setSchemaAutoUpdateCompatibilityStrategy(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the strategy used to check the compatibility of new schema
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} [body] Strategy used to check the compatibility of new schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSchemaCompatibilityStrategy(tenant: string, namespace: string, body?: string, options?: any) {
        return NamespacesApiFp(this.configuration).setSchemaCompatibilityStrategy(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
     * @summary Set schema validation enforced flag on namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {boolean} body Flag of whether validation is enforced on the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSchemaValidationEnforced(tenant: string, namespace: string, body: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).setSchemaValidationEnforced(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set subscribe-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {SubscribeRate} [body] Subscribe rate for all topics of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSubscribeRate(tenant: string, namespace: string, body?: SubscribeRate, options?: any) {
        return NamespacesApiFp(this.configuration).setSubscribeRate(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary  Set a subscription auth mode for all the topics on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} [body] Subscription auth mode for all topics of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSubscriptionAuthMode(tenant: string, namespace: string, body?: string, options?: any) {
        return NamespacesApiFp(this.configuration).setSubscriptionAuthMode(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set Subscription dispatch-rate throttling for all topics of the namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {DispatchRateImpl} [body] Subscription dispatch rate for all topics of the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSubscriptionDispatchRate(tenant: string, namespace: string, body?: DispatchRateImpl, options?: any) {
        return NamespacesApiFp(this.configuration).setSubscriptionDispatchRate(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set subscription expiration time in minutes for namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {number} body Expiration time in minutes for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSubscriptionExpirationTime(tenant: string, namespace: string, body: number, options?: any) {
        return NamespacesApiFp(this.configuration).setSubscriptionExpirationTime(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update set of whether allow share sub type
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {Array<string>} body Set of whether allow subscription types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public setSubscriptionTypesEnabled(tenant: string, namespace: string, body: Array<string>, options?: any) {
        return NamespacesApiFp(this.configuration).setSubscriptionTypesEnabled(tenant, namespace, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Split a namespace bundle
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} bundle 
     * @param {boolean} [authoritative] 
     * @param {boolean} [unload] 
     * @param {string} [splitAlgorithmName] 
     * @param {Array<number>} [body] splitBoundaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public splitNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, unload?: boolean, splitAlgorithmName?: string, body?: Array<number>, options?: any) {
        return NamespacesApiFp(this.configuration).splitNamespaceBundle(tenant, namespace, bundle, authoritative, unload, splitAlgorithmName, body, options)(this.fetch, this.basePath);
    }

    /**
     * Unload an active namespace from the current broker serving it. Performing this operation will let the brokerremoves all producers, consumers, and connections using this namespace, and close all topics (includingtheir persistent store). During that operation, the namespace is marked as tentatively unavailable until thebroker completes the unloading action. This operation requires strictly super user privileges, since it wouldresult in non-persistent message loss and unexpected connection closure to the clients.
     * @summary Unload namespace
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public unloadNamespace(tenant: string, namespace: string, options?: any) {
        return NamespacesApiFp(this.configuration).unloadNamespace(tenant, namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unload a namespace bundle
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} bundle 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public unloadNamespaceBundle(tenant: string, namespace: string, bundle: string, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).unloadNamespaceBundle(tenant, namespace, bundle, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unsubscribes the given subscription on all topics on a namespace.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} subscription 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public unsubscribeNamespace(tenant: string, namespace: string, subscription: string, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).unsubscribeNamespace(tenant, namespace, subscription, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unsubscribes the given subscription on all topics on a namespace bundle.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} subscription 
     * @param {string} bundle 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespacesApi
     */
    public unsubscribeNamespaceBundle(tenant: string, namespace: string, subscription: string, bundle: string, authoritative?: boolean, options?: any) {
        return NamespacesApiFp(this.configuration).unsubscribeNamespaceBundle(tenant, namespace, subscription, bundle, authoritative, options)(this.fetch, this.basePath);
    }

}

/**
 * NonPersistentTopicApi - fetch parameter creator
 * @export
 */
export const NonPersistentTopicApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Trigger a compaction operation on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling compact.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling compact.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling compact.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/compaction`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of a compaction operation for a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling compactionStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling compactionStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling compactionStatus.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/compaction`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create missed partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMissedPartitions(tenant: string, namespace: string, topic: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createMissedPartitions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createMissedPartitions.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createMissedPartitions.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/createMissedPartitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the only REST endpoint from which non-partitioned topics could be created.
         * @summary Create a non-partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {any} [body] Key value pair properties for the topic metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createNonPartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createNonPartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createNonPartitionedTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It needs to be called before creating a producer on a partitioned topic.
         * @summary Create a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {PartitionedTopicMetadata} body The metadata for the topic
         * @param {boolean} [createLocalTopicOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createPartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createPartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createPartitionedTopic.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPartitionedTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createLocalTopicOnly !== undefined) {
                localVarQueryParameter['createLocalTopicOnly'] = createLocalTopicOnly;
            }

            localVarHeaderParameter['Content-Type'] = 'application/vnd.partitioned-topic-metadata+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PartitionedTopicMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription on the topic at the specified message id
         * @summary Create a subscription on the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subscriptionName Subscription to create position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
         * @param {boolean} [replicated] Is replicated required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createSubscription.');
            }
            // verify required parameter 'subscriptionName' is not null or undefined
            if (subscriptionName === null || subscriptionName === undefined) {
                throw new RequiredError('subscriptionName','Required parameter subscriptionName was null or undefined when calling createSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subscriptionName"}}`, encodeURIComponent(String(subscriptionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (replicated !== undefined) {
                localVarQueryParameter['replicated'] = replicated;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetCursorData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(messageId || {}) : (messageId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteDelayedDeliveryPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteDelayedDeliveryPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteInactiveTopicPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteInactiveTopicPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnConsumer.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It will also delete all the partitions of the topic if it exists.
         * @summary Delete a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deletePartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deletePartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deletePartitionedTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
         * @summary Delete a subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be deleted
         * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteSubscription.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling deleteSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
         * @summary Delete a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
         * @param {number} [messagePosition] The position of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling examineMessage.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling examineMessage.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling examineMessage.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/examinemessage`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (initialPosition !== undefined) {
                localVarQueryParameter['initialPosition'] = initialPosition;
            }

            if (messagePosition !== undefined) {
                localVarQueryParameter['messagePosition'] = messagePosition;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expiry messages on all subscriptions of topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            // verify required parameter 'expireTimeInSeconds' is not null or undefined
            if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
                throw new RequiredError('expireTimeInSeconds','Required parameter expireTimeInSeconds was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"expireTimeInSeconds"}}`, encodeURIComponent(String(expireTimeInSeconds)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling expireTopicMessages.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling expireTopicMessages.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling expireTopicMessages.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling expireTopicMessages.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetCursorData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(messageId || {}) : (messageId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'expireTimeInSeconds' is not null or undefined
            if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
                throw new RequiredError('expireTimeInSeconds','Required parameter expireTimeInSeconds was null or undefined when calling expireTopicMessages_1.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"expireTimeInSeconds"}}`, encodeURIComponent(String(expireTimeInSeconds)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get estimated backlog for offline topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBacklog.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBacklog.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getBacklog.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/backlog`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get backlog quota map on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBacklogQuotaMap.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBacklogQuotaMap.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getBacklogQuotaMap.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Calculate backlog size by a message ID (in bytes).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBacklogSizeByMessageId.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBacklogSizeByMessageId.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getBacklogSizeByMessageId.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/backlogSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getCompactionThreshold.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getCompactionThreshold.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deduplication configuration of a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDeduplication.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDeduplication.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getInactiveTopicPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getInactiveTopicPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the internal stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [metadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getInternalStats.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getInternalStats.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getInternalStats.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/internalStats`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the last commit message id of topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getLastMessageId.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getLastMessageId.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getLastMessageId.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/lastMessageId`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of non-persistent topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} [bundle] Specify the bundle name
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getList.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getList.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bundle !== undefined) {
                localVarQueryParameter['bundle'] = bundle;
            }

            if (includeSystemTopic !== undefined) {
                localVarQueryParameter['includeSystemTopic'] = includeSystemTopic;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of non-persistent topics under a namespace bundle.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} bundle Bundle range of a topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListFromBundle(tenant: string, namespace: string, bundle: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getListFromBundle.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getListFromBundle.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling getListFromBundle.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{bundle}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the stored topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getManagedLedgerInfo.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getManagedLedgerInfo.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getManagedLedgerInfo.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/internal-info`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxConsumers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxConsumers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxConsumers.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxMessageSize.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxMessageSize.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxMessageSize.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxProducers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxProducers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxProducers.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxProducers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnConsumer.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message by its messageId.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} ledgerId The ledger id
         * @param {number} entryId The entry id
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'ledgerId' is not null or undefined
            if (ledgerId === null || ledgerId === undefined) {
                throw new RequiredError('ledgerId','Required parameter ledgerId was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling getMessageById.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"ledgerId"}}`, encodeURIComponent(String(ledgerId)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message ID published at or just after this absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} timestamp Specify the timestamp
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMessageIdByTimestamp.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMessageIdByTimestamp.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMessageIdByTimestamp.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling getMessageIdByTimestamp.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/messageid/{timestamp}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMessageTTL.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMessageTTL.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getOffloadPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getOffloadPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get partitioned topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPartitionedMetadata.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPartitionedMetadata.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPartitionedMetadata.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (checkAllowAutoCreation !== undefined) {
                localVarQueryParameter['checkAllowAutoCreation'] = checkAllowAutoCreation;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the stats for the partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [perPartition] Get per partition stats
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPartitionedStats.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPartitionedStats.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPartitionedStats.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/partitioned-stats`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPartition !== undefined) {
                localVarQueryParameter['perPartition'] = perPartition;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (getPreciseBacklog !== undefined) {
                localVarQueryParameter['getPreciseBacklog'] = getPreciseBacklog;
            }

            if (subscriptionBacklogSize !== undefined) {
                localVarQueryParameter['subscriptionBacklogSize'] = subscriptionBacklogSize;
            }

            if (getEarliestTimeInBacklog !== undefined) {
                localVarQueryParameter['getEarliestTimeInBacklog'] = getEarliestTimeInBacklog;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of partitioned topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPartitionedTopicList.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPartitionedTopicList.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/partitioned`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeSystemTopic !== undefined) {
                localVarQueryParameter['includeSystemTopic'] = includeSystemTopic;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
         * @summary Get permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPermissionsOnTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPermissionsOnTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPermissionsOnTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/permissions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPersistence.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPersistence.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPublishRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPublishRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPublishRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/publishRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get replicated subscription status on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the replication clusters for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getReplicationClusters.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getReplicationClusters.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getReplicatorDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getReplicatorDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRetention.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getRetention.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the cluster
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get schema validation enforced flag for topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchemaValidationEnforced.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchemaValidationEnforced.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSchemaValidationEnforced.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getStats.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getStats.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getStats.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/stats`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (getPreciseBacklog !== undefined) {
                localVarQueryParameter['getPreciseBacklog'] = getPreciseBacklog;
            }

            if (subscriptionBacklogSize !== undefined) {
                localVarQueryParameter['subscriptionBacklogSize'] = subscriptionBacklogSize;
            }

            if (getEarliestTimeInBacklog !== undefined) {
                localVarQueryParameter['getEarliestTimeInBacklog'] = getEarliestTimeInBacklog;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscribeRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscribeRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptionDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get is enable sub type fors specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of persistent subscriptions for a given topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptions.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptions.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscriptions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant a new permission to a role on a single topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling grantPermissionsOnTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling grantPermissionsOnTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling grantPermissionsOnTopic.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling grantPermissionsOnTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling offloadStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling offloadStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling offloadStatus.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/offload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Peek nth message on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscribed message expired
         * @param {number} messagePosition The number of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'messagePosition' is not null or undefined
            if (messagePosition === null || messagePosition === undefined) {
                throw new RequiredError('messagePosition','Required parameter messagePosition was null or undefined when calling peekNthMessage.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"messagePosition"}}`, encodeURIComponent(String(messagePosition)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeBacklogQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeBacklogQuota.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeBacklogQuota.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/backlogQuota`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeCompactionThreshold.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeCompactionThreshold.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove deduplication configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeDeduplication.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeDeduplication.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxConsumers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxConsumers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxConsumers.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxMessageSize.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxMessageSize.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxMessageSize.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxProducers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxProducers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxProducers.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxProducers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMessageTTL.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMessageTTL.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeOffloadPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeOffloadPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removePersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removePersistence.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removePersistence.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removePublishRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removePublishRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removePublishRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/publishRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the replication clusters from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeReplicationClusters.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeReplicationClusters.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeReplicatorDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeReplicatorDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeRetention.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeRetention.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] 
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscribeRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscribeRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscribeRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscriptionDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove subscription types enabled for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {number} timestamp the timestamp to reset back
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling resetCursor.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to given position.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling resetCursorOnPosition.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling resetCursorOnPosition.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling resetCursorOnPosition.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling resetCursorOnPosition.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetCursorData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(messageId || {}) : (messageId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
         * @summary Revoke permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling revokePermissionsOnTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling revokePermissionsOnTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling revokePermissionsOnTopic.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling revokePermissionsOnTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a backlog quota for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setBacklogQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setBacklogQuota.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setBacklogQuota.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/backlogQuota`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setCompactionThreshold.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setCompactionThreshold.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set deduplication enabled on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDeduplication.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDeduplication.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} [body] Interval to take deduplication snapshot for the specified topic
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DelayedDeliveryPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setInactiveTopicPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setInactiveTopicPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InactiveTopicPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max consumers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxConsumers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxConsumers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxConsumers.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max message size of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxMessageSize.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxMessageSize.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxMessageSize.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] The max producers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxProducers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxProducers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxProducers.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxProducers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max subscriptions of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on consumer policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnConsumer.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on subscription policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnSubscription.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} messageTTL TTL in seconds for the specified namespace
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMessageTTL.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMessageTTL.');
            }
            // verify required parameter 'messageTTL' is not null or undefined
            if (messageTTL === null || messageTTL === undefined) {
                throw new RequiredError('messageTTL','Required parameter messageTTL was null or undefined when calling setMessageTTL.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (messageTTL !== undefined) {
                localVarQueryParameter['messageTTL'] = messageTTL;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setOffloadPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setOffloadPolicies.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OffloadPoliciesImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setPersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setPersistence.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setPersistence.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PersistencePolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {PublishRate} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setPublishRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setPublishRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setPublishRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/publishRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublishRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable or disable a replicated subscription on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} body Whether to enable replicated subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the replication clusters for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {Array<string>} body List of replication clusters
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setReplicationClusters.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setReplicationClusters.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setReplicationClusters.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setReplicatorDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setReplicatorDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setRetention.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setRetention.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetentionPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set schema validation enforced flag on topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} body 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setSchemaValidationEnforced.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscribeRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscribeRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscribeRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscriptionDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set is enable sub types for specified topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {Array<string>} [body] Enable sub types for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely clears the backlog on the subscription.
         * @summary Skip all messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling skipAllMessages.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling skipAllMessages.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling skipAllMessages.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling skipAllMessages.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Skipping messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {number} numMessages The number of messages to skip
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'numMessages' is not null or undefined
            if (numMessages === null || numMessages === undefined) {
                throw new RequiredError('numMessages','Required parameter numMessages was null or undefined when calling skipMessages.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"numMessages"}}`, encodeURIComponent(String(numMessages)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling terminate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling terminate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling terminate.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/terminate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling terminatePartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling terminatePartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling terminatePartitionedTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/terminate/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling triggerOffload.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling triggerOffload.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling triggerOffload.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/offload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * NonPersistentTopic does not support truncate.
         * @summary Truncate a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling truncateTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling truncateTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling truncateTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/truncate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unload a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling unloadTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling unloadTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling unloadTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/unload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It only increments partitions of existing non-global partitioned-topic
         * @summary Increment partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} body The number of partitions for the topic
         * @param {boolean} [updateLocalTopicOnly] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling updatePartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updatePartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling updatePartitionedTopic.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePartitionedTopic.');
            }
            const localVarPath = `/non-persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateLocalTopicOnly !== undefined) {
                localVarQueryParameter['updateLocalTopicOnly'] = updateLocalTopicOnly;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NonPersistentTopicApi - functional programming interface
 * @export
 */
export const NonPersistentTopicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Trigger a compaction operation on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).compact(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the status of a compaction operation for a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LongRunningProcessStatus> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).compactionStatus(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create missed partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMissedPartitions(tenant: string, namespace: string, topic: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).createMissedPartitions(tenant, namespace, topic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is the only REST endpoint from which non-partitioned topics could be created.
         * @summary Create a non-partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {any} [body] Key value pair properties for the topic metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).createNonPartitionedTopic(tenant, namespace, topic, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It needs to be called before creating a producer on a partitioned topic.
         * @summary Create a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {PartitionedTopicMetadata} body The metadata for the topic
         * @param {boolean} [createLocalTopicOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).createPartitionedTopic(tenant, namespace, topic, body, createLocalTopicOnly, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a subscription on the topic at the specified message id
         * @summary Create a subscription on the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subscriptionName Subscription to create position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
         * @param {boolean} [replicated] Is replicated required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).createSubscription(tenant, namespace, topic, subscriptionName, authoritative, messageId, replicated, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deleteDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deleteDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deleteInactiveTopicPolicies(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deleteMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deleteMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It will also delete all the partitions of the topic if it exists.
         * @summary Delete a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deletePartitionedTopic(tenant, namespace, topic, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
         * @summary Delete a subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be deleted
         * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deleteSubscription(tenant, namespace, topic, subName, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
         * @summary Delete a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).deleteTopic(tenant, namespace, topic, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
         * @param {number} [messagePosition] The position of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).examineMessage(tenant, namespace, topic, initialPosition, messagePosition, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Expiry messages on all subscriptions of topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).expireMessagesForAllSubscriptions(tenant, namespace, topic, expireTimeInSeconds, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).expireTopicMessages(tenant, namespace, topic, subName, authoritative, messageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).expireTopicMessages_1(tenant, namespace, topic, subName, expireTimeInSeconds, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get estimated backlog for offline topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersistentOfflineTopicStats> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getBacklog(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get backlog quota map on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getBacklogQuotaMap(tenant, namespace, topic, applied, authoritative, isGlobal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Calculate backlog size by a message ID (in bytes).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getBacklogSizeByMessageId(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getCompactionThreshold(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get deduplication configuration of a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getDeduplication(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getInactiveTopicPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the internal stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [metadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersistentTopicInternalStats> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getInternalStats(tenant, namespace, topic, authoritative, metadata, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return the last commit message id of topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getLastMessageId(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of non-persistent topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} [bundle] Specify the bundle name
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getList(tenant, namespace, bundle, includeSystemTopic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of non-persistent topics under a namespace bundle.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} bundle Bundle range of a topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListFromBundle(tenant: string, namespace: string, bundle: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getListFromBundle(tenant, namespace, bundle, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the stored topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getManagedLedgerInfo(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMaxConsumers(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMaxProducers(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMaxUnackedMessagesOnConsumer(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMaxUnackedMessagesOnSubscription(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message by its messageId.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} ledgerId The ledger id
         * @param {number} entryId The entry id
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMessageById(tenant, namespace, topic, ledgerId, entryId, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message ID published at or just after this absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} timestamp Specify the timestamp
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMessageIdByTimestamp(tenant, namespace, topic, timestamp, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getMessageTTL(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getOffloadPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get partitioned topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getPartitionedMetadata(tenant, namespace, topic, authoritative, checkAllowAutoCreation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the stats for the partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [perPartition] Get per partition stats
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getPartitionedStats(tenant, namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of partitioned topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getPartitionedTopicList(tenant, namespace, includeSystemTopic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
         * @summary Get permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getPermissionsOnTopic(tenant, namespace, topic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getPersistence(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getPublishRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get replicated subscription status on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getReplicatedSubscriptionStatus(tenant, namespace, topic, subName, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the replication clusters for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getReplicationClusters(tenant, namespace, topic, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getReplicatorDispatchRate(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getRetention(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the cluster
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getSchemaCompatibilityStrategy(tenant, namespace, topic, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get schema validation enforced flag for topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getSchemaValidationEnforced(tenant, namespace, topic, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getStats(tenant, namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getSubscribeRate(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getSubscriptionDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get is enable sub type fors specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of persistent subscriptions for a given topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).getSubscriptions(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Grant a new permission to a role on a single topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).grantPermissionsOnTopic(tenant, namespace, topic, role, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).offloadStatus(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Peek nth message on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscribed message expired
         * @param {number} messagePosition The number of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).peekNthMessage(tenant, namespace, topic, subName, messagePosition, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeBacklogQuota(tenant, namespace, topic, backlogQuotaType, authoritative, isGlobal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeCompactionThreshold(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove deduplication configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeDeduplication(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeMaxProducers(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeMessageTTL(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeOffloadPolicies(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removePersistence(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removePublishRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the replication clusters from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeReplicationClusters(tenant, namespace, topic, backlogQuotaType, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeRetention(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] 
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeSubscriptionDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove subscription types enabled for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).removeSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {number} timestamp the timestamp to reset back
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).resetCursor(tenant, namespace, topic, subName, timestamp, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to given position.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).resetCursorOnPosition(tenant, namespace, topic, subName, authoritative, messageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
         * @summary Revoke permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).revokePermissionsOnTopic(tenant, namespace, topic, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set a backlog quota for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setBacklogQuota(tenant, namespace, topic, authoritative, isGlobal, backlogQuotaType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setCompactionThreshold(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set deduplication enabled on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setDeduplication(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} [body] Interval to take deduplication snapshot for the specified topic
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setDeduplicationSnapshotInterval(tenant, namespace, topic, body, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setInactiveTopicPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max consumers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max message size of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] The max producers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMaxProducers(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max subscriptions of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on consumer policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on subscription policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} messageTTL TTL in seconds for the specified namespace
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setMessageTTL(tenant, namespace, topic, messageTTL, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setOffloadPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setPersistence(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {PublishRate} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setPublishRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable or disable a replicated subscription on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} body Whether to enable replicated subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setReplicatedSubscriptionStatus(tenant, namespace, topic, subName, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the replication clusters for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {Array<string>} body List of replication clusters
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setReplicationClusters(tenant, namespace, topic, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setRetention(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set schema validation enforced flag on topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} body 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setSchemaValidationEnforced(tenant, namespace, topic, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setSubscriptionDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set is enable sub types for specified topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {Array<string>} [body] Enable sub types for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).setSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Completely clears the backlog on the subscription.
         * @summary Skip all messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).skipAllMessages(tenant, namespace, topic, subName, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Skipping messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {number} numMessages The number of messages to skip
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).skipMessages(tenant, namespace, topic, subName, numMessages, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageId> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).terminate(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).terminatePartitionedTopic(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).triggerOffload(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * NonPersistentTopic does not support truncate.
         * @summary Truncate a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).truncateTopic(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unload a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).unloadTopic(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It only increments partitions of existing non-global partitioned-topic
         * @summary Increment partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} body The number of partitions for the topic
         * @param {boolean} [updateLocalTopicOnly] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NonPersistentTopicApiFetchParamCreator(configuration).updatePartitionedTopic(tenant, namespace, topic, body, updateLocalTopicOnly, authoritative, force, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NonPersistentTopicApi - factory interface
 * @export
 */
export const NonPersistentTopicApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Trigger a compaction operation on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).compact(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the status of a compaction operation for a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).compactionStatus(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create missed partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMissedPartitions(tenant: string, namespace: string, topic: string, options?: any) {
            return NonPersistentTopicApiFp(configuration).createMissedPartitions(tenant, namespace, topic, options)(fetch, basePath);
        },
        /**
         * This is the only REST endpoint from which non-partitioned topics could be created.
         * @summary Create a non-partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {any} [body] Key value pair properties for the topic metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options?: any) {
            return NonPersistentTopicApiFp(configuration).createNonPartitionedTopic(tenant, namespace, topic, authoritative, body, options)(fetch, basePath);
        },
        /**
         * It needs to be called before creating a producer on a partitioned topic.
         * @summary Create a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {PartitionedTopicMetadata} body The metadata for the topic
         * @param {boolean} [createLocalTopicOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).createPartitionedTopic(tenant, namespace, topic, body, createLocalTopicOnly, options)(fetch, basePath);
        },
        /**
         * Creates a subscription on the topic at the specified message id
         * @summary Create a subscription on the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subscriptionName Subscription to create position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
         * @param {boolean} [replicated] Is replicated required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).createSubscription(tenant, namespace, topic, subscriptionName, authoritative, messageId, replicated, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deleteDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deleteDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deleteInactiveTopicPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deleteMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deleteMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * It will also delete all the partitions of the topic if it exists.
         * @summary Delete a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deletePartitionedTopic(tenant, namespace, topic, force, authoritative, options)(fetch, basePath);
        },
        /**
         * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
         * @summary Delete a subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be deleted
         * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deleteSubscription(tenant, namespace, topic, subName, force, authoritative, options)(fetch, basePath);
        },
        /**
         * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
         * @summary Delete a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).deleteTopic(tenant, namespace, topic, force, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
         * @param {number} [messagePosition] The position of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).examineMessage(tenant, namespace, topic, initialPosition, messagePosition, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Expiry messages on all subscriptions of topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).expireMessagesForAllSubscriptions(tenant, namespace, topic, expireTimeInSeconds, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
            return NonPersistentTopicApiFp(configuration).expireTopicMessages(tenant, namespace, topic, subName, authoritative, messageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).expireTopicMessages_1(tenant, namespace, topic, subName, expireTimeInSeconds, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get estimated backlog for offline topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getBacklog(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get backlog quota map on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getBacklogQuotaMap(tenant, namespace, topic, applied, authoritative, isGlobal, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Calculate backlog size by a message ID (in bytes).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getBacklogSizeByMessageId(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getCompactionThreshold(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get deduplication configuration of a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getDeduplication(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getInactiveTopicPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the internal stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [metadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getInternalStats(tenant, namespace, topic, authoritative, metadata, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return the last commit message id of topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getLastMessageId(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of non-persistent topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} [bundle] Specify the bundle name
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getList(tenant, namespace, bundle, includeSystemTopic, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of non-persistent topics under a namespace bundle.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} bundle Bundle range of a topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListFromBundle(tenant: string, namespace: string, bundle: string, options?: any) {
            return NonPersistentTopicApiFp(configuration).getListFromBundle(tenant, namespace, bundle, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the stored topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getManagedLedgerInfo(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMaxConsumers(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMaxProducers(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMaxUnackedMessagesOnConsumer(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMaxUnackedMessagesOnSubscription(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message by its messageId.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} ledgerId The ledger id
         * @param {number} entryId The entry id
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMessageById(tenant, namespace, topic, ledgerId, entryId, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message ID published at or just after this absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} timestamp Specify the timestamp
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMessageIdByTimestamp(tenant, namespace, topic, timestamp, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getMessageTTL(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getOffloadPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get partitioned topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getPartitionedMetadata(tenant, namespace, topic, authoritative, checkAllowAutoCreation, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the stats for the partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [perPartition] Get per partition stats
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getPartitionedStats(tenant, namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of partitioned topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getPartitionedTopicList(tenant, namespace, includeSystemTopic, options)(fetch, basePath);
        },
        /**
         * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
         * @summary Get permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options?: any) {
            return NonPersistentTopicApiFp(configuration).getPermissionsOnTopic(tenant, namespace, topic, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getPersistence(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getPublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get replicated subscription status on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getReplicatedSubscriptionStatus(tenant, namespace, topic, subName, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the replication clusters for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getReplicationClusters(tenant, namespace, topic, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getReplicatorDispatchRate(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getRetention(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the cluster
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getSchemaCompatibilityStrategy(tenant, namespace, topic, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get schema validation enforced flag for topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getSchemaValidationEnforced(tenant, namespace, topic, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getStats(tenant, namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getSubscribeRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getSubscriptionDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get is enable sub type fors specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of persistent subscriptions for a given topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).getSubscriptions(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Grant a new permission to a role on a single topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options?: any) {
            return NonPersistentTopicApiFp(configuration).grantPermissionsOnTopic(tenant, namespace, topic, role, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).offloadStatus(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Peek nth message on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscribed message expired
         * @param {number} messagePosition The number of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).peekNthMessage(tenant, namespace, topic, subName, messagePosition, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeBacklogQuota(tenant, namespace, topic, backlogQuotaType, authoritative, isGlobal, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeCompactionThreshold(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove deduplication configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeDeduplication(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeMaxProducers(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeMessageTTL(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeOffloadPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removePersistence(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removePublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the replication clusters from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeReplicationClusters(tenant, namespace, topic, backlogQuotaType, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeRetention(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] 
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeSubscriptionDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove subscription types enabled for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).removeSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {number} timestamp the timestamp to reset back
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).resetCursor(tenant, namespace, topic, subName, timestamp, authoritative, options)(fetch, basePath);
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to given position.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
            return NonPersistentTopicApiFp(configuration).resetCursorOnPosition(tenant, namespace, topic, subName, authoritative, messageId, options)(fetch, basePath);
        },
        /**
         * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
         * @summary Revoke permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options?: any) {
            return NonPersistentTopicApiFp(configuration).revokePermissionsOnTopic(tenant, namespace, topic, role, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a backlog quota for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any) {
            return NonPersistentTopicApiFp(configuration).setBacklogQuota(tenant, namespace, topic, authoritative, isGlobal, backlogQuotaType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setCompactionThreshold(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set deduplication enabled on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).setDeduplication(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} [body] Interval to take deduplication snapshot for the specified topic
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).setDeduplicationSnapshotInterval(tenant, namespace, topic, body, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options?: any) {
            return NonPersistentTopicApiFp(configuration).setDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
            return NonPersistentTopicApiFp(configuration).setDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options?: any) {
            return NonPersistentTopicApiFp(configuration).setInactiveTopicPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max consumers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max message size of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] The max producers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMaxProducers(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max subscriptions of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on consumer policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on subscription policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} messageTTL TTL in seconds for the specified namespace
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).setMessageTTL(tenant, namespace, topic, messageTTL, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options?: any) {
            return NonPersistentTopicApiFp(configuration).setOffloadPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options?: any) {
            return NonPersistentTopicApiFp(configuration).setPersistence(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {PublishRate} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options?: any) {
            return NonPersistentTopicApiFp(configuration).setPublishRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable or disable a replicated subscription on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} body Whether to enable replicated subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).setReplicatedSubscriptionStatus(tenant, namespace, topic, subName, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the replication clusters for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {Array<string>} body List of replication clusters
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).setReplicationClusters(tenant, namespace, topic, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options?: any) {
            return NonPersistentTopicApiFp(configuration).setReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options?: any) {
            return NonPersistentTopicApiFp(configuration).setRetention(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
            return NonPersistentTopicApiFp(configuration).setSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set schema validation enforced flag on topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} body 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).setSchemaValidationEnforced(tenant, namespace, topic, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
            return NonPersistentTopicApiFp(configuration).setSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
            return NonPersistentTopicApiFp(configuration).setSubscriptionDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
            return NonPersistentTopicApiFp(configuration).setSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set is enable sub types for specified topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {Array<string>} [body] Enable sub types for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options?: any) {
            return NonPersistentTopicApiFp(configuration).setSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * Completely clears the backlog on the subscription.
         * @summary Skip all messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).skipAllMessages(tenant, namespace, topic, subName, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Skipping messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {number} numMessages The number of messages to skip
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).skipMessages(tenant, namespace, topic, subName, numMessages, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).terminate(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).terminatePartitionedTopic(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).triggerOffload(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * NonPersistentTopic does not support truncate.
         * @summary Truncate a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).truncateTopic(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unload a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).unloadTopic(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * It only increments partitions of existing non-global partitioned-topic
         * @summary Increment partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} body The number of partitions for the topic
         * @param {boolean} [updateLocalTopicOnly] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options?: any) {
            return NonPersistentTopicApiFp(configuration).updatePartitionedTopic(tenant, namespace, topic, body, updateLocalTopicOnly, authoritative, force, options)(fetch, basePath);
        },
    };
};

/**
 * NonPersistentTopicApi - object-oriented interface
 * @export
 * @class NonPersistentTopicApi
 * @extends {BaseAPI}
 */
export class NonPersistentTopicApi extends BaseAPI {
    /**
     * 
     * @summary Trigger a compaction operation on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).compact(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the status of a compaction operation for a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).compactionStatus(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create missed partitions of an existing partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public createMissedPartitions(tenant: string, namespace: string, topic: string, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).createMissedPartitions(tenant, namespace, topic, options)(this.fetch, this.basePath);
    }

    /**
     * This is the only REST endpoint from which non-partitioned topics could be created.
     * @summary Create a non-partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {any} [body] Key value pair properties for the topic metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).createNonPartitionedTopic(tenant, namespace, topic, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * It needs to be called before creating a producer on a partitioned topic.
     * @summary Create a partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {PartitionedTopicMetadata} body The metadata for the topic
     * @param {boolean} [createLocalTopicOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).createPartitionedTopic(tenant, namespace, topic, body, createLocalTopicOnly, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a subscription on the topic at the specified message id
     * @summary Create a subscription on the topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subscriptionName Subscription to create position on
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
     * @param {boolean} [replicated] Is replicated required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).createSubscription(tenant, namespace, topic, subscriptionName, authoritative, messageId, replicated, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete deduplicationSnapshotInterval config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deleteDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set delayed delivery messages config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deleteDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete inactive topic policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deleteInactiveTopicPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete max unacked messages per consumer config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deleteMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete max unacked messages per subscription config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deleteMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It will also delete all the partitions of the topic if it exists.
     * @summary Delete a partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deletePartitionedTopic(tenant, namespace, topic, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
     * @summary Delete a subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to be deleted
     * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deleteSubscription(tenant, namespace, topic, subName, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
     * @summary Delete a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).deleteTopic(tenant, namespace, topic, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
     * @param {number} [messagePosition] The position of messages (default 1)
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).examineMessage(tenant, namespace, topic, initialPosition, messagePosition, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Expiry messages on all subscriptions of topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).expireMessagesForAllSubscriptions(tenant, namespace, topic, expireTimeInSeconds, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Expiry messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to be Expiry messages on
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).expireTopicMessages(tenant, namespace, topic, subName, authoritative, messageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Expiry messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to be Expiry messages on
     * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).expireTopicMessages_1(tenant, namespace, topic, subName, expireTimeInSeconds, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get estimated backlog for offline topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getBacklog(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get backlog quota map on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getBacklogQuotaMap(tenant, namespace, topic, applied, authoritative, isGlobal, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Calculate backlog size by a message ID (in bytes).
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getBacklogSizeByMessageId(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get compaction threshold configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getCompactionThreshold(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get deduplication configuration of a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getDeduplication(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get deduplicationSnapshotInterval config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get delayed delivery messages config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get inactive topic policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getInactiveTopicPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the internal stats for the topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [metadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getInternalStats(tenant, namespace, topic, authoritative, metadata, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return the last commit message id of topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getLastMessageId(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of non-persistent topics under a namespace.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} [bundle] Specify the bundle name
     * @param {boolean} [includeSystemTopic] Include system topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getList(tenant, namespace, bundle, includeSystemTopic, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of non-persistent topics under a namespace bundle.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} bundle Bundle range of a topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getListFromBundle(tenant: string, namespace: string, bundle: string, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getListFromBundle(tenant, namespace, bundle, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the stored topic metadata.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getManagedLedgerInfo(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxConsumers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMaxConsumers(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get max consumers per subscription configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxMessageSize config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxProducers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMaxProducers(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxSubscriptionsPerTopic config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get max unacked messages per consumer config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMaxUnackedMessagesOnConsumer(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get max unacked messages per subscription config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMaxUnackedMessagesOnSubscription(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message by its messageId.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} ledgerId The ledger id
     * @param {number} entryId The entry id
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMessageById(tenant, namespace, topic, ledgerId, entryId, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message ID published at or just after this absolute timestamp (in ms).
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} timestamp Specify the timestamp
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMessageIdByTimestamp(tenant, namespace, topic, timestamp, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message TTL in seconds for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getMessageTTL(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get offload policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getOffloadPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get partitioned topic metadata.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getPartitionedMetadata(tenant, namespace, topic, authoritative, checkAllowAutoCreation, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the stats for the partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [perPartition] Get per partition stats
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
     * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
     * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getPartitionedStats(tenant, namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of partitioned topics under a namespace.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {boolean} [includeSystemTopic] Include system topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getPartitionedTopicList(tenant, namespace, includeSystemTopic, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
     * @summary Get permissions on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getPermissionsOnTopic(tenant, namespace, topic, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get configuration of persistence policies for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getPersistence(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get publish rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getPublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get replicated subscription status on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getReplicatedSubscriptionStatus(tenant, namespace, topic, subName, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the replication clusters for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getReplicationClusters(tenant, namespace, topic, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get replicatorDispatchRate config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getReplicatorDispatchRate(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get retention configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getRetention(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get schema compatibility strategy on a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the cluster
     * @param {string} topic Specify topic name
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getSchemaCompatibilityStrategy(tenant, namespace, topic, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get schema validation enforced flag for topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getSchemaValidationEnforced(tenant, namespace, topic, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the stats for the topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
     * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
     * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getStats(tenant, namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subscribe rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getSubscribeRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subscription message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getSubscriptionDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message dispatch rate configuration for specified subscription.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {string} subName 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get is enable sub type fors specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of persistent subscriptions for a given topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).getSubscriptions(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Grant a new permission to a role on a single topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} role Client role to which grant permissions
     * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).grantPermissionsOnTopic(tenant, namespace, topic, role, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Offload a prefix of a topic to long term storage
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).offloadStatus(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Peek nth message on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscribed message expired
     * @param {number} messagePosition The number of messages (default 1)
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).peekNthMessage(tenant, namespace, topic, subName, messagePosition, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a backlog quota policy from a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeBacklogQuota(tenant, namespace, topic, backlogQuotaType, authoritative, isGlobal, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove compaction threshold configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeCompactionThreshold(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove deduplication configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeDeduplication(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxConsumers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove max consumers per subscription configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxMessageSize config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxProducers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeMaxProducers(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxSubscriptionsPerTopic config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message TTL in seconds for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeMessageTTL(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete offload policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeOffloadPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove configuration of persistence policies for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removePersistence(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message publish rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removePublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the replication clusters from a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeReplicationClusters(tenant, namespace, topic, backlogQuotaType, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove replicatorDispatchRate config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove retention configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeRetention(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove schema compatibility strategy on a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {string} [body] Strategy used to check the compatibility of new schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove subscribe rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] 
     * @param {SubscribeRate} [body] Subscribe rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove subscription message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeSubscriptionDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message dispatch rate configuration for specified subscription.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {string} subName 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove subscription types enabled for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).removeSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It fence cursor and disconnects all active consumers before reseting cursor.
     * @summary Reset subscription to message position closest to absolute timestamp (in ms).
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to reset position on
     * @param {number} timestamp the timestamp to reset back
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).resetCursor(tenant, namespace, topic, subName, timestamp, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It fence cursor and disconnects all active consumers before reseting cursor.
     * @summary Reset subscription to message position closest to given position.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to reset position on
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).resetCursorOnPosition(tenant, namespace, topic, subName, authoritative, messageId, options)(this.fetch, this.basePath);
    }

    /**
     * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
     * @summary Revoke permissions on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} role Client role to which grant permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).revokePermissionsOnTopic(tenant, namespace, topic, role, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set a backlog quota for a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setBacklogQuota(tenant, namespace, topic, authoritative, isGlobal, backlogQuotaType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set compaction threshold configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {number} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setCompactionThreshold(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set deduplication enabled on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setDeduplication(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set deduplicationSnapshotInterval config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {number} [body] Interval to take deduplication snapshot for the specified topic
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setDeduplicationSnapshotInterval(tenant, namespace, topic, body, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set delayed delivery messages config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set inactive topic policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setInactiveTopicPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxConsumers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] The max consumers of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set max consumers per subscription configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxMessageSize config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] The max message size of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxProducers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {number} [body] The max producers of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMaxProducers(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxSubscriptionsPerTopic config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] The max subscriptions of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set max unacked messages per consumer config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] Max unacked messages on consumer policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set max unacked messages per subscription config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] Max unacked messages on subscription policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message TTL in seconds for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {number} messageTTL TTL in seconds for the specified namespace
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setMessageTTL(tenant, namespace, topic, messageTTL, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set offload policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setOffloadPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set configuration of persistence policies for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setPersistence(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message publish rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {PublishRate} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setPublishRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable or disable a replicated subscription on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {boolean} body Whether to enable replicated subscription
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setReplicatedSubscriptionStatus(tenant, namespace, topic, subName, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the replication clusters for a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {Array<string>} body List of replication clusters
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setReplicationClusters(tenant, namespace, topic, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set replicatorDispatchRate config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set retention configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {RetentionPolicies} [body] Retention policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setRetention(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set schema compatibility strategy on a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {string} [body] Strategy used to check the compatibility of new schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set schema validation enforced flag on topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} body 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setSchemaValidationEnforced(tenant, namespace, topic, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set subscribe rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {SubscribeRate} [body] Subscribe rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set subscription message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setSubscriptionDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message dispatch rate configuration for specified subscription.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {string} subName 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set is enable sub types for specified topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {Array<string>} [body] Enable sub types for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).setSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * Completely clears the backlog on the subscription.
     * @summary Skip all messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).skipAllMessages(tenant, namespace, topic, subName, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Skipping messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {number} numMessages The number of messages to skip
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).skipMessages(tenant, namespace, topic, subName, numMessages, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).terminate(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).terminatePartitionedTopic(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Offload a prefix of a topic to long term storage
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).triggerOffload(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * NonPersistentTopic does not support truncate.
     * @summary Truncate a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).truncateTopic(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unload a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).unloadTopic(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It only increments partitions of existing non-global partitioned-topic
     * @summary Increment partitions of an existing partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} body The number of partitions for the topic
     * @param {boolean} [updateLocalTopicOnly] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NonPersistentTopicApi
     */
    public updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options?: any) {
        return NonPersistentTopicApiFp(this.configuration).updatePartitionedTopic(tenant, namespace, topic, body, updateLocalTopicOnly, authoritative, force, options)(this.fetch, this.basePath);
    }

}

/**
 * PersistentTopicApi - fetch parameter creator
 * @export
 */
export const PersistentTopicApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Trigger a compaction operation on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling compact.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling compact.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling compact.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/compaction`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of a compaction operation for a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling compactionStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling compactionStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling compactionStatus.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/compaction`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create missed partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMissedPartitions(tenant: string, namespace: string, topic: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createMissedPartitions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createMissedPartitions.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createMissedPartitions.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/createMissedPartitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is the only REST endpoint from which non-partitioned topics could be created.
         * @summary Create a non-partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {any} [body] Key value pair properties for the topic metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createNonPartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createNonPartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createNonPartitionedTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It needs to be called before creating a producer on a partitioned topic.
         * @summary Create a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {PartitionedTopicMetadata} body The metadata for the topic
         * @param {boolean} [createLocalTopicOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createPartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createPartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createPartitionedTopic.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createPartitionedTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (createLocalTopicOnly !== undefined) {
                localVarQueryParameter['createLocalTopicOnly'] = createLocalTopicOnly;
            }

            localVarHeaderParameter['Content-Type'] = 'application/vnd.partitioned-topic-metadata+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PartitionedTopicMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription on the topic at the specified message id
         * @summary Create a subscription on the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subscriptionName Subscription to create position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
         * @param {boolean} [replicated] Is replicated required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling createSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling createSubscription.');
            }
            // verify required parameter 'subscriptionName' is not null or undefined
            if (subscriptionName === null || subscriptionName === undefined) {
                throw new RequiredError('subscriptionName','Required parameter subscriptionName was null or undefined when calling createSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subscriptionName"}}`, encodeURIComponent(String(subscriptionName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (replicated !== undefined) {
                localVarQueryParameter['replicated'] = replicated;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetCursorData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(messageId || {}) : (messageId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteDelayedDeliveryPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteDelayedDeliveryPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteInactiveTopicPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteInactiveTopicPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnConsumer.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It will also delete all the partitions of the topic if it exists.
         * @summary Delete a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deletePartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deletePartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deletePartitionedTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
         * @summary Delete a subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be deleted
         * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteSubscription.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling deleteSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
         * @summary Delete a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
         * @param {number} [messagePosition] The position of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling examineMessage.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling examineMessage.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling examineMessage.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/examinemessage`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (initialPosition !== undefined) {
                localVarQueryParameter['initialPosition'] = initialPosition;
            }

            if (messagePosition !== undefined) {
                localVarQueryParameter['messagePosition'] = messagePosition;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expiry messages on all subscriptions of topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            // verify required parameter 'expireTimeInSeconds' is not null or undefined
            if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
                throw new RequiredError('expireTimeInSeconds','Required parameter expireTimeInSeconds was null or undefined when calling expireMessagesForAllSubscriptions.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"expireTimeInSeconds"}}`, encodeURIComponent(String(expireTimeInSeconds)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling expireTopicMessages.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling expireTopicMessages.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling expireTopicMessages.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling expireTopicMessages.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetCursorData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(messageId || {}) : (messageId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling expireTopicMessages_1.');
            }
            // verify required parameter 'expireTimeInSeconds' is not null or undefined
            if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
                throw new RequiredError('expireTimeInSeconds','Required parameter expireTimeInSeconds was null or undefined when calling expireTopicMessages_1.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"expireTimeInSeconds"}}`, encodeURIComponent(String(expireTimeInSeconds)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get estimated backlog for offline topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBacklog.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBacklog.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getBacklog.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/backlog`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get backlog quota map on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBacklogQuotaMap.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBacklogQuotaMap.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getBacklogQuotaMap.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Calculate backlog size by a message ID (in bytes).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getBacklogSizeByMessageId.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getBacklogSizeByMessageId.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getBacklogSizeByMessageId.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/backlogSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getCompactionThreshold.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getCompactionThreshold.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deduplication configuration of a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDeduplication.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDeduplication.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDelayedDeliveryPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getInactiveTopicPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getInactiveTopicPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the internal stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [metadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getInternalStats.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getInternalStats.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getInternalStats.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/internalStats`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the last commit message id of topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getLastMessageId.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getLastMessageId.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getLastMessageId.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/lastMessageId`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} [bundle] Specify the bundle name
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getList.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getList.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bundle !== undefined) {
                localVarQueryParameter['bundle'] = bundle;
            }

            if (includeSystemTopic !== undefined) {
                localVarQueryParameter['includeSystemTopic'] = includeSystemTopic;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the stored topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getManagedLedgerInfo.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getManagedLedgerInfo.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getManagedLedgerInfo.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/internal-info`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxConsumers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxConsumers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxConsumers.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxConsumers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxConsumersPerSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxMessageSize.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxMessageSize.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxMessageSize.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxMessageSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxProducers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxProducers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxProducers.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxProducers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnConsumer.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message by its messageId.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} ledgerId The ledger id
         * @param {number} entryId The entry id
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'ledgerId' is not null or undefined
            if (ledgerId === null || ledgerId === undefined) {
                throw new RequiredError('ledgerId','Required parameter ledgerId was null or undefined when calling getMessageById.');
            }
            // verify required parameter 'entryId' is not null or undefined
            if (entryId === null || entryId === undefined) {
                throw new RequiredError('entryId','Required parameter entryId was null or undefined when calling getMessageById.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"ledgerId"}}`, encodeURIComponent(String(ledgerId)))
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message ID published at or just after this absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} timestamp Specify the timestamp
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMessageIdByTimestamp.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMessageIdByTimestamp.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMessageIdByTimestamp.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling getMessageIdByTimestamp.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/messageid/{timestamp}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getMessageTTL.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getMessageTTL.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getOffloadPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getOffloadPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get partitioned topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPartitionedMetadata.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPartitionedMetadata.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPartitionedMetadata.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (checkAllowAutoCreation !== undefined) {
                localVarQueryParameter['checkAllowAutoCreation'] = checkAllowAutoCreation;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the stats for the partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [perPartition] Get per partition stats
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPartitionedStats.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPartitionedStats.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPartitionedStats.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/partitioned-stats`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPartition !== undefined) {
                localVarQueryParameter['perPartition'] = perPartition;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (getPreciseBacklog !== undefined) {
                localVarQueryParameter['getPreciseBacklog'] = getPreciseBacklog;
            }

            if (subscriptionBacklogSize !== undefined) {
                localVarQueryParameter['subscriptionBacklogSize'] = subscriptionBacklogSize;
            }

            if (getEarliestTimeInBacklog !== undefined) {
                localVarQueryParameter['getEarliestTimeInBacklog'] = getEarliestTimeInBacklog;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of partitioned topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPartitionedTopicList.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPartitionedTopicList.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/partitioned`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeSystemTopic !== undefined) {
                localVarQueryParameter['includeSystemTopic'] = includeSystemTopic;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
         * @summary Get permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPermissionsOnTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPermissionsOnTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPermissionsOnTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/permissions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPersistence.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPersistence.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getPublishRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getPublishRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getPublishRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/publishRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get replicated subscription status on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling getReplicatedSubscriptionStatus.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the replication clusters for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getReplicationClusters.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getReplicationClusters.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getReplicatorDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getReplicatorDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getRetention.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getRetention.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the cluster
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get schema validation enforced flag for topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchemaValidationEnforced.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchemaValidationEnforced.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSchemaValidationEnforced.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getStats.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getStats.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getStats.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/stats`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (getPreciseBacklog !== undefined) {
                localVarQueryParameter['getPreciseBacklog'] = getPreciseBacklog;
            }

            if (subscriptionBacklogSize !== undefined) {
                localVarQueryParameter['subscriptionBacklogSize'] = subscriptionBacklogSize;
            }

            if (getEarliestTimeInBacklog !== undefined) {
                localVarQueryParameter['getEarliestTimeInBacklog'] = getEarliestTimeInBacklog;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscribeRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscribeRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptionDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling getSubscriptionLevelDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (applied !== undefined) {
                localVarQueryParameter['applied'] = applied;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get is enable sub type fors specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptionTypesEnabled.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of persistent subscriptions for a given topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSubscriptions.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSubscriptions.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSubscriptions.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscriptions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grant a new permission to a role on a single topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling grantPermissionsOnTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling grantPermissionsOnTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling grantPermissionsOnTopic.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling grantPermissionsOnTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/permissions/{role}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling offloadStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling offloadStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling offloadStatus.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/offload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Peek nth message on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscribed message expired
         * @param {number} messagePosition The number of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling peekNthMessage.');
            }
            // verify required parameter 'messagePosition' is not null or undefined
            if (messagePosition === null || messagePosition === undefined) {
                throw new RequiredError('messagePosition','Required parameter messagePosition was null or undefined when calling peekNthMessage.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"messagePosition"}}`, encodeURIComponent(String(messagePosition)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeBacklogQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeBacklogQuota.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeBacklogQuota.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/backlogQuota`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeCompactionThreshold.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeCompactionThreshold.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove deduplication configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeDeduplication.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeDeduplication.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxConsumers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxConsumers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxConsumers.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxConsumers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxConsumersPerSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxMessageSize.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxMessageSize.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxMessageSize.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxMessageSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxProducers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxProducers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxProducers.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxProducers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeMessageTTL.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeMessageTTL.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeOffloadPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeOffloadPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removePersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removePersistence.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removePersistence.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removePublishRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removePublishRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removePublishRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/publishRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the replication clusters from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeReplicationClusters.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeReplicationClusters.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeReplicatorDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeReplicatorDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeRetention.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeRetention.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] 
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscribeRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscribeRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscribeRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscriptionDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling removeSubscriptionLevelDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove subscription types enabled for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling removeSubscriptionTypesEnabled.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {number} timestamp the timestamp to reset back
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling resetCursor.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling resetCursor.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to given position.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling resetCursorOnPosition.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling resetCursorOnPosition.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling resetCursorOnPosition.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling resetCursorOnPosition.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetCursorData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(messageId || {}) : (messageId || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
         * @summary Revoke permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling revokePermissionsOnTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling revokePermissionsOnTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling revokePermissionsOnTopic.');
            }
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling revokePermissionsOnTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/permissions/{role}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a backlog quota for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setBacklogQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setBacklogQuota.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setBacklogQuota.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/backlogQuota`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (backlogQuotaType !== undefined) {
                localVarQueryParameter['backlogQuotaType'] = backlogQuotaType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setCompactionThreshold.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setCompactionThreshold.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setCompactionThreshold.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/compactionThreshold`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set deduplication enabled on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDeduplication.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDeduplication.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDeduplication.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} [body] Interval to take deduplication snapshot for the specified topic
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDeduplicationSnapshotInterval.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDelayedDeliveryPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/delayedDelivery`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DelayedDeliveryPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setInactiveTopicPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setInactiveTopicPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setInactiveTopicPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InactiveTopicPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max consumers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxConsumers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxConsumers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxConsumers.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxConsumers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxConsumersPerSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max message size of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxMessageSize.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxMessageSize.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxMessageSize.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxMessageSize`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] The max producers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxProducers.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxProducers.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxProducers.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxProducers`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max subscriptions of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxSubscriptionsPerTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on consumer policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnConsumer.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnConsumer.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on subscription policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnSubscription.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnSubscription.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} messageTTL TTL in seconds for the specified namespace
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setMessageTTL.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setMessageTTL.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setMessageTTL.');
            }
            // verify required parameter 'messageTTL' is not null or undefined
            if (messageTTL === null || messageTTL === undefined) {
                throw new RequiredError('messageTTL','Required parameter messageTTL was null or undefined when calling setMessageTTL.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/messageTTL`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (messageTTL !== undefined) {
                localVarQueryParameter['messageTTL'] = messageTTL;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setOffloadPolicies.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setOffloadPolicies.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setOffloadPolicies.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/offloadPolicies`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OffloadPoliciesImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setPersistence.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setPersistence.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setPersistence.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/persistence`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PersistencePolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {PublishRate} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setPublishRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setPublishRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setPublishRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/publishRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PublishRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enable or disable a replicated subscription on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} body Whether to enable replicated subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setReplicatedSubscriptionStatus.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the replication clusters for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {Array<string>} body List of replication clusters
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setReplicationClusters.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setReplicationClusters.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setReplicationClusters.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setReplicationClusters.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/replication`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setReplicatorDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setReplicatorDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setReplicatorDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setRetention.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setRetention.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setRetention.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/retention`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetentionPolicies" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSchemaCompatibilityStrategy.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set schema validation enforced flag on topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} body 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSchemaValidationEnforced.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setSchemaValidationEnforced.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"boolean" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscribeRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscribeRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscribeRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscribeRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubscribeRate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscriptionDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling setSubscriptionLevelDispatchRate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DispatchRateImpl" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set is enable sub types for specified topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {Array<string>} [body] Enable sub types for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling setSubscriptionTypesEnabled.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isGlobal !== undefined) {
                localVarQueryParameter['isGlobal'] = isGlobal;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completely clears the backlog on the subscription.
         * @summary Skip all messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling skipAllMessages.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling skipAllMessages.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling skipAllMessages.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling skipAllMessages.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Skipping messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {number} numMessages The number of messages to skip
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'subName' is not null or undefined
            if (subName === null || subName === undefined) {
                throw new RequiredError('subName','Required parameter subName was null or undefined when calling skipMessages.');
            }
            // verify required parameter 'numMessages' is not null or undefined
            if (numMessages === null || numMessages === undefined) {
                throw new RequiredError('numMessages','Required parameter numMessages was null or undefined when calling skipMessages.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"subName"}}`, encodeURIComponent(String(subName)))
                .replace(`{${"numMessages"}}`, encodeURIComponent(String(numMessages)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling terminate.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling terminate.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling terminate.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/terminate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling terminatePartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling terminatePartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling terminatePartitionedTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/terminate/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling triggerOffload.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling triggerOffload.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling triggerOffload.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/offload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The truncate operation will move all cursors to the end of the topic and delete all inactive ledgers.
         * @summary Truncate a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling truncateTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling truncateTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling truncateTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/truncate`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unload a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling unloadTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling unloadTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling unloadTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/unload`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It only increments partitions of existing non-global partitioned-topic
         * @summary Increment partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} body The number of partitions for the topic
         * @param {boolean} [updateLocalTopicOnly] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling updatePartitionedTopic.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling updatePartitionedTopic.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling updatePartitionedTopic.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updatePartitionedTopic.');
            }
            const localVarPath = `/persistent/{tenant}/{namespace}/{topic}/partitions`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (updateLocalTopicOnly !== undefined) {
                localVarQueryParameter['updateLocalTopicOnly'] = updateLocalTopicOnly;
            }

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"number" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersistentTopicApi - functional programming interface
 * @export
 */
export const PersistentTopicApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Trigger a compaction operation on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).compact(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the status of a compaction operation for a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LongRunningProcessStatus> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).compactionStatus(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create missed partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMissedPartitions(tenant: string, namespace: string, topic: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).createMissedPartitions(tenant, namespace, topic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is the only REST endpoint from which non-partitioned topics could be created.
         * @summary Create a non-partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {any} [body] Key value pair properties for the topic metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).createNonPartitionedTopic(tenant, namespace, topic, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It needs to be called before creating a producer on a partitioned topic.
         * @summary Create a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {PartitionedTopicMetadata} body The metadata for the topic
         * @param {boolean} [createLocalTopicOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).createPartitionedTopic(tenant, namespace, topic, body, createLocalTopicOnly, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a subscription on the topic at the specified message id
         * @summary Create a subscription on the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subscriptionName Subscription to create position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
         * @param {boolean} [replicated] Is replicated required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).createSubscription(tenant, namespace, topic, subscriptionName, authoritative, messageId, replicated, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deleteDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deleteDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deleteInactiveTopicPolicies(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deleteMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deleteMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It will also delete all the partitions of the topic if it exists.
         * @summary Delete a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deletePartitionedTopic(tenant, namespace, topic, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
         * @summary Delete a subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be deleted
         * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deleteSubscription(tenant, namespace, topic, subName, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
         * @summary Delete a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).deleteTopic(tenant, namespace, topic, force, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
         * @param {number} [messagePosition] The position of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).examineMessage(tenant, namespace, topic, initialPosition, messagePosition, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Expiry messages on all subscriptions of topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).expireMessagesForAllSubscriptions(tenant, namespace, topic, expireTimeInSeconds, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).expireTopicMessages(tenant, namespace, topic, subName, authoritative, messageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).expireTopicMessages_1(tenant, namespace, topic, subName, expireTimeInSeconds, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get estimated backlog for offline topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersistentOfflineTopicStats> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getBacklog(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get backlog quota map on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getBacklogQuotaMap(tenant, namespace, topic, applied, authoritative, isGlobal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Calculate backlog size by a message ID (in bytes).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getBacklogSizeByMessageId(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getCompactionThreshold(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get deduplication configuration of a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getDeduplication(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getInactiveTopicPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the internal stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [metadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PersistentTopicInternalStats> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getInternalStats(tenant, namespace, topic, authoritative, metadata, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Return the last commit message id of topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getLastMessageId(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} [bundle] Specify the bundle name
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getList(tenant, namespace, bundle, includeSystemTopic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the stored topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getManagedLedgerInfo(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMaxConsumers(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMaxProducers(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMaxUnackedMessagesOnConsumer(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMaxUnackedMessagesOnSubscription(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message by its messageId.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} ledgerId The ledger id
         * @param {number} entryId The entry id
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMessageById(tenant, namespace, topic, ledgerId, entryId, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message ID published at or just after this absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} timestamp Specify the timestamp
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMessageIdByTimestamp(tenant, namespace, topic, timestamp, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getMessageTTL(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getOffloadPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get partitioned topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getPartitionedMetadata(tenant, namespace, topic, authoritative, checkAllowAutoCreation, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the stats for the partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [perPartition] Get per partition stats
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getPartitionedStats(tenant, namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of partitioned topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getPartitionedTopicList(tenant, namespace, includeSystemTopic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
         * @summary Get permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getPermissionsOnTopic(tenant, namespace, topic, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getPersistence(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getPublishRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get replicated subscription status on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getReplicatedSubscriptionStatus(tenant, namespace, topic, subName, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the replication clusters for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getReplicationClusters(tenant, namespace, topic, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getReplicatorDispatchRate(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getRetention(tenant, namespace, topic, isGlobal, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the cluster
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getSchemaCompatibilityStrategy(tenant, namespace, topic, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get schema validation enforced flag for topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getSchemaValidationEnforced(tenant, namespace, topic, applied, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getStats(tenant, namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getSubscribeRate(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getSubscriptionDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, applied, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get is enable sub type fors specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of persistent subscriptions for a given topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).getSubscriptions(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Grant a new permission to a role on a single topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).grantPermissionsOnTopic(tenant, namespace, topic, role, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).offloadStatus(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Peek nth message on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscribed message expired
         * @param {number} messagePosition The number of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).peekNthMessage(tenant, namespace, topic, subName, messagePosition, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeBacklogQuota(tenant, namespace, topic, backlogQuotaType, authoritative, isGlobal, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeCompactionThreshold(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove deduplication configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeDeduplication(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeMaxProducers(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeMessageTTL(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeOffloadPolicies(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removePersistence(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removePublishRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove the replication clusters from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeReplicationClusters(tenant, namespace, topic, backlogQuotaType, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeRetention(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] 
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeSubscriptionDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove subscription types enabled for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).removeSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {number} timestamp the timestamp to reset back
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).resetCursor(tenant, namespace, topic, subName, timestamp, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to given position.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).resetCursorOnPosition(tenant, namespace, topic, subName, authoritative, messageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
         * @summary Revoke permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).revokePermissionsOnTopic(tenant, namespace, topic, role, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set a backlog quota for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setBacklogQuota(tenant, namespace, topic, authoritative, isGlobal, backlogQuotaType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setCompactionThreshold(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set deduplication enabled on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setDeduplication(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} [body] Interval to take deduplication snapshot for the specified topic
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setDeduplicationSnapshotInterval(tenant, namespace, topic, body, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setInactiveTopicPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max consumers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max message size of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] The max producers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMaxProducers(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max subscriptions of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on consumer policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on subscription policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} messageTTL TTL in seconds for the specified namespace
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setMessageTTL(tenant, namespace, topic, messageTTL, isGlobal, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setOffloadPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setPersistence(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {PublishRate} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setPublishRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enable or disable a replicated subscription on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} body Whether to enable replicated subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setReplicatedSubscriptionStatus(tenant, namespace, topic, subName, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the replication clusters for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {Array<string>} body List of replication clusters
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setReplicationClusters(tenant, namespace, topic, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setRetention(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set schema validation enforced flag on topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} body 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setSchemaValidationEnforced(tenant, namespace, topic, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setSubscriptionDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, authoritative, isGlobal, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set is enable sub types for specified topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {Array<string>} [body] Enable sub types for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).setSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Completely clears the backlog on the subscription.
         * @summary Skip all messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).skipAllMessages(tenant, namespace, topic, subName, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Skipping messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {number} numMessages The number of messages to skip
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).skipMessages(tenant, namespace, topic, subName, numMessages, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MessageId> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).terminate(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).terminatePartitionedTopic(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).triggerOffload(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The truncate operation will move all cursors to the end of the topic and delete all inactive ledgers.
         * @summary Truncate a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).truncateTopic(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Unload a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).unloadTopic(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * It only increments partitions of existing non-global partitioned-topic
         * @summary Increment partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} body The number of partitions for the topic
         * @param {boolean} [updateLocalTopicOnly] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PersistentTopicApiFetchParamCreator(configuration).updatePartitionedTopic(tenant, namespace, topic, body, updateLocalTopicOnly, authoritative, force, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PersistentTopicApi - factory interface
 * @export
 */
export const PersistentTopicApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Trigger a compaction operation on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).compact(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the status of a compaction operation for a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).compactionStatus(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create missed partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMissedPartitions(tenant: string, namespace: string, topic: string, options?: any) {
            return PersistentTopicApiFp(configuration).createMissedPartitions(tenant, namespace, topic, options)(fetch, basePath);
        },
        /**
         * This is the only REST endpoint from which non-partitioned topics could be created.
         * @summary Create a non-partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {any} [body] Key value pair properties for the topic metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options?: any) {
            return PersistentTopicApiFp(configuration).createNonPartitionedTopic(tenant, namespace, topic, authoritative, body, options)(fetch, basePath);
        },
        /**
         * It needs to be called before creating a producer on a partitioned topic.
         * @summary Create a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {PartitionedTopicMetadata} body The metadata for the topic
         * @param {boolean} [createLocalTopicOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).createPartitionedTopic(tenant, namespace, topic, body, createLocalTopicOnly, options)(fetch, basePath);
        },
        /**
         * Creates a subscription on the topic at the specified message id
         * @summary Create a subscription on the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subscriptionName Subscription to create position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
         * @param {boolean} [replicated] Is replicated required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).createSubscription(tenant, namespace, topic, subscriptionName, authoritative, messageId, replicated, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deleteDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deleteDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deleteInactiveTopicPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deleteMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deleteMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * It will also delete all the partitions of the topic if it exists.
         * @summary Delete a partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deletePartitionedTopic(tenant, namespace, topic, force, authoritative, options)(fetch, basePath);
        },
        /**
         * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
         * @summary Delete a subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be deleted
         * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deleteSubscription(tenant, namespace, topic, subName, force, authoritative, options)(fetch, basePath);
        },
        /**
         * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
         * @summary Delete a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).deleteTopic(tenant, namespace, topic, force, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
         * @param {number} [messagePosition] The position of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).examineMessage(tenant, namespace, topic, initialPosition, messagePosition, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Expiry messages on all subscriptions of topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).expireMessagesForAllSubscriptions(tenant, namespace, topic, expireTimeInSeconds, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
            return PersistentTopicApiFp(configuration).expireTopicMessages(tenant, namespace, topic, subName, authoritative, messageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Expiry messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to be Expiry messages on
         * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).expireTopicMessages_1(tenant, namespace, topic, subName, expireTimeInSeconds, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get estimated backlog for offline topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getBacklog(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get backlog quota map on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getBacklogQuotaMap(tenant, namespace, topic, applied, authoritative, isGlobal, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Calculate backlog size by a message ID (in bytes).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getBacklogSizeByMessageId(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getCompactionThreshold(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get deduplication configuration of a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getDeduplication(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getInactiveTopicPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the internal stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [metadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getInternalStats(tenant, namespace, topic, authoritative, metadata, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Return the last commit message id of topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getLastMessageId(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} [bundle] Specify the bundle name
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getList(tenant, namespace, bundle, includeSystemTopic, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the stored topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getManagedLedgerInfo(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMaxConsumers(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMaxProducers(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMaxUnackedMessagesOnConsumer(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMaxUnackedMessagesOnSubscription(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message by its messageId.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} ledgerId The ledger id
         * @param {number} entryId The entry id
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMessageById(tenant, namespace, topic, ledgerId, entryId, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message ID published at or just after this absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} timestamp Specify the timestamp
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMessageIdByTimestamp(tenant, namespace, topic, timestamp, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getMessageTTL(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getOffloadPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get partitioned topic metadata.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getPartitionedMetadata(tenant, namespace, topic, authoritative, checkAllowAutoCreation, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the stats for the partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [perPartition] Get per partition stats
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getPartitionedStats(tenant, namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of partitioned topics under a namespace.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {boolean} [includeSystemTopic] Include system topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getPartitionedTopicList(tenant, namespace, includeSystemTopic, options)(fetch, basePath);
        },
        /**
         * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
         * @summary Get permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options?: any) {
            return PersistentTopicApiFp(configuration).getPermissionsOnTopic(tenant, namespace, topic, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getPersistence(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getPublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get replicated subscription status on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getReplicatedSubscriptionStatus(tenant, namespace, topic, subName, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the replication clusters for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getReplicationClusters(tenant, namespace, topic, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getReplicatorDispatchRate(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getRetention(tenant, namespace, topic, isGlobal, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the cluster
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getSchemaCompatibilityStrategy(tenant, namespace, topic, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get schema validation enforced flag for topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [applied] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getSchemaValidationEnforced(tenant, namespace, topic, applied, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the stats for the topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
         * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
         * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getStats(tenant, namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getSubscribeRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getSubscriptionDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [applied] 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, applied, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get is enable sub type fors specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of persistent subscriptions for a given topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).getSubscriptions(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Grant a new permission to a role on a single topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options?: any) {
            return PersistentTopicApiFp(configuration).grantPermissionsOnTopic(tenant, namespace, topic, role, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).offloadStatus(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Peek nth message on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscribed message expired
         * @param {number} messagePosition The number of messages (default 1)
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).peekNthMessage(tenant, namespace, topic, subName, messagePosition, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove a backlog quota policy from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeBacklogQuota(tenant, namespace, topic, backlogQuotaType, authoritative, isGlobal, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeCompactionThreshold(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove deduplication configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeDeduplication(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeMaxProducers(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeMessageTTL(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeOffloadPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removePersistence(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removePublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the replication clusters from a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeReplicationClusters(tenant, namespace, topic, backlogQuotaType, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeRetention(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
            return PersistentTopicApiFp(configuration).removeSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] 
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
            return PersistentTopicApiFp(configuration).removeSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeSubscriptionDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove subscription types enabled for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).removeSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to absolute timestamp (in ms).
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {number} timestamp the timestamp to reset back
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).resetCursor(tenant, namespace, topic, subName, timestamp, authoritative, options)(fetch, basePath);
        },
        /**
         * It fence cursor and disconnects all active consumers before reseting cursor.
         * @summary Reset subscription to message position closest to given position.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Subscription to reset position on
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
            return PersistentTopicApiFp(configuration).resetCursorOnPosition(tenant, namespace, topic, subName, authoritative, messageId, options)(fetch, basePath);
        },
        /**
         * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
         * @summary Revoke permissions on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} role Client role to which grant permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options?: any) {
            return PersistentTopicApiFp(configuration).revokePermissionsOnTopic(tenant, namespace, topic, role, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set a backlog quota for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any) {
            return PersistentTopicApiFp(configuration).setBacklogQuota(tenant, namespace, topic, authoritative, isGlobal, backlogQuotaType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set compaction threshold configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setCompactionThreshold(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set deduplication enabled on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).setDeduplication(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set deduplicationSnapshotInterval config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} [body] Interval to take deduplication snapshot for the specified topic
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).setDeduplicationSnapshotInterval(tenant, namespace, topic, body, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set delayed delivery messages config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options?: any) {
            return PersistentTopicApiFp(configuration).setDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
            return PersistentTopicApiFp(configuration).setDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set inactive topic policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options?: any) {
            return PersistentTopicApiFp(configuration).setInactiveTopicPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxConsumers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max consumers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set max consumers per subscription configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxMessageSize config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max message size of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxProducers config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {number} [body] The max producers of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setMaxProducers(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set maxSubscriptionsPerTopic config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] The max subscriptions of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set max unacked messages per consumer config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on consumer policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set max unacked messages per subscription config on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {number} [body] Max unacked messages on subscription policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
            return PersistentTopicApiFp(configuration).setMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message TTL in seconds for a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {number} messageTTL TTL in seconds for the specified namespace
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).setMessageTTL(tenant, namespace, topic, messageTTL, isGlobal, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set offload policies on a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options?: any) {
            return PersistentTopicApiFp(configuration).setOffloadPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set configuration of persistence policies for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options?: any) {
            return PersistentTopicApiFp(configuration).setPersistence(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message publish rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {PublishRate} [body] Dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options?: any) {
            return PersistentTopicApiFp(configuration).setPublishRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enable or disable a replicated subscription on a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} body Whether to enable replicated subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).setReplicatedSubscriptionStatus(tenant, namespace, topic, subName, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the replication clusters for a topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {Array<string>} body List of replication clusters
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).setReplicationClusters(tenant, namespace, topic, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set replicatorDispatchRate config for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options?: any) {
            return PersistentTopicApiFp(configuration).setReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set retention configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {RetentionPolicies} [body] Retention policies for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options?: any) {
            return PersistentTopicApiFp(configuration).setRetention(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set schema compatibility strategy on a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {string} [body] Strategy used to check the compatibility of new schema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
            return PersistentTopicApiFp(configuration).setSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set schema validation enforced flag on topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} body 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).setSchemaValidationEnforced(tenant, namespace, topic, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set subscribe rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {SubscribeRate} [body] Subscribe rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
            return PersistentTopicApiFp(configuration).setSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set subscription message dispatch rate configuration for specified topic.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
            return PersistentTopicApiFp(configuration).setSubscriptionDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set message dispatch rate configuration for specified subscription.
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} subName 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [isGlobal] 
         * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
            return PersistentTopicApiFp(configuration).setSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, authoritative, isGlobal, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set is enable sub types for specified topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [isGlobal] Is authentication required to perform this operation
         * @param {boolean} [authoritative] 
         * @param {Array<string>} [body] Enable sub types for the specified topic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options?: any) {
            return PersistentTopicApiFp(configuration).setSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, body, options)(fetch, basePath);
        },
        /**
         * Completely clears the backlog on the subscription.
         * @summary Skip all messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).skipAllMessages(tenant, namespace, topic, subName, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Skipping messages on a topic subscription.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {string} subName Name of subscription
         * @param {number} numMessages The number of messages to skip
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).skipMessages(tenant, namespace, topic, subName, numMessages, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).terminate(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).terminatePartitionedTopic(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Offload a prefix of a topic to long term storage
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).triggerOffload(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * The truncate operation will move all cursors to the end of the topic and delete all inactive ledgers.
         * @summary Truncate a topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).truncateTopic(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Unload a topic
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).unloadTopic(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * It only increments partitions of existing non-global partitioned-topic
         * @summary Increment partitions of an existing partitioned topic.
         * @param {string} tenant Specify the tenant
         * @param {string} namespace Specify the namespace
         * @param {string} topic Specify topic name
         * @param {number} body The number of partitions for the topic
         * @param {boolean} [updateLocalTopicOnly] 
         * @param {boolean} [authoritative] Is authentication required to perform this operation
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options?: any) {
            return PersistentTopicApiFp(configuration).updatePartitionedTopic(tenant, namespace, topic, body, updateLocalTopicOnly, authoritative, force, options)(fetch, basePath);
        },
    };
};

/**
 * PersistentTopicApi - object-oriented interface
 * @export
 * @class PersistentTopicApi
 * @extends {BaseAPI}
 */
export class PersistentTopicApi extends BaseAPI {
    /**
     * 
     * @summary Trigger a compaction operation on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public compact(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).compact(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the status of a compaction operation for a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public compactionStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).compactionStatus(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create missed partitions of an existing partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public createMissedPartitions(tenant: string, namespace: string, topic: string, options?: any) {
        return PersistentTopicApiFp(this.configuration).createMissedPartitions(tenant, namespace, topic, options)(this.fetch, this.basePath);
    }

    /**
     * This is the only REST endpoint from which non-partitioned topics could be created.
     * @summary Create a non-partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {any} [body] Key value pair properties for the topic metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public createNonPartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: any, options?: any) {
        return PersistentTopicApiFp(this.configuration).createNonPartitionedTopic(tenant, namespace, topic, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * It needs to be called before creating a producer on a partitioned topic.
     * @summary Create a partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {PartitionedTopicMetadata} body The metadata for the topic
     * @param {boolean} [createLocalTopicOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public createPartitionedTopic(tenant: string, namespace: string, topic: string, body: PartitionedTopicMetadata, createLocalTopicOnly?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).createPartitionedTopic(tenant, namespace, topic, body, createLocalTopicOnly, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a subscription on the topic at the specified message id
     * @summary Create a subscription on the topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subscriptionName Subscription to create position on
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {ResetCursorData} [messageId] messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
     * @param {boolean} [replicated] Is replicated required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public createSubscription(tenant: string, namespace: string, topic: string, subscriptionName: string, authoritative?: boolean, messageId?: ResetCursorData, replicated?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).createSubscription(tenant, namespace, topic, subscriptionName, authoritative, messageId, replicated, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete deduplicationSnapshotInterval config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deleteDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deleteDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set delayed delivery messages config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deleteDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deleteDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete inactive topic policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deleteInactiveTopicPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deleteInactiveTopicPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete max unacked messages per consumer config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deleteMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deleteMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete max unacked messages per subscription config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deleteMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deleteMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It will also delete all the partitions of the topic if it exists.
     * @summary Delete a partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deletePartitionedTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deletePartitionedTopic(tenant, namespace, topic, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
     * @summary Delete a subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to be deleted
     * @param {boolean} [force] Disconnect and close all consumers and delete subscription forcefully
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deleteSubscription(tenant: string, namespace: string, topic: string, subName: string, force?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deleteSubscription(tenant, namespace, topic, subName, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
     * @summary Delete a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [force] Stop all producer/consumer/replicator and delete topic forcefully
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public deleteTopic(tenant: string, namespace: string, topic: string, force?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).deleteTopic(tenant, namespace, topic, force, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {'latest' | 'earliest'} [initialPosition] Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
     * @param {number} [messagePosition] The position of messages (default 1)
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public examineMessage(tenant: string, namespace: string, topic: string, initialPosition?: 'latest' | 'earliest', messagePosition?: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).examineMessage(tenant, namespace, topic, initialPosition, messagePosition, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Expiry messages on all subscriptions of topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public expireMessagesForAllSubscriptions(tenant: string, namespace: string, topic: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).expireMessagesForAllSubscriptions(tenant, namespace, topic, expireTimeInSeconds, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Expiry messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to be Expiry messages on
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public expireTopicMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
        return PersistentTopicApiFp(this.configuration).expireTopicMessages(tenant, namespace, topic, subName, authoritative, messageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Expiry messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to be Expiry messages on
     * @param {number} expireTimeInSeconds Expires beyond the specified number of seconds
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public expireTopicMessages_1(tenant: string, namespace: string, topic: string, subName: string, expireTimeInSeconds: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).expireTopicMessages_1(tenant, namespace, topic, subName, expireTimeInSeconds, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get estimated backlog for offline topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getBacklog(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getBacklog(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get backlog quota map on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getBacklogQuotaMap(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, isGlobal?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getBacklogQuotaMap(tenant, namespace, topic, applied, authoritative, isGlobal, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Calculate backlog size by a message ID (in bytes).
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getBacklogSizeByMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getBacklogSizeByMessageId(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get compaction threshold configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getCompactionThreshold(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getCompactionThreshold(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get deduplication configuration of a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getDeduplication(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getDeduplication(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get deduplicationSnapshotInterval config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getDeduplicationSnapshotInterval(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get delayed delivery messages config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get inactive topic policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getInactiveTopicPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getInactiveTopicPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the internal stats for the topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [metadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getInternalStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, metadata?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getInternalStats(tenant, namespace, topic, authoritative, metadata, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Return the last commit message id of topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getLastMessageId(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getLastMessageId(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of topics under a namespace.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} [bundle] Specify the bundle name
     * @param {boolean} [includeSystemTopic] Include system topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getList(tenant: string, namespace: string, bundle?: string, includeSystemTopic?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getList(tenant, namespace, bundle, includeSystemTopic, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the stored topic metadata.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getManagedLedgerInfo(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getManagedLedgerInfo(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxConsumers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMaxConsumers(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get max consumers per subscription configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxMessageSize config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxProducers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMaxProducers(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMaxProducers(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get maxSubscriptionsPerTopic config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get max unacked messages per consumer config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMaxUnackedMessagesOnConsumer(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get max unacked messages per subscription config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMaxUnackedMessagesOnSubscription(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message by its messageId.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} ledgerId The ledger id
     * @param {number} entryId The entry id
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMessageById(tenant: string, namespace: string, topic: string, ledgerId: number, entryId: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMessageById(tenant, namespace, topic, ledgerId, entryId, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message ID published at or just after this absolute timestamp (in ms).
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} timestamp Specify the timestamp
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMessageIdByTimestamp(tenant: string, namespace: string, topic: string, timestamp: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMessageIdByTimestamp(tenant, namespace, topic, timestamp, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message TTL in seconds for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getMessageTTL(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getMessageTTL(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get offload policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getOffloadPolicies(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getOffloadPolicies(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get partitioned topic metadata.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [checkAllowAutoCreation] Is check configuration required to automatically create topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getPartitionedMetadata(tenant: string, namespace: string, topic: string, authoritative?: boolean, checkAllowAutoCreation?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getPartitionedMetadata(tenant, namespace, topic, authoritative, checkAllowAutoCreation, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the stats for the partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [perPartition] Get per partition stats
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
     * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
     * @param {boolean} [getEarliestTimeInBacklog] If return the earliest time in backlog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getPartitionedStats(tenant: string, namespace: string, topic: string, perPartition?: boolean, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getPartitionedStats(tenant, namespace, topic, perPartition, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of partitioned topics under a namespace.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {boolean} [includeSystemTopic] Include system topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getPartitionedTopicList(tenant: string, namespace: string, includeSystemTopic?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getPartitionedTopicList(tenant, namespace, includeSystemTopic, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
     * @summary Get permissions on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getPermissionsOnTopic(tenant: string, namespace: string, topic: string, options?: any) {
        return PersistentTopicApiFp(this.configuration).getPermissionsOnTopic(tenant, namespace, topic, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get configuration of persistence policies for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getPersistence(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getPersistence(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get publish rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getPublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get replicated subscription status on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getReplicatedSubscriptionStatus(tenant, namespace, topic, subName, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the replication clusters for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getReplicationClusters(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getReplicationClusters(tenant, namespace, topic, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get replicatorDispatchRate config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getReplicatorDispatchRate(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get retention configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, applied?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getRetention(tenant, namespace, topic, isGlobal, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get schema compatibility strategy on a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the cluster
     * @param {string} topic Specify topic name
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getSchemaCompatibilityStrategy(tenant, namespace, topic, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get schema validation enforced flag for topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [applied] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getSchemaValidationEnforced(tenant: string, namespace: string, topic: string, applied?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getSchemaValidationEnforced(tenant, namespace, topic, applied, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the stats for the topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [getPreciseBacklog] If return precise backlog or imprecise backlog
     * @param {boolean} [subscriptionBacklogSize] If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
     * @param {boolean} [getEarliestTimeInBacklog] If return time of the earliest message in backlog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getStats(tenant: string, namespace: string, topic: string, authoritative?: boolean, getPreciseBacklog?: boolean, subscriptionBacklogSize?: boolean, getEarliestTimeInBacklog?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getStats(tenant, namespace, topic, authoritative, getPreciseBacklog, subscriptionBacklogSize, getEarliestTimeInBacklog, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subscribe rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getSubscribeRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getSubscribeRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subscription message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getSubscriptionDispatchRate(tenant, namespace, topic, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get message dispatch rate configuration for specified subscription.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {string} subName 
     * @param {boolean} [applied] 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, applied?: boolean, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, applied, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get is enable sub type fors specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of persistent subscriptions for a given topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public getSubscriptions(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).getSubscriptions(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Grant a new permission to a role on a single topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} role Client role to which grant permissions
     * @param {Array<string>} [body] Actions to be granted (produce,functions,consume)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public grantPermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, body?: Array<string>, options?: any) {
        return PersistentTopicApiFp(this.configuration).grantPermissionsOnTopic(tenant, namespace, topic, role, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Offload a prefix of a topic to long term storage
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public offloadStatus(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).offloadStatus(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Peek nth message on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscribed message expired
     * @param {number} messagePosition The number of messages (default 1)
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public peekNthMessage(tenant: string, namespace: string, topic: string, subName: string, messagePosition: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).peekNthMessage(tenant, namespace, topic, subName, messagePosition, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove a backlog quota policy from a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeBacklogQuota(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, isGlobal?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeBacklogQuota(tenant, namespace, topic, backlogQuotaType, authoritative, isGlobal, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove compaction threshold configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeCompactionThreshold(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeCompactionThreshold(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove deduplication configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeDeduplication(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxConsumers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove max consumers per subscription configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxMessageSize config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxProducers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeMaxProducers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeMaxProducers(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove maxSubscriptionsPerTopic config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message TTL in seconds for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeMessageTTL(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeMessageTTL(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete offload policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeOffloadPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeOffloadPolicies(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove configuration of persistence policies for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removePersistence(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removePersistence(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message publish rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removePublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removePublishRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove the replication clusters from a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeReplicationClusters(tenant: string, namespace: string, topic: string, backlogQuotaType?: 'destination_storage' | 'message_age', authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeReplicationClusters(tenant, namespace, topic, backlogQuotaType, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove replicatorDispatchRate config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove retention configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeRetention(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeRetention(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove schema compatibility strategy on a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {string} [body] Strategy used to check the compatibility of new schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove subscribe rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] 
     * @param {SubscribeRate} [body] Subscribe rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove subscription message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeSubscriptionDispatchRate(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove message dispatch rate configuration for specified subscription.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {string} subName 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove subscription types enabled for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public removeSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).removeSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It fence cursor and disconnects all active consumers before reseting cursor.
     * @summary Reset subscription to message position closest to absolute timestamp (in ms).
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to reset position on
     * @param {number} timestamp the timestamp to reset back
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public resetCursor(tenant: string, namespace: string, topic: string, subName: string, timestamp: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).resetCursor(tenant, namespace, topic, subName, timestamp, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It fence cursor and disconnects all active consumers before reseting cursor.
     * @summary Reset subscription to message position closest to given position.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Subscription to reset position on
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {ResetCursorData} [messageId] messageId to reset back to (ledgerId:entryId)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public resetCursorOnPosition(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, messageId?: ResetCursorData, options?: any) {
        return PersistentTopicApiFp(this.configuration).resetCursorOnPosition(tenant, namespace, topic, subName, authoritative, messageId, options)(this.fetch, this.basePath);
    }

    /**
     * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
     * @summary Revoke permissions on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} role Client role to which grant permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public revokePermissionsOnTopic(tenant: string, namespace: string, topic: string, role: string, options?: any) {
        return PersistentTopicApiFp(this.configuration).revokePermissionsOnTopic(tenant, namespace, topic, role, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set a backlog quota for a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {'destination_storage' | 'message_age'} [backlogQuotaType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setBacklogQuota(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, backlogQuotaType?: 'destination_storage' | 'message_age', options?: any) {
        return PersistentTopicApiFp(this.configuration).setBacklogQuota(tenant, namespace, topic, authoritative, isGlobal, backlogQuotaType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set compaction threshold configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {number} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setCompactionThreshold(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setCompactionThreshold(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set deduplication enabled on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {boolean} [body] DeduplicationEnabled policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setDeduplication(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).setDeduplication(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set deduplicationSnapshotInterval config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {number} [body] Interval to take deduplication snapshot for the specified topic
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setDeduplicationSnapshotInterval(tenant: string, namespace: string, topic: string, body?: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).setDeduplicationSnapshotInterval(tenant, namespace, topic, body, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set delayed delivery messages config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {DelayedDeliveryPolicies} [body] Delayed delivery policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setDelayedDeliveryPolicies(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DelayedDeliveryPolicies, options?: any) {
        return PersistentTopicApiFp(this.configuration).setDelayedDeliveryPolicies(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {DispatchRateImpl} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
        return PersistentTopicApiFp(this.configuration).setDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set inactive topic policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {InactiveTopicPolicies} [body] inactive topic policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setInactiveTopicPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: InactiveTopicPolicies, options?: any) {
        return PersistentTopicApiFp(this.configuration).setInactiveTopicPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxConsumers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] The max consumers of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMaxConsumers(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMaxConsumers(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set max consumers per subscription configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMaxConsumersPerSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMaxConsumersPerSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxMessageSize config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] The max message size of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMaxMessageSize(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMaxMessageSize(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxProducers config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {number} [body] The max producers of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMaxProducers(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMaxProducers(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set maxSubscriptionsPerTopic config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] The max subscriptions of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMaxSubscriptionsPerTopic(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMaxSubscriptionsPerTopic(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set max unacked messages per consumer config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] Max unacked messages on consumer policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMaxUnackedMessagesOnConsumer(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMaxUnackedMessagesOnConsumer(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set max unacked messages per subscription config on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {number} [body] Max unacked messages on subscription policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMaxUnackedMessagesOnSubscription(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: number, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMaxUnackedMessagesOnSubscription(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message TTL in seconds for a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {number} messageTTL TTL in seconds for the specified namespace
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setMessageTTL(tenant: string, namespace: string, topic: string, messageTTL: number, isGlobal?: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).setMessageTTL(tenant, namespace, topic, messageTTL, isGlobal, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set offload policies on a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {OffloadPoliciesImpl} [body] Offload policies for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setOffloadPolicies(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: OffloadPoliciesImpl, options?: any) {
        return PersistentTopicApiFp(this.configuration).setOffloadPolicies(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set configuration of persistence policies for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {PersistencePolicies} [body] Bookkeeper persistence policies for specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setPersistence(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: PersistencePolicies, options?: any) {
        return PersistentTopicApiFp(this.configuration).setPersistence(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message publish rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {PublishRate} [body] Dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setPublishRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: PublishRate, options?: any) {
        return PersistentTopicApiFp(this.configuration).setPublishRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enable or disable a replicated subscription on a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {boolean} body Whether to enable replicated subscription
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setReplicatedSubscriptionStatus(tenant: string, namespace: string, topic: string, subName: string, body: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).setReplicatedSubscriptionStatus(tenant, namespace, topic, subName, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the replication clusters for a topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {Array<string>} body List of replication clusters
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setReplicationClusters(tenant: string, namespace: string, topic: string, body: Array<string>, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).setReplicationClusters(tenant, namespace, topic, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set replicatorDispatchRate config for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {DispatchRateImpl} [body] Replicator dispatch rate of the topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setReplicatorDispatchRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: DispatchRateImpl, options?: any) {
        return PersistentTopicApiFp(this.configuration).setReplicatorDispatchRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set retention configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {RetentionPolicies} [body] Retention policies for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setRetention(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: RetentionPolicies, options?: any) {
        return PersistentTopicApiFp(this.configuration).setRetention(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set schema compatibility strategy on a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {string} [body] Strategy used to check the compatibility of new schema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setSchemaCompatibilityStrategy(tenant: string, namespace: string, topic: string, authoritative?: boolean, body?: string, options?: any) {
        return PersistentTopicApiFp(this.configuration).setSchemaCompatibilityStrategy(tenant, namespace, topic, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set schema validation enforced flag on topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} body 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setSchemaValidationEnforced(tenant: string, namespace: string, topic: string, body: boolean, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).setSchemaValidationEnforced(tenant, namespace, topic, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set subscribe rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {SubscribeRate} [body] Subscribe rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setSubscribeRate(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: SubscribeRate, options?: any) {
        return PersistentTopicApiFp(this.configuration).setSubscribeRate(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set subscription message dispatch rate configuration for specified topic.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setSubscriptionDispatchRate(tenant: string, namespace: string, topic: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
        return PersistentTopicApiFp(this.configuration).setSubscriptionDispatchRate(tenant, namespace, topic, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set message dispatch rate configuration for specified subscription.
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {string} subName 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [isGlobal] 
     * @param {DispatchRateImpl} [body] Subscription message dispatch rate for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setSubscriptionLevelDispatchRate(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, isGlobal?: boolean, body?: DispatchRateImpl, options?: any) {
        return PersistentTopicApiFp(this.configuration).setSubscriptionLevelDispatchRate(tenant, namespace, topic, subName, authoritative, isGlobal, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set is enable sub types for specified topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [isGlobal] Is authentication required to perform this operation
     * @param {boolean} [authoritative] 
     * @param {Array<string>} [body] Enable sub types for the specified topic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public setSubscriptionTypesEnabled(tenant: string, namespace: string, topic: string, isGlobal?: boolean, authoritative?: boolean, body?: Array<string>, options?: any) {
        return PersistentTopicApiFp(this.configuration).setSubscriptionTypesEnabled(tenant, namespace, topic, isGlobal, authoritative, body, options)(this.fetch, this.basePath);
    }

    /**
     * Completely clears the backlog on the subscription.
     * @summary Skip all messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public skipAllMessages(tenant: string, namespace: string, topic: string, subName: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).skipAllMessages(tenant, namespace, topic, subName, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Skipping messages on a topic subscription.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {string} subName Name of subscription
     * @param {number} numMessages The number of messages to skip
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public skipMessages(tenant: string, namespace: string, topic: string, subName: string, numMessages: number, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).skipMessages(tenant, namespace, topic, subName, numMessages, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public terminate(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).terminate(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public terminatePartitionedTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).terminatePartitionedTopic(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Offload a prefix of a topic to long term storage
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public triggerOffload(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).triggerOffload(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * The truncate operation will move all cursors to the end of the topic and delete all inactive ledgers.
     * @summary Truncate a topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public truncateTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).truncateTopic(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Unload a topic
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public unloadTopic(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).unloadTopic(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * It only increments partitions of existing non-global partitioned-topic
     * @summary Increment partitions of an existing partitioned topic.
     * @param {string} tenant Specify the tenant
     * @param {string} namespace Specify the namespace
     * @param {string} topic Specify topic name
     * @param {number} body The number of partitions for the topic
     * @param {boolean} [updateLocalTopicOnly] 
     * @param {boolean} [authoritative] Is authentication required to perform this operation
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersistentTopicApi
     */
    public updatePartitionedTopic(tenant: string, namespace: string, topic: string, body: number, updateLocalTopicOnly?: boolean, authoritative?: boolean, force?: boolean, options?: any) {
        return PersistentTopicApiFp(this.configuration).updatePartitionedTopic(tenant, namespace, topic, body, updateLocalTopicOnly, authoritative, force, options)(this.fetch, this.basePath);
    }

}

/**
 * ResourceQuotasApi - fetch parameter creator
 * @export
 */
export const ResourceQuotasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the default quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultResourceQuota(options: any = {}): FetchArgs {
            const localVarPath = `/resource-quotas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get resource quota of a namespace bundle.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getNamespaceBundleResourceQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getNamespaceBundleResourceQuota.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling getNamespaceBundleResourceQuota.');
            }
            const localVarPath = `/resource-quotas/{tenant}/{namespace}/{bundle}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove resource quota for a namespace.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling removeNamespaceBundleResourceQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling removeNamespaceBundleResourceQuota.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling removeNamespaceBundleResourceQuota.');
            }
            const localVarPath = `/resource-quotas/{tenant}/{namespace}/{bundle}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the default quota
         * @param {ResourceQuota} [body] Default resource quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultResourceQuota(body?: ResourceQuota, options: any = {}): FetchArgs {
            const localVarPath = `/resource-quotas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceQuota" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set resource quota on a namespace.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {ResourceQuota} [body] Resource quota for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, body?: ResourceQuota, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling setNamespaceBundleResourceQuota.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling setNamespaceBundleResourceQuota.');
            }
            // verify required parameter 'bundle' is not null or undefined
            if (bundle === null || bundle === undefined) {
                throw new RequiredError('bundle','Required parameter bundle was null or undefined when calling setNamespaceBundleResourceQuota.');
            }
            const localVarPath = `/resource-quotas/{tenant}/{namespace}/{bundle}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"bundle"}}`, encodeURIComponent(String(bundle)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceQuota" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceQuotasApi - functional programming interface
 * @export
 */
export const ResourceQuotasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the default quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultResourceQuota(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ResourceQuotasApiFetchParamCreator(configuration).getDefaultResourceQuota(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get resource quota of a namespace bundle.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceQuotasApiFetchParamCreator(configuration).getNamespaceBundleResourceQuota(tenant, namespace, bundle, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove resource quota for a namespace.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceQuotasApiFetchParamCreator(configuration).removeNamespaceBundleResourceQuota(tenant, namespace, bundle, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set the default quota
         * @param {ResourceQuota} [body] Default resource quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultResourceQuota(body?: ResourceQuota, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ResourceQuotasApiFetchParamCreator(configuration).setDefaultResourceQuota(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Set resource quota on a namespace.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {ResourceQuota} [body] Resource quota for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, body?: ResourceQuota, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceQuotasApiFetchParamCreator(configuration).setNamespaceBundleResourceQuota(tenant, namespace, bundle, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResourceQuotasApi - factory interface
 * @export
 */
export const ResourceQuotasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get the default quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultResourceQuota(options?: any) {
            return ResourceQuotasApiFp(configuration).getDefaultResourceQuota(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get resource quota of a namespace bundle.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options?: any) {
            return ResourceQuotasApiFp(configuration).getNamespaceBundleResourceQuota(tenant, namespace, bundle, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove resource quota for a namespace.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options?: any) {
            return ResourceQuotasApiFp(configuration).removeNamespaceBundleResourceQuota(tenant, namespace, bundle, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set the default quota
         * @param {ResourceQuota} [body] Default resource quota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultResourceQuota(body?: ResourceQuota, options?: any) {
            return ResourceQuotasApiFp(configuration).setDefaultResourceQuota(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Set resource quota on a namespace.
         * @param {string} tenant Tenant name
         * @param {string} namespace Namespace name within the specified tenant
         * @param {string} bundle Namespace bundle range
         * @param {ResourceQuota} [body] Resource quota for the specified namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, body?: ResourceQuota, options?: any) {
            return ResourceQuotasApiFp(configuration).setNamespaceBundleResourceQuota(tenant, namespace, bundle, body, options)(fetch, basePath);
        },
    };
};

/**
 * ResourceQuotasApi - object-oriented interface
 * @export
 * @class ResourceQuotasApi
 * @extends {BaseAPI}
 */
export class ResourceQuotasApi extends BaseAPI {
    /**
     * 
     * @summary Get the default quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceQuotasApi
     */
    public getDefaultResourceQuota(options?: any) {
        return ResourceQuotasApiFp(this.configuration).getDefaultResourceQuota(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get resource quota of a namespace bundle.
     * @param {string} tenant Tenant name
     * @param {string} namespace Namespace name within the specified tenant
     * @param {string} bundle Namespace bundle range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceQuotasApi
     */
    public getNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options?: any) {
        return ResourceQuotasApiFp(this.configuration).getNamespaceBundleResourceQuota(tenant, namespace, bundle, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove resource quota for a namespace.
     * @param {string} tenant Tenant name
     * @param {string} namespace Namespace name within the specified tenant
     * @param {string} bundle Namespace bundle range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceQuotasApi
     */
    public removeNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, options?: any) {
        return ResourceQuotasApiFp(this.configuration).removeNamespaceBundleResourceQuota(tenant, namespace, bundle, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set the default quota
     * @param {ResourceQuota} [body] Default resource quota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceQuotasApi
     */
    public setDefaultResourceQuota(body?: ResourceQuota, options?: any) {
        return ResourceQuotasApiFp(this.configuration).setDefaultResourceQuota(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Set resource quota on a namespace.
     * @param {string} tenant Tenant name
     * @param {string} namespace Namespace name within the specified tenant
     * @param {string} bundle Namespace bundle range
     * @param {ResourceQuota} [body] Resource quota for the specified namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceQuotasApi
     */
    public setNamespaceBundleResourceQuota(tenant: string, namespace: string, bundle: string, body?: ResourceQuota, options?: any) {
        return ResourceQuotasApiFp(this.configuration).setNamespaceBundleResourceQuota(tenant, namespace, bundle, body, options)(this.fetch, this.basePath);
    }

}

/**
 * ResourcegroupsApi - fetch parameter creator
 * @export
 */
export const ResourcegroupsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new resourcegroup with the specified rate limiters
         * @param {string} resourcegroup 
         * @param {ResourceGroup} [body] Rate limiters for the resourcegroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateResourceGroup(resourcegroup: string, body?: ResourceGroup, options: any = {}): FetchArgs {
            // verify required parameter 'resourcegroup' is not null or undefined
            if (resourcegroup === null || resourcegroup === undefined) {
                throw new RequiredError('resourcegroup','Required parameter resourcegroup was null or undefined when calling createOrUpdateResourceGroup.');
            }
            const localVarPath = `/resourcegroups/{resourcegroup}`
                .replace(`{${"resourcegroup"}}`, encodeURIComponent(String(resourcegroup)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResourceGroup" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a resourcegroup.
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceGroup(resourcegroup: string, options: any = {}): FetchArgs {
            // verify required parameter 'resourcegroup' is not null or undefined
            if (resourcegroup === null || resourcegroup === undefined) {
                throw new RequiredError('resourcegroup','Required parameter resourcegroup was null or undefined when calling deleteResourceGroup.');
            }
            const localVarPath = `/resourcegroups/{resourcegroup}`
                .replace(`{${"resourcegroup"}}`, encodeURIComponent(String(resourcegroup)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the rate limiters specified for a resourcegroup.
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroup(resourcegroup: string, options: any = {}): FetchArgs {
            // verify required parameter 'resourcegroup' is not null or undefined
            if (resourcegroup === null || resourcegroup === undefined) {
                throw new RequiredError('resourcegroup','Required parameter resourcegroup was null or undefined when calling getResourceGroup.');
            }
            const localVarPath = `/resourcegroups/{resourcegroup}`
                .replace(`{${"resourcegroup"}}`, encodeURIComponent(String(resourcegroup)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of all the resourcegroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroups(options: any = {}): FetchArgs {
            const localVarPath = `/resourcegroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcegroupsApi - functional programming interface
 * @export
 */
export const ResourcegroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new resourcegroup with the specified rate limiters
         * @param {string} resourcegroup 
         * @param {ResourceGroup} [body] Rate limiters for the resourcegroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateResourceGroup(resourcegroup: string, body?: ResourceGroup, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourcegroupsApiFetchParamCreator(configuration).createOrUpdateResourceGroup(resourcegroup, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a resourcegroup.
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceGroup(resourcegroup: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourcegroupsApiFetchParamCreator(configuration).deleteResourceGroup(resourcegroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the rate limiters specified for a resourcegroup.
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroup(resourcegroup: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResourceGroup> {
            const localVarFetchArgs = ResourcegroupsApiFetchParamCreator(configuration).getResourceGroup(resourcegroup, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of all the resourcegroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroups(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ResourcegroupsApiFetchParamCreator(configuration).getResourceGroups(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResourcegroupsApi - factory interface
 * @export
 */
export const ResourcegroupsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new resourcegroup with the specified rate limiters
         * @param {string} resourcegroup 
         * @param {ResourceGroup} [body] Rate limiters for the resourcegroup
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateResourceGroup(resourcegroup: string, body?: ResourceGroup, options?: any) {
            return ResourcegroupsApiFp(configuration).createOrUpdateResourceGroup(resourcegroup, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a resourcegroup.
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResourceGroup(resourcegroup: string, options?: any) {
            return ResourcegroupsApiFp(configuration).deleteResourceGroup(resourcegroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the rate limiters specified for a resourcegroup.
         * @param {string} resourcegroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroup(resourcegroup: string, options?: any) {
            return ResourcegroupsApiFp(configuration).getResourceGroup(resourcegroup, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of all the resourcegroups.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceGroups(options?: any) {
            return ResourcegroupsApiFp(configuration).getResourceGroups(options)(fetch, basePath);
        },
    };
};

/**
 * ResourcegroupsApi - object-oriented interface
 * @export
 * @class ResourcegroupsApi
 * @extends {BaseAPI}
 */
export class ResourcegroupsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new resourcegroup with the specified rate limiters
     * @param {string} resourcegroup 
     * @param {ResourceGroup} [body] Rate limiters for the resourcegroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcegroupsApi
     */
    public createOrUpdateResourceGroup(resourcegroup: string, body?: ResourceGroup, options?: any) {
        return ResourcegroupsApiFp(this.configuration).createOrUpdateResourceGroup(resourcegroup, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a resourcegroup.
     * @param {string} resourcegroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcegroupsApi
     */
    public deleteResourceGroup(resourcegroup: string, options?: any) {
        return ResourcegroupsApiFp(this.configuration).deleteResourceGroup(resourcegroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the rate limiters specified for a resourcegroup.
     * @param {string} resourcegroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcegroupsApi
     */
    public getResourceGroup(resourcegroup: string, options?: any) {
        return ResourcegroupsApiFp(this.configuration).getResourceGroup(resourcegroup, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of all the resourcegroups.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcegroupsApi
     */
    public getResourceGroups(options?: any) {
        return ResourcegroupsApiFp(this.configuration).getResourceGroups(options)(this.fetch, this.basePath);
    }

}

/**
 * SchemasApi - fetch parameter creator
 * @export
 */
export const SchemasApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, force?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteSchema.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling deleteSchema.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling deleteSchema.');
            }
            const localVarPath = `/schemas/{tenant}/{namespace}/{topic}/schema`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the all schemas of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSchemas(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getAllSchemas.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getAllSchemas.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getAllSchemas.');
            }
            const localVarPath = `/schemas/{tenant}/{namespace}/{topic}/schemas`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchema.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchema.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSchema.');
            }
            const localVarPath = `/schemas/{tenant}/{namespace}/{topic}/schema`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the schema of a topic at a given version
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} version 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema_1(tenant: string, namespace: string, topic: string, version: string, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getSchema_1.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getSchema_1.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getSchema_1.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling getSchema_1.');
            }
            const localVarPath = `/schemas/{tenant}/{namespace}/{topic}/schema/{version}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the version of the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionBySchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getVersionBySchema.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling getVersionBySchema.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling getVersionBySchema.');
            }
            const localVarPath = `/schemas/{tenant}/{namespace}/{topic}/version`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostSchemaPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling postSchema.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling postSchema.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling postSchema.');
            }
            const localVarPath = `/schemas/{tenant}/{namespace}/{topic}/schema`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostSchemaPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test the schema compatibility
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCompatibility(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling testCompatibility.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling testCompatibility.');
            }
            // verify required parameter 'topic' is not null or undefined
            if (topic === null || topic === undefined) {
                throw new RequiredError('topic','Required parameter topic was null or undefined when calling testCompatibility.');
            }
            const localVarPath = `/schemas/{tenant}/{namespace}/{topic}/compatibility`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"topic"}}`, encodeURIComponent(String(topic)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (authoritative !== undefined) {
                localVarQueryParameter['authoritative'] = authoritative;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostSchemaPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasApi - functional programming interface
 * @export
 */
export const SchemasApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, force?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteSchemaResponse> {
            const localVarFetchArgs = SchemasApiFetchParamCreator(configuration).deleteSchema(tenant, namespace, topic, authoritative, force, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the all schemas of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSchemas(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAllVersionsSchemaResponse> {
            const localVarFetchArgs = SchemasApiFetchParamCreator(configuration).getAllSchemas(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSchemaResponse> {
            const localVarFetchArgs = SchemasApiFetchParamCreator(configuration).getSchema(tenant, namespace, topic, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the schema of a topic at a given version
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} version 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema_1(tenant: string, namespace: string, topic: string, version: string, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSchemaResponse> {
            const localVarFetchArgs = SchemasApiFetchParamCreator(configuration).getSchema_1(tenant, namespace, topic, version, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary get the version of the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionBySchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LongSchemaVersion> {
            const localVarFetchArgs = SchemasApiFetchParamCreator(configuration).getVersionBySchema(tenant, namespace, topic, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PostSchemaResponse> {
            const localVarFetchArgs = SchemasApiFetchParamCreator(configuration).postSchema(tenant, namespace, topic, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary test the schema compatibility
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCompatibility(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IsCompatibilityResponse> {
            const localVarFetchArgs = SchemasApiFetchParamCreator(configuration).testCompatibility(tenant, namespace, topic, body, authoritative, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SchemasApi - factory interface
 * @export
 */
export const SchemasApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, force?: boolean, options?: any) {
            return SchemasApiFp(configuration).deleteSchema(tenant, namespace, topic, authoritative, force, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the all schemas of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSchemas(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return SchemasApiFp(configuration).getAllSchemas(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
            return SchemasApiFp(configuration).getSchema(tenant, namespace, topic, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the schema of a topic at a given version
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {string} version 
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema_1(tenant: string, namespace: string, topic: string, version: string, authoritative?: boolean, options?: any) {
            return SchemasApiFp(configuration).getSchema_1(tenant, namespace, topic, version, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary get the version of the schema
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersionBySchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any) {
            return SchemasApiFp(configuration).getVersionBySchema(tenant, namespace, topic, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the schema of a topic
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any) {
            return SchemasApiFp(configuration).postSchema(tenant, namespace, topic, body, authoritative, options)(fetch, basePath);
        },
        /**
         * 
         * @summary test the schema compatibility
         * @param {string} tenant 
         * @param {string} namespace 
         * @param {string} topic 
         * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
         * @param {boolean} [authoritative] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCompatibility(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any) {
            return SchemasApiFp(configuration).testCompatibility(tenant, namespace, topic, body, authoritative, options)(fetch, basePath);
        },
    };
};

/**
 * SchemasApi - object-oriented interface
 * @export
 * @class SchemasApi
 * @extends {BaseAPI}
 */
export class SchemasApi extends BaseAPI {
    /**
     * 
     * @summary Delete the schema of a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] 
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public deleteSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, force?: boolean, options?: any) {
        return SchemasApiFp(this.configuration).deleteSchema(tenant, namespace, topic, authoritative, force, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the all schemas of a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getAllSchemas(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return SchemasApiFp(this.configuration).getAllSchemas(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the schema of a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getSchema(tenant: string, namespace: string, topic: string, authoritative?: boolean, options?: any) {
        return SchemasApiFp(this.configuration).getSchema(tenant, namespace, topic, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the schema of a topic at a given version
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {string} version 
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getSchema_1(tenant: string, namespace: string, topic: string, version: string, authoritative?: boolean, options?: any) {
        return SchemasApiFp(this.configuration).getSchema_1(tenant, namespace, topic, version, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary get the version of the schema
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getVersionBySchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any) {
        return SchemasApiFp(this.configuration).getVersionBySchema(tenant, namespace, topic, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the schema of a topic
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public postSchema(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any) {
        return SchemasApiFp(this.configuration).postSchema(tenant, namespace, topic, body, authoritative, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary test the schema compatibility
     * @param {string} tenant 
     * @param {string} namespace 
     * @param {string} topic 
     * @param {PostSchemaPayload} [body] A JSON value presenting a schema playload. An example of the expected schema can be found down here.
     * @param {boolean} [authoritative] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public testCompatibility(tenant: string, namespace: string, topic: string, body?: PostSchemaPayload, authoritative?: boolean, options?: any) {
        return SchemasApiFp(this.configuration).testCompatibility(tenant, namespace, topic, body, authoritative, options)(this.fetch, this.basePath);
    }

}

/**
 * TenantsApi - fetch parameter creator
 * @export
 */
export const TenantsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation requires Pulsar super-user privileges.
         * @summary Create a new tenant.
         * @param {string} tenant The tenant name
         * @param {TenantInfo} [body] TenantInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(tenant: string, body?: TenantInfo, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling createTenant.');
            }
            const localVarPath = `/tenants/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TenantInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a tenant and all namespaces and topics under it.
         * @param {string} tenant The tenant name
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant(tenant: string, force?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling deleteTenant.');
            }
            const localVarPath = `/tenants/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the admin configuration for a given tenant.
         * @param {string} tenant The tenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAdmin(tenant: string, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling getTenantAdmin.');
            }
            const localVarPath = `/tenants/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of existing tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenants(options: any = {}): FetchArgs {
            const localVarPath = `/tenants`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation requires Pulsar super-user privileges.
         * @summary Update the admins for a tenant.
         * @param {string} tenant The tenant name
         * @param {TenantInfo} [body] TenantInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenant(tenant: string, body?: TenantInfo, options: any = {}): FetchArgs {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling updateTenant.');
            }
            const localVarPath = `/tenants/{tenant}`
                .replace(`{${"tenant"}}`, encodeURIComponent(String(tenant)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TenantInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantsApi - functional programming interface
 * @export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This operation requires Pulsar super-user privileges.
         * @summary Create a new tenant.
         * @param {string} tenant The tenant name
         * @param {TenantInfo} [body] TenantInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(tenant: string, body?: TenantInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).createTenant(tenant, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a tenant and all namespaces and topics under it.
         * @param {string} tenant The tenant name
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant(tenant: string, force?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).deleteTenant(tenant, force, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the admin configuration for a given tenant.
         * @param {string} tenant The tenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAdmin(tenant: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).getTenantAdmin(tenant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of existing tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenants(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).getTenants(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This operation requires Pulsar super-user privileges.
         * @summary Update the admins for a tenant.
         * @param {string} tenant The tenant name
         * @param {TenantInfo} [body] TenantInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenant(tenant: string, body?: TenantInfo, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TenantsApiFetchParamCreator(configuration).updateTenant(tenant, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TenantsApi - factory interface
 * @export
 */
export const TenantsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This operation requires Pulsar super-user privileges.
         * @summary Create a new tenant.
         * @param {string} tenant The tenant name
         * @param {TenantInfo} [body] TenantInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(tenant: string, body?: TenantInfo, options?: any) {
            return TenantsApiFp(configuration).createTenant(tenant, body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a tenant and all namespaces and topics under it.
         * @param {string} tenant The tenant name
         * @param {boolean} [force] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant(tenant: string, force?: boolean, options?: any) {
            return TenantsApiFp(configuration).deleteTenant(tenant, force, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the admin configuration for a given tenant.
         * @param {string} tenant The tenant name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantAdmin(tenant: string, options?: any) {
            return TenantsApiFp(configuration).getTenantAdmin(tenant, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of existing tenants.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenants(options?: any) {
            return TenantsApiFp(configuration).getTenants(options)(fetch, basePath);
        },
        /**
         * This operation requires Pulsar super-user privileges.
         * @summary Update the admins for a tenant.
         * @param {string} tenant The tenant name
         * @param {TenantInfo} [body] TenantInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenant(tenant: string, body?: TenantInfo, options?: any) {
            return TenantsApiFp(configuration).updateTenant(tenant, body, options)(fetch, basePath);
        },
    };
};

/**
 * TenantsApi - object-oriented interface
 * @export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
    /**
     * This operation requires Pulsar super-user privileges.
     * @summary Create a new tenant.
     * @param {string} tenant The tenant name
     * @param {TenantInfo} [body] TenantInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public createTenant(tenant: string, body?: TenantInfo, options?: any) {
        return TenantsApiFp(this.configuration).createTenant(tenant, body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a tenant and all namespaces and topics under it.
     * @param {string} tenant The tenant name
     * @param {boolean} [force] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public deleteTenant(tenant: string, force?: boolean, options?: any) {
        return TenantsApiFp(this.configuration).deleteTenant(tenant, force, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the admin configuration for a given tenant.
     * @param {string} tenant The tenant name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public getTenantAdmin(tenant: string, options?: any) {
        return TenantsApiFp(this.configuration).getTenantAdmin(tenant, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of existing tenants.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public getTenants(options?: any) {
        return TenantsApiFp(this.configuration).getTenants(options)(this.fetch, this.basePath);
    }

    /**
     * This operation requires Pulsar super-user privileges.
     * @summary Update the admins for a tenant.
     * @param {string} tenant The tenant name
     * @param {TenantInfo} [body] TenantInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public updateTenant(tenant: string, body?: TenantInfo, options?: any) {
        return TenantsApiFp(this.configuration).updateTenant(tenant, body, options)(this.fetch, this.basePath);
    }

}


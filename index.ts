/**
 * Pulsar Admin REST API
 * This provides the REST API for admin operations
 *
 * OpenAPI spec version: v2
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require("request");
import http = require("http");
import Promise = require("bluebird");

let defaultBasePath = "http://localhost/admin/v2";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any",
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type
        );
      }
      return instance;
    }
  }
}

export class AllocatorStats {
  "numDirectArenas"?: number;
  "numHeapArenas"?: number;
  "numThreadLocalCaches"?: number;
  "normalCacheSize"?: number;
  "smallCacheSize"?: number;
  "directArenas"?: Array<PoolArenaStats>;
  "heapArenas"?: Array<PoolArenaStats>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "numDirectArenas",
      baseName: "numDirectArenas",
      type: "number",
    },
    {
      name: "numHeapArenas",
      baseName: "numHeapArenas",
      type: "number",
    },
    {
      name: "numThreadLocalCaches",
      baseName: "numThreadLocalCaches",
      type: "number",
    },
    {
      name: "normalCacheSize",
      baseName: "normalCacheSize",
      type: "number",
    },
    {
      name: "smallCacheSize",
      baseName: "smallCacheSize",
      type: "number",
    },
    {
      name: "directArenas",
      baseName: "directArenas",
      type: "Array<PoolArenaStats>",
    },
    {
      name: "heapArenas",
      baseName: "heapArenas",
      type: "Array<PoolArenaStats>",
    },
  ];

  static getAttributeTypeMap() {
    return AllocatorStats.attributeTypeMap;
  }
}

export class Annotation {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return Annotation.attributeTypeMap;
  }
}

export class AnnotationIntrospector {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return AnnotationIntrospector.attributeTypeMap;
  }
}

export class ArrayBuilders {
  "booleanBuilder"?: BooleanBuilder;
  "byteBuilder"?: ByteBuilder;
  "shortBuilder"?: ShortBuilder;
  "intBuilder"?: IntBuilder;
  "longBuilder"?: LongBuilder;
  "floatBuilder"?: FloatBuilder;
  "doubleBuilder"?: DoubleBuilder;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "booleanBuilder",
      baseName: "booleanBuilder",
      type: "BooleanBuilder",
    },
    {
      name: "byteBuilder",
      baseName: "byteBuilder",
      type: "ByteBuilder",
    },
    {
      name: "shortBuilder",
      baseName: "shortBuilder",
      type: "ShortBuilder",
    },
    {
      name: "intBuilder",
      baseName: "intBuilder",
      type: "IntBuilder",
    },
    {
      name: "longBuilder",
      baseName: "longBuilder",
      type: "LongBuilder",
    },
    {
      name: "floatBuilder",
      baseName: "floatBuilder",
      type: "FloatBuilder",
    },
    {
      name: "doubleBuilder",
      baseName: "doubleBuilder",
      type: "DoubleBuilder",
    },
  ];

  static getAttributeTypeMap() {
    return ArrayBuilders.attributeTypeMap;
  }
}

export class AuthPolicies {
  "subscriptionAuthentication"?: { [key: string]: Array<string> };
  "namespaceAuthentication"?: { [key: string]: Array<string> };
  "topicAuthentication"?: { [key: string]: { [key: string]: Array<string> } };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "subscriptionAuthentication",
      baseName: "subscriptionAuthentication",
      type: "{ [key: string]: Array<string>; }",
    },
    {
      name: "namespaceAuthentication",
      baseName: "namespaceAuthentication",
      type: "{ [key: string]: Array<string>; }",
    },
    {
      name: "topicAuthentication",
      baseName: "topicAuthentication",
      type: "{ [key: string]: { [key: string]: Array<string>; }; }",
    },
  ];

  static getAttributeTypeMap() {
    return AuthPolicies.attributeTypeMap;
  }
}

export namespace AuthPolicies {
  export enum NamespaceAuthenticationEnum {
    Produce = <any>"produce",
    Consume = <any>"consume",
    Functions = <any>"functions",
    Sources = <any>"sources",
    Sinks = <any>"sinks",
    Packages = <any>"packages",
  }
  export enum TopicAuthenticationEnum {
    Produce = <any>"produce",
    Consume = <any>"consume",
    Functions = <any>"functions",
    Sources = <any>"sources",
    Sinks = <any>"sinks",
    Packages = <any>"packages",
  }
}
export class AuthenticationDataSource {
  "peerAddress"?: SocketAddress;
  "commandData"?: string;
  "tlsCertificates"?: Array<Certificate>;
  "httpAuthType"?: string;
  "subscription"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "peerAddress",
      baseName: "peerAddress",
      type: "SocketAddress",
    },
    {
      name: "commandData",
      baseName: "commandData",
      type: "string",
    },
    {
      name: "tlsCertificates",
      baseName: "tlsCertificates",
      type: "Array<Certificate>",
    },
    {
      name: "httpAuthType",
      baseName: "httpAuthType",
      type: "string",
    },
    {
      name: "subscription",
      baseName: "subscription",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return AuthenticationDataSource.attributeTypeMap;
  }
}

export class AutoFailoverPolicyData {
  "parameters"?: { [key: string]: string };
  "policyType"?: AutoFailoverPolicyData.PolicyTypeEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "parameters",
      baseName: "parameters",
      type: "{ [key: string]: string; }",
    },
    {
      name: "policyType",
      baseName: "policyType",
      type: "AutoFailoverPolicyData.PolicyTypeEnum",
    },
  ];

  static getAttributeTypeMap() {
    return AutoFailoverPolicyData.attributeTypeMap;
  }
}

export namespace AutoFailoverPolicyData {
  export enum PolicyTypeEnum {
    MinAvailable = <any>"min_available",
  }
}
export class AutoSubscriptionCreationOverride {
  "allowAutoSubscriptionCreation"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "allowAutoSubscriptionCreation",
      baseName: "allowAutoSubscriptionCreation",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return AutoSubscriptionCreationOverride.attributeTypeMap;
  }
}

export class AutoTopicCreationOverride {
  "topicType"?: string;
  "defaultNumPartitions"?: number;
  "allowAutoTopicCreation"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "topicType",
      baseName: "topicType",
      type: "string",
    },
    {
      name: "defaultNumPartitions",
      baseName: "defaultNumPartitions",
      type: "number",
    },
    {
      name: "allowAutoTopicCreation",
      baseName: "allowAutoTopicCreation",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return AutoTopicCreationOverride.attributeTypeMap;
  }
}

export class BacklogQuota {
  "policy"?: BacklogQuota.PolicyEnum;
  "limit"?: number;
  "limitSize"?: number;
  "limitTime"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "policy",
      baseName: "policy",
      type: "BacklogQuota.PolicyEnum",
    },
    {
      name: "limit",
      baseName: "limit",
      type: "number",
    },
    {
      name: "limitSize",
      baseName: "limitSize",
      type: "number",
    },
    {
      name: "limitTime",
      baseName: "limitTime",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return BacklogQuota.attributeTypeMap;
  }
}

export namespace BacklogQuota {
  export enum PolicyEnum {
    ProducerRequestHold = <any>"producer_request_hold",
    ProducerException = <any>"producer_exception",
    ConsumerBacklogEviction = <any>"consumer_backlog_eviction",
  }
}
export class Base64Variant {
  "name"?: string;
  "maxLineLength"?: number;
  "paddingChar"?: string;
  "paddingByte"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "maxLineLength",
      baseName: "maxLineLength",
      type: "number",
    },
    {
      name: "paddingChar",
      baseName: "paddingChar",
      type: "string",
    },
    {
      name: "paddingByte",
      baseName: "paddingByte",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Base64Variant.attributeTypeMap;
  }
}

export class BookieAffinityGroupData {
  "bookkeeperAffinityGroupPrimary"?: string;
  "bookkeeperAffinityGroupSecondary"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "bookkeeperAffinityGroupPrimary",
      baseName: "bookkeeperAffinityGroupPrimary",
      type: "string",
    },
    {
      name: "bookkeeperAffinityGroupSecondary",
      baseName: "bookkeeperAffinityGroupSecondary",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return BookieAffinityGroupData.attributeTypeMap;
  }
}

export class BookieInfo {
  "hostname"?: string;
  "rack"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "hostname",
      baseName: "hostname",
      type: "string",
    },
    {
      name: "rack",
      baseName: "rack",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return BookieInfo.attributeTypeMap;
  }
}

export class BookiesClusterInfo {
  "bookies"?: Array<RawBookieInfo>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "bookies",
      baseName: "bookies",
      type: "Array<RawBookieInfo>",
    },
  ];

  static getAttributeTypeMap() {
    return BookiesClusterInfo.attributeTypeMap;
  }
}

export class BooleanBuilder {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return BooleanBuilder.attributeTypeMap;
  }
}

export class BrokerInfo {
  "serviceUrl"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "serviceUrl",
      baseName: "serviceUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return BrokerInfo.attributeTypeMap;
  }
}

/**
 * The namespace isolation data for a given broker
 */
export class BrokerNamespaceIsolationData {
  /**
   * The broker name
   */
  "brokerName"?: string;
  /**
   * Policy name
   */
  "policyName"?: string;
  /**
   * The namespace-isolation policies attached to this broker
   */
  "namespaceRegex"?: Array<string>;
  "primary"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "brokerName",
      baseName: "brokerName",
      type: "string",
    },
    {
      name: "policyName",
      baseName: "policyName",
      type: "string",
    },
    {
      name: "namespaceRegex",
      baseName: "namespaceRegex",
      type: "Array<string>",
    },
    {
      name: "primary",
      baseName: "primary",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return BrokerNamespaceIsolationData.attributeTypeMap;
  }
}

export class BundlesData {
  "boundaries"?: Array<string>;
  "numBundles"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "boundaries",
      baseName: "boundaries",
      type: "Array<string>",
    },
    {
      name: "numBundles",
      baseName: "numBundles",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return BundlesData.attributeTypeMap;
  }
}

export class ByteBuilder {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return ByteBuilder.attributeTypeMap;
  }
}

export class Certificate {
  "type"?: string;
  "encoded"?: Array<string>;
  "publicKey"?: PublicKey;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "string",
    },
    {
      name: "encoded",
      baseName: "encoded",
      type: "Array<string>",
    },
    {
      name: "publicKey",
      baseName: "publicKey",
      type: "PublicKey",
    },
  ];

  static getAttributeTypeMap() {
    return Certificate.attributeTypeMap;
  }
}

export class CharacterEscapes {
  "escapeCodesForAscii"?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "escapeCodesForAscii",
      baseName: "escapeCodesForAscii",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return CharacterEscapes.attributeTypeMap;
  }
}

export class ClassIntrospector {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return ClassIntrospector.attributeTypeMap;
  }
}

export class ClassLoader {
  "name"?: string;
  "registeredAsParallelCapable"?: boolean;
  "parent"?: ClassLoader;
  "unnamedModule"?: Module;
  "definedPackages"?: Array<ModelPackage>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "registeredAsParallelCapable",
      baseName: "registeredAsParallelCapable",
      type: "boolean",
    },
    {
      name: "parent",
      baseName: "parent",
      type: "ClassLoader",
    },
    {
      name: "unnamedModule",
      baseName: "unnamedModule",
      type: "Module",
    },
    {
      name: "definedPackages",
      baseName: "definedPackages",
      type: "Array<ModelPackage>",
    },
  ];

  static getAttributeTypeMap() {
    return ClassLoader.attributeTypeMap;
  }
}

/**
 * The configuration data for a cluster
 */
export class ClusterData {
  /**
   * The HTTP rest service URL (for admin operations)
   */
  "serviceUrl"?: string;
  /**
   * The HTTPS rest service URL (for admin operations)
   */
  "serviceUrlTls"?: string;
  /**
   * The broker service url (for produce and consume operations)
   */
  "brokerServiceUrl"?: string;
  /**
   * The secured broker service url (for produce and consume operations)
   */
  "brokerServiceUrlTls"?: string;
  /**
   * Proxy-service url when client would like to connect to broker via proxy.
   */
  "proxyServiceUrl"?: string;
  /**
   * Authentication plugin when client would like to connect to cluster.
   */
  "authenticationPlugin"?: string;
  /**
   * Authentication parameters when client would like to connect to cluster.
   */
  "authenticationParameters"?: string;
  /**
   * protocol to decide type of proxy routing eg: SNI-routing
   */
  "proxyProtocol"?: ClusterData.ProxyProtocolEnum;
  /**
   * A set of peer cluster names
   */
  "peerClusterNames"?: Array<string>;
  /**
   * Enable TLS when talking with other brokers in the same cluster (admin operation) or different clusters (replication)
   */
  "brokerClientTlsEnabled"?: boolean;
  /**
   * Allow TLS connections to servers whose certificate cannot be be verified to have been signed by a trusted certificate authority.
   */
  "tlsAllowInsecureConnection"?: boolean;
  /**
   * Whether internal client use KeyStore type to authenticate with other Pulsar brokers
   */
  "brokerClientTlsEnabledWithKeyStore"?: boolean;
  /**
   * TLS TrustStore type configuration for internal client: JKS, PKCS12 used by the internal client to authenticate with Pulsar brokers
   */
  "brokerClientTlsTrustStoreType"?: string;
  /**
   * TLS TrustStore path for internal client used by the internal client to authenticate with Pulsar brokers
   */
  "brokerClientTlsTrustStore"?: string;
  /**
   * TLS TrustStore password for internal client used by the internal client to authenticate with Pulsar brokers
   */
  "brokerClientTlsTrustStorePassword"?: string;
  /**
   * Path for the trusted TLS certificate file for outgoing connection to a server (broker)
   */
  "brokerClientTrustCertsFilePath"?: string;
  /**
   * listenerName when client would like to connect to cluster
   */
  "listenerName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "serviceUrl",
      baseName: "serviceUrl",
      type: "string",
    },
    {
      name: "serviceUrlTls",
      baseName: "serviceUrlTls",
      type: "string",
    },
    {
      name: "brokerServiceUrl",
      baseName: "brokerServiceUrl",
      type: "string",
    },
    {
      name: "brokerServiceUrlTls",
      baseName: "brokerServiceUrlTls",
      type: "string",
    },
    {
      name: "proxyServiceUrl",
      baseName: "proxyServiceUrl",
      type: "string",
    },
    {
      name: "authenticationPlugin",
      baseName: "authenticationPlugin",
      type: "string",
    },
    {
      name: "authenticationParameters",
      baseName: "authenticationParameters",
      type: "string",
    },
    {
      name: "proxyProtocol",
      baseName: "proxyProtocol",
      type: "ClusterData.ProxyProtocolEnum",
    },
    {
      name: "peerClusterNames",
      baseName: "peerClusterNames",
      type: "Array<string>",
    },
    {
      name: "brokerClientTlsEnabled",
      baseName: "brokerClientTlsEnabled",
      type: "boolean",
    },
    {
      name: "tlsAllowInsecureConnection",
      baseName: "tlsAllowInsecureConnection",
      type: "boolean",
    },
    {
      name: "brokerClientTlsEnabledWithKeyStore",
      baseName: "brokerClientTlsEnabledWithKeyStore",
      type: "boolean",
    },
    {
      name: "brokerClientTlsTrustStoreType",
      baseName: "brokerClientTlsTrustStoreType",
      type: "string",
    },
    {
      name: "brokerClientTlsTrustStore",
      baseName: "brokerClientTlsTrustStore",
      type: "string",
    },
    {
      name: "brokerClientTlsTrustStorePassword",
      baseName: "brokerClientTlsTrustStorePassword",
      type: "string",
    },
    {
      name: "brokerClientTrustCertsFilePath",
      baseName: "brokerClientTrustCertsFilePath",
      type: "string",
    },
    {
      name: "listenerName",
      baseName: "listenerName",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ClusterData.attributeTypeMap;
  }
}

export namespace ClusterData {
  export enum ProxyProtocolEnum {
    SNI = <any>"SNI",
  }
}
export class CompletableFuture {
  "cancelled"?: boolean;
  "done"?: boolean;
  "numberOfDependents"?: number;
  "completedExceptionally"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "cancelled",
      baseName: "cancelled",
      type: "boolean",
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean",
    },
    {
      name: "numberOfDependents",
      baseName: "numberOfDependents",
      type: "number",
    },
    {
      name: "completedExceptionally",
      baseName: "completedExceptionally",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CompletableFuture.attributeTypeMap;
  }
}

export class CompletableFutureClusterData {
  "cancelled"?: boolean;
  "done"?: boolean;
  "numberOfDependents"?: number;
  "completedExceptionally"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "cancelled",
      baseName: "cancelled",
      type: "boolean",
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean",
    },
    {
      name: "numberOfDependents",
      baseName: "numberOfDependents",
      type: "number",
    },
    {
      name: "completedExceptionally",
      baseName: "completedExceptionally",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CompletableFutureClusterData.attributeTypeMap;
  }
}

export class CompletableFuturePartitionedTopicMetadata {
  "cancelled"?: boolean;
  "done"?: boolean;
  "numberOfDependents"?: number;
  "completedExceptionally"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "cancelled",
      baseName: "cancelled",
      type: "boolean",
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean",
    },
    {
      name: "numberOfDependents",
      baseName: "numberOfDependents",
      type: "number",
    },
    {
      name: "completedExceptionally",
      baseName: "completedExceptionally",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CompletableFuturePartitionedTopicMetadata.attributeTypeMap;
  }
}

export class CompletableFutureResourceQuota {
  "cancelled"?: boolean;
  "done"?: boolean;
  "numberOfDependents"?: number;
  "completedExceptionally"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "cancelled",
      baseName: "cancelled",
      type: "boolean",
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean",
    },
    {
      name: "numberOfDependents",
      baseName: "numberOfDependents",
      type: "number",
    },
    {
      name: "completedExceptionally",
      baseName: "completedExceptionally",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CompletableFutureResourceQuota.attributeTypeMap;
  }
}

export class CompletableFutureVoid {
  "cancelled"?: boolean;
  "done"?: boolean;
  "numberOfDependents"?: number;
  "completedExceptionally"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "cancelled",
      baseName: "cancelled",
      type: "boolean",
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean",
    },
    {
      name: "numberOfDependents",
      baseName: "numberOfDependents",
      type: "number",
    },
    {
      name: "completedExceptionally",
      baseName: "completedExceptionally",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CompletableFutureVoid.attributeTypeMap;
  }
}

export class ConnectorDefinition {
  "name"?: string;
  "description"?: string;
  "sourceClass"?: string;
  "sinkClass"?: string;
  "sourceConfigClass"?: string;
  "sinkConfigClass"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "description",
      baseName: "description",
      type: "string",
    },
    {
      name: "sourceClass",
      baseName: "sourceClass",
      type: "string",
    },
    {
      name: "sinkClass",
      baseName: "sinkClass",
      type: "string",
    },
    {
      name: "sourceConfigClass",
      baseName: "sourceConfigClass",
      type: "string",
    },
    {
      name: "sinkConfigClass",
      baseName: "sinkConfigClass",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ConnectorDefinition.attributeTypeMap;
  }
}

export class ContextAttributes {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return ContextAttributes.attributeTypeMap;
  }
}

export class Currency {
  "currencyCode"?: string;
  "defaultFractionDigits"?: number;
  "numericCode"?: number;
  "displayName"?: string;
  "symbol"?: string;
  "numericCodeAsString"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "currencyCode",
      baseName: "currencyCode",
      type: "string",
    },
    {
      name: "defaultFractionDigits",
      baseName: "defaultFractionDigits",
      type: "number",
    },
    {
      name: "numericCode",
      baseName: "numericCode",
      type: "number",
    },
    {
      name: "displayName",
      baseName: "displayName",
      type: "string",
    },
    {
      name: "symbol",
      baseName: "symbol",
      type: "string",
    },
    {
      name: "numericCodeAsString",
      baseName: "numericCodeAsString",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Currency.attributeTypeMap;
  }
}

export class CursorDetails {
  "cursorBacklog"?: number;
  "cursorLedgerId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "cursorBacklog",
      baseName: "cursorBacklog",
      type: "number",
    },
    {
      name: "cursorLedgerId",
      baseName: "cursorLedgerId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CursorDetails.attributeTypeMap;
  }
}

export class CursorStats {
  "markDeletePosition"?: string;
  "readPosition"?: string;
  "waitingReadOp"?: boolean;
  "pendingReadOps"?: number;
  "messagesConsumedCounter"?: number;
  "cursorLedger"?: number;
  "cursorLedgerLastEntry"?: number;
  "individuallyDeletedMessages"?: string;
  "lastLedgerSwitchTimestamp"?: string;
  "state"?: string;
  "numberOfEntriesSinceFirstNotAckedMessage"?: number;
  "totalNonContiguousDeletedMessagesRange"?: number;
  "subscriptionHavePendingRead"?: boolean;
  "subscriptionHavePendingReplayRead"?: boolean;
  "properties"?: { [key: string]: number };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "markDeletePosition",
      baseName: "markDeletePosition",
      type: "string",
    },
    {
      name: "readPosition",
      baseName: "readPosition",
      type: "string",
    },
    {
      name: "waitingReadOp",
      baseName: "waitingReadOp",
      type: "boolean",
    },
    {
      name: "pendingReadOps",
      baseName: "pendingReadOps",
      type: "number",
    },
    {
      name: "messagesConsumedCounter",
      baseName: "messagesConsumedCounter",
      type: "number",
    },
    {
      name: "cursorLedger",
      baseName: "cursorLedger",
      type: "number",
    },
    {
      name: "cursorLedgerLastEntry",
      baseName: "cursorLedgerLastEntry",
      type: "number",
    },
    {
      name: "individuallyDeletedMessages",
      baseName: "individuallyDeletedMessages",
      type: "string",
    },
    {
      name: "lastLedgerSwitchTimestamp",
      baseName: "lastLedgerSwitchTimestamp",
      type: "string",
    },
    {
      name: "state",
      baseName: "state",
      type: "string",
    },
    {
      name: "numberOfEntriesSinceFirstNotAckedMessage",
      baseName: "numberOfEntriesSinceFirstNotAckedMessage",
      type: "number",
    },
    {
      name: "totalNonContiguousDeletedMessagesRange",
      baseName: "totalNonContiguousDeletedMessagesRange",
      type: "number",
    },
    {
      name: "subscriptionHavePendingRead",
      baseName: "subscriptionHavePendingRead",
      type: "boolean",
    },
    {
      name: "subscriptionHavePendingReplayRead",
      baseName: "subscriptionHavePendingReplayRead",
      type: "boolean",
    },
    {
      name: "properties",
      baseName: "properties",
      type: "{ [key: string]: number; }",
    },
  ];

  static getAttributeTypeMap() {
    return CursorStats.attributeTypeMap;
  }
}

export class DateFormat {
  "calendar"?: Date;
  "numberFormat"?: NumberFormat;
  "timeZone"?: TimeZone;
  "lenient"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "calendar",
      baseName: "calendar",
      type: "Date",
    },
    {
      name: "numberFormat",
      baseName: "numberFormat",
      type: "NumberFormat",
    },
    {
      name: "timeZone",
      baseName: "timeZone",
      type: "TimeZone",
    },
    {
      name: "lenient",
      baseName: "lenient",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return DateFormat.attributeTypeMap;
  }
}

export class DelayedDeliveryPolicies {
  "active"?: boolean;
  "tickTime"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "active",
      baseName: "active",
      type: "boolean",
    },
    {
      name: "tickTime",
      baseName: "tickTime",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return DelayedDeliveryPolicies.attributeTypeMap;
  }
}

export class DeleteSchemaResponse {
  "version"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "version",
      baseName: "version",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return DeleteSchemaResponse.attributeTypeMap;
  }
}

export class DeserializationConfig {
  "annotationIntrospector"?: AnnotationIntrospector;
  "defaultPropertyInclusion"?: Value;
  "nodeFactory"?: JsonNodeFactory;
  "deserializationFeatures"?: number;
  "problemHandlers"?: LinkedNodeDeserializationProblemHandler;
  "attributes"?: ContextAttributes;
  "rootName"?: string;
  "subtypeResolver"?: SubtypeResolver;
  "fullRootName"?: PropertyName;
  "defaultVisibilityChecker"?: VisibilityCheckerObject;
  "locale"?: Locale;
  "timeZone"?: TimeZone;
  "typeFactory"?: TypeFactory;
  "propertyNamingStrategy"?: PropertyNamingStrategy;
  "handlerInstantiator"?: HandlerInstantiator;
  "dateFormat"?: DateFormat;
  "base64Variant"?: Base64Variant;
  "annotationProcessingEnabled"?: boolean;
  "classIntrospector"?: ClassIntrospector;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "annotationIntrospector",
      baseName: "annotationIntrospector",
      type: "AnnotationIntrospector",
    },
    {
      name: "defaultPropertyInclusion",
      baseName: "defaultPropertyInclusion",
      type: "Value",
    },
    {
      name: "nodeFactory",
      baseName: "nodeFactory",
      type: "JsonNodeFactory",
    },
    {
      name: "deserializationFeatures",
      baseName: "deserializationFeatures",
      type: "number",
    },
    {
      name: "problemHandlers",
      baseName: "problemHandlers",
      type: "LinkedNodeDeserializationProblemHandler",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "ContextAttributes",
    },
    {
      name: "rootName",
      baseName: "rootName",
      type: "string",
    },
    {
      name: "subtypeResolver",
      baseName: "subtypeResolver",
      type: "SubtypeResolver",
    },
    {
      name: "fullRootName",
      baseName: "fullRootName",
      type: "PropertyName",
    },
    {
      name: "defaultVisibilityChecker",
      baseName: "defaultVisibilityChecker",
      type: "VisibilityCheckerObject",
    },
    {
      name: "locale",
      baseName: "locale",
      type: "Locale",
    },
    {
      name: "timeZone",
      baseName: "timeZone",
      type: "TimeZone",
    },
    {
      name: "typeFactory",
      baseName: "typeFactory",
      type: "TypeFactory",
    },
    {
      name: "propertyNamingStrategy",
      baseName: "propertyNamingStrategy",
      type: "PropertyNamingStrategy",
    },
    {
      name: "handlerInstantiator",
      baseName: "handlerInstantiator",
      type: "HandlerInstantiator",
    },
    {
      name: "dateFormat",
      baseName: "dateFormat",
      type: "DateFormat",
    },
    {
      name: "base64Variant",
      baseName: "base64Variant",
      type: "Base64Variant",
    },
    {
      name: "annotationProcessingEnabled",
      baseName: "annotationProcessingEnabled",
      type: "boolean",
    },
    {
      name: "classIntrospector",
      baseName: "classIntrospector",
      type: "ClassIntrospector",
    },
  ];

  static getAttributeTypeMap() {
    return DeserializationConfig.attributeTypeMap;
  }
}

export class DeserializationContext {
  "factory"?: DeserializerFactory;
  "locale"?: Locale;
  "timeZone"?: TimeZone;
  "config"?: DeserializationConfig;
  "parser"?: JsonParser;
  "typeFactory"?: TypeFactory;
  "annotationIntrospector"?: AnnotationIntrospector;
  "nodeFactory"?: JsonNodeFactory;
  "contextualType"?: JavaType;
  "deserializationFeatures"?: number;
  "base64Variant"?: Base64Variant;
  "arrayBuilders"?: ArrayBuilders;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "factory",
      baseName: "factory",
      type: "DeserializerFactory",
    },
    {
      name: "locale",
      baseName: "locale",
      type: "Locale",
    },
    {
      name: "timeZone",
      baseName: "timeZone",
      type: "TimeZone",
    },
    {
      name: "config",
      baseName: "config",
      type: "DeserializationConfig",
    },
    {
      name: "parser",
      baseName: "parser",
      type: "JsonParser",
    },
    {
      name: "typeFactory",
      baseName: "typeFactory",
      type: "TypeFactory",
    },
    {
      name: "annotationIntrospector",
      baseName: "annotationIntrospector",
      type: "AnnotationIntrospector",
    },
    {
      name: "nodeFactory",
      baseName: "nodeFactory",
      type: "JsonNodeFactory",
    },
    {
      name: "contextualType",
      baseName: "contextualType",
      type: "JavaType",
    },
    {
      name: "deserializationFeatures",
      baseName: "deserializationFeatures",
      type: "number",
    },
    {
      name: "base64Variant",
      baseName: "base64Variant",
      type: "Base64Variant",
    },
    {
      name: "arrayBuilders",
      baseName: "arrayBuilders",
      type: "ArrayBuilders",
    },
  ];

  static getAttributeTypeMap() {
    return DeserializationContext.attributeTypeMap;
  }
}

export class DeserializerFactory {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return DeserializerFactory.attributeTypeMap;
  }
}

export class DispatchRate {
  "dispatchThrottlingRateInMsg"?: number;
  "dispatchThrottlingRateInByte"?: number;
  "relativeToPublishRate"?: boolean;
  "ratePeriodInSecond"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "dispatchThrottlingRateInMsg",
      baseName: "dispatchThrottlingRateInMsg",
      type: "number",
    },
    {
      name: "dispatchThrottlingRateInByte",
      baseName: "dispatchThrottlingRateInByte",
      type: "number",
    },
    {
      name: "relativeToPublishRate",
      baseName: "relativeToPublishRate",
      type: "boolean",
    },
    {
      name: "ratePeriodInSecond",
      baseName: "ratePeriodInSecond",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return DispatchRate.attributeTypeMap;
  }
}

export class DispatchRateImpl {
  "dispatchThrottlingRateInMsg"?: number;
  "dispatchThrottlingRateInByte"?: number;
  "relativeToPublishRate"?: boolean;
  "ratePeriodInSecond"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "dispatchThrottlingRateInMsg",
      baseName: "dispatchThrottlingRateInMsg",
      type: "number",
    },
    {
      name: "dispatchThrottlingRateInByte",
      baseName: "dispatchThrottlingRateInByte",
      type: "number",
    },
    {
      name: "relativeToPublishRate",
      baseName: "relativeToPublishRate",
      type: "boolean",
    },
    {
      name: "ratePeriodInSecond",
      baseName: "ratePeriodInSecond",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return DispatchRateImpl.attributeTypeMap;
  }
}

export class DoubleBuilder {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return DoubleBuilder.attributeTypeMap;
  }
}

/**
 * The data of a failure domain configuration in a cluster
 */
export class FailureDomain {
  /**
   * The collection of brokers in the same failure domain
   */
  "brokers"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "brokers",
      baseName: "brokers",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return FailureDomain.attributeTypeMap;
  }
}

export class FilterProvider {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return FilterProvider.attributeTypeMap;
  }
}

export class FloatBuilder {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return FloatBuilder.attributeTypeMap;
  }
}

export class FormatSchema {
  "schemaType"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "schemaType",
      baseName: "schemaType",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return FormatSchema.attributeTypeMap;
  }
}

export class FunctionInstanceStatsData {
  "oneMin"?: FunctionInstanceStatsDataBase;
  "userMetrics"?: { [key: string]: number };
  "lastInvocation"?: number;
  "receivedTotal"?: number;
  "processedSuccessfullyTotal"?: number;
  "systemExceptionsTotal"?: number;
  "userExceptionsTotal"?: number;
  "avgProcessLatency"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "oneMin",
      baseName: "oneMin",
      type: "FunctionInstanceStatsDataBase",
    },
    {
      name: "userMetrics",
      baseName: "userMetrics",
      type: "{ [key: string]: number; }",
    },
    {
      name: "lastInvocation",
      baseName: "lastInvocation",
      type: "number",
    },
    {
      name: "receivedTotal",
      baseName: "receivedTotal",
      type: "number",
    },
    {
      name: "processedSuccessfullyTotal",
      baseName: "processedSuccessfullyTotal",
      type: "number",
    },
    {
      name: "systemExceptionsTotal",
      baseName: "systemExceptionsTotal",
      type: "number",
    },
    {
      name: "userExceptionsTotal",
      baseName: "userExceptionsTotal",
      type: "number",
    },
    {
      name: "avgProcessLatency",
      baseName: "avgProcessLatency",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return FunctionInstanceStatsData.attributeTypeMap;
  }
}

export class FunctionInstanceStatsDataBase {
  "receivedTotal"?: number;
  "processedSuccessfullyTotal"?: number;
  "systemExceptionsTotal"?: number;
  "userExceptionsTotal"?: number;
  "avgProcessLatency"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "receivedTotal",
      baseName: "receivedTotal",
      type: "number",
    },
    {
      name: "processedSuccessfullyTotal",
      baseName: "processedSuccessfullyTotal",
      type: "number",
    },
    {
      name: "systemExceptionsTotal",
      baseName: "systemExceptionsTotal",
      type: "number",
    },
    {
      name: "userExceptionsTotal",
      baseName: "userExceptionsTotal",
      type: "number",
    },
    {
      name: "avgProcessLatency",
      baseName: "avgProcessLatency",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return FunctionInstanceStatsDataBase.attributeTypeMap;
  }
}

export class Functions {
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return Functions.attributeTypeMap;
  }
}

export class FunctionsV2 {
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return FunctionsV2.attributeTypeMap;
  }
}

export class FunctionsV2WorkerService {
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return FunctionsV2WorkerService.attributeTypeMap;
  }
}

export class FunctionsWorkerService {
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return FunctionsWorkerService.attributeTypeMap;
  }
}

export class GetAllVersionsSchemaResponse {
  "getSchemaResponses"?: Array<GetSchemaResponse>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "getSchemaResponses",
      baseName: "getSchemaResponses",
      type: "Array<GetSchemaResponse>",
    },
  ];

  static getAttributeTypeMap() {
    return GetAllVersionsSchemaResponse.attributeTypeMap;
  }
}

export class GetSchemaResponse {
  "version"?: number;
  "type"?: GetSchemaResponse.TypeEnum;
  "timestamp"?: number;
  "data"?: string;
  "properties"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "version",
      baseName: "version",
      type: "number",
    },
    {
      name: "type",
      baseName: "type",
      type: "GetSchemaResponse.TypeEnum",
    },
    {
      name: "timestamp",
      baseName: "timestamp",
      type: "number",
    },
    {
      name: "data",
      baseName: "data",
      type: "string",
    },
    {
      name: "properties",
      baseName: "properties",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return GetSchemaResponse.attributeTypeMap;
  }
}

export namespace GetSchemaResponse {
  export enum TypeEnum {
    NONE = <any>"NONE",
    STRING = <any>"STRING",
    JSON = <any>"JSON",
    PROTOBUF = <any>"PROTOBUF",
    AVRO = <any>"AVRO",
    BOOLEAN = <any>"BOOLEAN",
    INT8 = <any>"INT8",
    INT16 = <any>"INT16",
    INT32 = <any>"INT32",
    INT64 = <any>"INT64",
    FLOAT = <any>"FLOAT",
    DOUBLE = <any>"DOUBLE",
    DATE = <any>"DATE",
    TIME = <any>"TIME",
    TIMESTAMP = <any>"TIMESTAMP",
    KEYVALUE = <any>"KEY_VALUE",
    INSTANT = <any>"INSTANT",
    LOCALDATE = <any>"LOCAL_DATE",
    LOCALTIME = <any>"LOCAL_TIME",
    LOCALDATETIME = <any>"LOCAL_DATE_TIME",
    PROTOBUFNATIVE = <any>"PROTOBUF_NATIVE",
    BYTES = <any>"BYTES",
    AUTO = <any>"AUTO",
    AUTOCONSUME = <any>"AUTO_CONSUME",
    AUTOPUBLISH = <any>"AUTO_PUBLISH",
  }
}
export class HandlerInstantiator {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return HandlerInstantiator.attributeTypeMap;
  }
}

export class InactiveTopicPolicies {
  "inactiveTopicDeleteMode"?: InactiveTopicPolicies.InactiveTopicDeleteModeEnum;
  "maxInactiveDurationSeconds"?: number;
  "deleteWhileInactive"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "inactiveTopicDeleteMode",
      baseName: "inactiveTopicDeleteMode",
      type: "InactiveTopicPolicies.InactiveTopicDeleteModeEnum",
    },
    {
      name: "maxInactiveDurationSeconds",
      baseName: "maxInactiveDurationSeconds",
      type: "number",
    },
    {
      name: "deleteWhileInactive",
      baseName: "deleteWhileInactive",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return InactiveTopicPolicies.attributeTypeMap;
  }
}

export namespace InactiveTopicPolicies {
  export enum InactiveTopicDeleteModeEnum {
    NoSubscriptions = <any>"delete_when_no_subscriptions",
    SubscriptionsCaughtUp = <any>"delete_when_subscriptions_caught_up",
  }
}
export class InjectableValues {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return InjectableValues.attributeTypeMap;
  }
}

export class InputDecorator {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return InputDecorator.attributeTypeMap;
  }
}

export class IntBuilder {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return IntBuilder.attributeTypeMap;
  }
}

export class InternalConfigurationData {
  "metadataStoreUrl"?: string;
  "configurationMetadataStoreUrl"?: string;
  "ledgersRootPath"?: string;
  "bookkeeperMetadataServiceUri"?: string;
  "stateStorageServiceUrl"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "metadataStoreUrl",
      baseName: "metadataStoreUrl",
      type: "string",
    },
    {
      name: "configurationMetadataStoreUrl",
      baseName: "configurationMetadataStoreUrl",
      type: "string",
    },
    {
      name: "ledgersRootPath",
      baseName: "ledgersRootPath",
      type: "string",
    },
    {
      name: "bookkeeperMetadataServiceUri",
      baseName: "bookkeeperMetadataServiceUri",
      type: "string",
    },
    {
      name: "stateStorageServiceUrl",
      baseName: "stateStorageServiceUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return InternalConfigurationData.attributeTypeMap;
  }
}

export class IsCompatibilityResponse {
  "schemaCompatibilityStrategy"?: string;
  "compatibility"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "schemaCompatibilityStrategy",
      baseName: "schemaCompatibilityStrategy",
      type: "string",
    },
    {
      name: "compatibility",
      baseName: "compatibility",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return IsCompatibilityResponse.attributeTypeMap;
  }
}

export class JavaType {
  "_interface"?: boolean;
  "primitive"?: boolean;
  "interfaces"?: Array<JavaType>;
  "genericSignature"?: string;
  "_final"?: boolean;
  "_abstract"?: boolean;
  "bindings"?: TypeBindings;
  "concrete"?: boolean;
  "keyType"?: JavaType;
  "arrayType"?: boolean;
  "throwable"?: boolean;
  "javaLangObject"?: boolean;
  "enumType"?: boolean;
  "containerType"?: boolean;
  "valueHandler"?: any;
  "typeHandler"?: any;
  "referencedType"?: JavaType;
  "superClass"?: JavaType;
  "contentValueHandler"?: any;
  "contentTypeHandler"?: any;
  "erasedSignature"?: string;
  "collectionLikeType"?: boolean;
  "mapLikeType"?: boolean;
  "contentType"?: JavaType;
  "typeName"?: string;
  "referenceType"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "_interface",
      baseName: "interface",
      type: "boolean",
    },
    {
      name: "primitive",
      baseName: "primitive",
      type: "boolean",
    },
    {
      name: "interfaces",
      baseName: "interfaces",
      type: "Array<JavaType>",
    },
    {
      name: "genericSignature",
      baseName: "genericSignature",
      type: "string",
    },
    {
      name: "_final",
      baseName: "final",
      type: "boolean",
    },
    {
      name: "_abstract",
      baseName: "abstract",
      type: "boolean",
    },
    {
      name: "bindings",
      baseName: "bindings",
      type: "TypeBindings",
    },
    {
      name: "concrete",
      baseName: "concrete",
      type: "boolean",
    },
    {
      name: "keyType",
      baseName: "keyType",
      type: "JavaType",
    },
    {
      name: "arrayType",
      baseName: "arrayType",
      type: "boolean",
    },
    {
      name: "throwable",
      baseName: "throwable",
      type: "boolean",
    },
    {
      name: "javaLangObject",
      baseName: "javaLangObject",
      type: "boolean",
    },
    {
      name: "enumType",
      baseName: "enumType",
      type: "boolean",
    },
    {
      name: "containerType",
      baseName: "containerType",
      type: "boolean",
    },
    {
      name: "valueHandler",
      baseName: "valueHandler",
      type: "any",
    },
    {
      name: "typeHandler",
      baseName: "typeHandler",
      type: "any",
    },
    {
      name: "referencedType",
      baseName: "referencedType",
      type: "JavaType",
    },
    {
      name: "superClass",
      baseName: "superClass",
      type: "JavaType",
    },
    {
      name: "contentValueHandler",
      baseName: "contentValueHandler",
      type: "any",
    },
    {
      name: "contentTypeHandler",
      baseName: "contentTypeHandler",
      type: "any",
    },
    {
      name: "erasedSignature",
      baseName: "erasedSignature",
      type: "string",
    },
    {
      name: "collectionLikeType",
      baseName: "collectionLikeType",
      type: "boolean",
    },
    {
      name: "mapLikeType",
      baseName: "mapLikeType",
      type: "boolean",
    },
    {
      name: "contentType",
      baseName: "contentType",
      type: "JavaType",
    },
    {
      name: "typeName",
      baseName: "typeName",
      type: "string",
    },
    {
      name: "referenceType",
      baseName: "referenceType",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return JavaType.attributeTypeMap;
  }
}

export class JsonFactory {
  "inputDecorator"?: InputDecorator;
  "characterEscapes"?: CharacterEscapes;
  "outputDecorator"?: OutputDecorator;
  "rootValueSeparator"?: string;
  "codec"?: ObjectCodec;
  "formatName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "inputDecorator",
      baseName: "inputDecorator",
      type: "InputDecorator",
    },
    {
      name: "characterEscapes",
      baseName: "characterEscapes",
      type: "CharacterEscapes",
    },
    {
      name: "outputDecorator",
      baseName: "outputDecorator",
      type: "OutputDecorator",
    },
    {
      name: "rootValueSeparator",
      baseName: "rootValueSeparator",
      type: "string",
    },
    {
      name: "codec",
      baseName: "codec",
      type: "ObjectCodec",
    },
    {
      name: "formatName",
      baseName: "formatName",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return JsonFactory.attributeTypeMap;
  }
}

export class JsonGenerator {
  "schema"?: FormatSchema;
  "characterEscapes"?: CharacterEscapes;
  "codec"?: ObjectCodec;
  "prettyPrinter"?: PrettyPrinter;
  "featureMask"?: number;
  "formatFeatures"?: number;
  "currentValue"?: any;
  "highestEscapedChar"?: number;
  "outputTarget"?: any;
  "outputBuffered"?: number;
  "outputContext"?: JsonStreamContext;
  "closed"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "schema",
      baseName: "schema",
      type: "FormatSchema",
    },
    {
      name: "characterEscapes",
      baseName: "characterEscapes",
      type: "CharacterEscapes",
    },
    {
      name: "codec",
      baseName: "codec",
      type: "ObjectCodec",
    },
    {
      name: "prettyPrinter",
      baseName: "prettyPrinter",
      type: "PrettyPrinter",
    },
    {
      name: "featureMask",
      baseName: "featureMask",
      type: "number",
    },
    {
      name: "formatFeatures",
      baseName: "formatFeatures",
      type: "number",
    },
    {
      name: "currentValue",
      baseName: "currentValue",
      type: "any",
    },
    {
      name: "highestEscapedChar",
      baseName: "highestEscapedChar",
      type: "number",
    },
    {
      name: "outputTarget",
      baseName: "outputTarget",
      type: "any",
    },
    {
      name: "outputBuffered",
      baseName: "outputBuffered",
      type: "number",
    },
    {
      name: "outputContext",
      baseName: "outputContext",
      type: "JsonStreamContext",
    },
    {
      name: "closed",
      baseName: "closed",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return JsonGenerator.attributeTypeMap;
  }
}

export class JsonLocation {
  "byteOffset"?: number;
  "sourceRef"?: any;
  "lineNr"?: number;
  "columnNr"?: number;
  "charOffset"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "byteOffset",
      baseName: "byteOffset",
      type: "number",
    },
    {
      name: "sourceRef",
      baseName: "sourceRef",
      type: "any",
    },
    {
      name: "lineNr",
      baseName: "lineNr",
      type: "number",
    },
    {
      name: "columnNr",
      baseName: "columnNr",
      type: "number",
    },
    {
      name: "charOffset",
      baseName: "charOffset",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return JsonLocation.attributeTypeMap;
  }
}

export class JsonNodeFactory {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return JsonNodeFactory.attributeTypeMap;
  }
}

export class JsonParser {
  "textLength"?: number;
  "text"?: string;
  "textCharacters"?: Array<string>;
  "booleanValue"?: boolean;
  "byteValue"?: string;
  "doubleValue"?: number;
  "floatValue"?: number;
  "longValue"?: number;
  "shortValue"?: number;
  "objectId"?: any;
  "intValue"?: number;
  "typeId"?: any;
  "schema"?: FormatSchema;
  "codec"?: ObjectCodec;
  "currentToken"?: JsonParser.CurrentTokenEnum;
  "currentName"?: string;
  "tokenLocation"?: JsonLocation;
  "featureMask"?: number;
  "formatFeatures"?: number;
  "currentTokenId"?: number;
  "parsingContext"?: JsonStreamContext;
  "currentLocation"?: JsonLocation;
  "expectedStartArrayToken"?: boolean;
  "expectedStartObjectToken"?: boolean;
  "lastClearedToken"?: JsonParser.LastClearedTokenEnum;
  "textOffset"?: number;
  "numberValue"?: Number;
  "numberType"?: JsonParser.NumberTypeEnum;
  "bigIntegerValue"?: number;
  "decimalValue"?: number;
  "embeddedObject"?: any;
  "binaryValue"?: Array<string>;
  "valueAsInt"?: number;
  "valueAsLong"?: number;
  "valueAsDouble"?: number;
  "valueAsBoolean"?: boolean;
  "valueAsString"?: string;
  "inputSource"?: any;
  "currentValue"?: any;
  "closed"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "textLength",
      baseName: "textLength",
      type: "number",
    },
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
    {
      name: "textCharacters",
      baseName: "textCharacters",
      type: "Array<string>",
    },
    {
      name: "booleanValue",
      baseName: "booleanValue",
      type: "boolean",
    },
    {
      name: "byteValue",
      baseName: "byteValue",
      type: "string",
    },
    {
      name: "doubleValue",
      baseName: "doubleValue",
      type: "number",
    },
    {
      name: "floatValue",
      baseName: "floatValue",
      type: "number",
    },
    {
      name: "longValue",
      baseName: "longValue",
      type: "number",
    },
    {
      name: "shortValue",
      baseName: "shortValue",
      type: "number",
    },
    {
      name: "objectId",
      baseName: "objectId",
      type: "any",
    },
    {
      name: "intValue",
      baseName: "intValue",
      type: "number",
    },
    {
      name: "typeId",
      baseName: "typeId",
      type: "any",
    },
    {
      name: "schema",
      baseName: "schema",
      type: "FormatSchema",
    },
    {
      name: "codec",
      baseName: "codec",
      type: "ObjectCodec",
    },
    {
      name: "currentToken",
      baseName: "currentToken",
      type: "JsonParser.CurrentTokenEnum",
    },
    {
      name: "currentName",
      baseName: "currentName",
      type: "string",
    },
    {
      name: "tokenLocation",
      baseName: "tokenLocation",
      type: "JsonLocation",
    },
    {
      name: "featureMask",
      baseName: "featureMask",
      type: "number",
    },
    {
      name: "formatFeatures",
      baseName: "formatFeatures",
      type: "number",
    },
    {
      name: "currentTokenId",
      baseName: "currentTokenId",
      type: "number",
    },
    {
      name: "parsingContext",
      baseName: "parsingContext",
      type: "JsonStreamContext",
    },
    {
      name: "currentLocation",
      baseName: "currentLocation",
      type: "JsonLocation",
    },
    {
      name: "expectedStartArrayToken",
      baseName: "expectedStartArrayToken",
      type: "boolean",
    },
    {
      name: "expectedStartObjectToken",
      baseName: "expectedStartObjectToken",
      type: "boolean",
    },
    {
      name: "lastClearedToken",
      baseName: "lastClearedToken",
      type: "JsonParser.LastClearedTokenEnum",
    },
    {
      name: "textOffset",
      baseName: "textOffset",
      type: "number",
    },
    {
      name: "numberValue",
      baseName: "numberValue",
      type: "Number",
    },
    {
      name: "numberType",
      baseName: "numberType",
      type: "JsonParser.NumberTypeEnum",
    },
    {
      name: "bigIntegerValue",
      baseName: "bigIntegerValue",
      type: "number",
    },
    {
      name: "decimalValue",
      baseName: "decimalValue",
      type: "number",
    },
    {
      name: "embeddedObject",
      baseName: "embeddedObject",
      type: "any",
    },
    {
      name: "binaryValue",
      baseName: "binaryValue",
      type: "Array<string>",
    },
    {
      name: "valueAsInt",
      baseName: "valueAsInt",
      type: "number",
    },
    {
      name: "valueAsLong",
      baseName: "valueAsLong",
      type: "number",
    },
    {
      name: "valueAsDouble",
      baseName: "valueAsDouble",
      type: "number",
    },
    {
      name: "valueAsBoolean",
      baseName: "valueAsBoolean",
      type: "boolean",
    },
    {
      name: "valueAsString",
      baseName: "valueAsString",
      type: "string",
    },
    {
      name: "inputSource",
      baseName: "inputSource",
      type: "any",
    },
    {
      name: "currentValue",
      baseName: "currentValue",
      type: "any",
    },
    {
      name: "closed",
      baseName: "closed",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return JsonParser.attributeTypeMap;
  }
}

export namespace JsonParser {
  export enum CurrentTokenEnum {
    NOTAVAILABLE = <any>"NOT_AVAILABLE",
    STARTOBJECT = <any>"START_OBJECT",
    ENDOBJECT = <any>"END_OBJECT",
    STARTARRAY = <any>"START_ARRAY",
    ENDARRAY = <any>"END_ARRAY",
    FIELDNAME = <any>"FIELD_NAME",
    VALUEEMBEDDEDOBJECT = <any>"VALUE_EMBEDDED_OBJECT",
    VALUESTRING = <any>"VALUE_STRING",
    VALUENUMBERINT = <any>"VALUE_NUMBER_INT",
    VALUENUMBERFLOAT = <any>"VALUE_NUMBER_FLOAT",
    VALUETRUE = <any>"VALUE_TRUE",
    VALUEFALSE = <any>"VALUE_FALSE",
    VALUENULL = <any>"VALUE_NULL",
  }
  export enum LastClearedTokenEnum {
    NOTAVAILABLE = <any>"NOT_AVAILABLE",
    STARTOBJECT = <any>"START_OBJECT",
    ENDOBJECT = <any>"END_OBJECT",
    STARTARRAY = <any>"START_ARRAY",
    ENDARRAY = <any>"END_ARRAY",
    FIELDNAME = <any>"FIELD_NAME",
    VALUEEMBEDDEDOBJECT = <any>"VALUE_EMBEDDED_OBJECT",
    VALUESTRING = <any>"VALUE_STRING",
    VALUENUMBERINT = <any>"VALUE_NUMBER_INT",
    VALUENUMBERFLOAT = <any>"VALUE_NUMBER_FLOAT",
    VALUETRUE = <any>"VALUE_TRUE",
    VALUEFALSE = <any>"VALUE_FALSE",
    VALUENULL = <any>"VALUE_NULL",
  }
  export enum NumberTypeEnum {
    INT = <any>"INT",
    LONG = <any>"LONG",
    BIGINTEGER = <any>"BIG_INTEGER",
    FLOAT = <any>"FLOAT",
    DOUBLE = <any>"DOUBLE",
    BIGDECIMAL = <any>"BIG_DECIMAL",
  }
}
export class JsonSerializer {
  "unwrappingSerializer"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "unwrappingSerializer",
      baseName: "unwrappingSerializer",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return JsonSerializer.attributeTypeMap;
  }
}

export class JsonSerializerObject {
  "unwrappingSerializer"?: boolean;
  "delegatee"?: JsonSerializerObject;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "unwrappingSerializer",
      baseName: "unwrappingSerializer",
      type: "boolean",
    },
    {
      name: "delegatee",
      baseName: "delegatee",
      type: "JsonSerializerObject",
    },
  ];

  static getAttributeTypeMap() {
    return JsonSerializerObject.attributeTypeMap;
  }
}

export class JsonStreamContext {
  "parent"?: JsonStreamContext;
  "currentName"?: string;
  "currentValue"?: any;
  "entryCount"?: number;
  "typeDesc"?: string;
  "currentIndex"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "parent",
      baseName: "parent",
      type: "JsonStreamContext",
    },
    {
      name: "currentName",
      baseName: "currentName",
      type: "string",
    },
    {
      name: "currentValue",
      baseName: "currentValue",
      type: "any",
    },
    {
      name: "entryCount",
      baseName: "entryCount",
      type: "number",
    },
    {
      name: "typeDesc",
      baseName: "typeDesc",
      type: "string",
    },
    {
      name: "currentIndex",
      baseName: "currentIndex",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return JsonStreamContext.attributeTypeMap;
  }
}

export class KubernetesContainerFactory {
  "k8Uri"?: string;
  "jobNamespace"?: string;
  "jobName"?: string;
  "pulsarDockerImageName"?: string;
  "functionDockerImages"?: { [key: string]: string };
  "imagePullPolicy"?: string;
  "pulsarRootDir"?: string;
  "configAdminCLI"?: string;
  "submittingInsidePod"?: boolean;
  "pulsarServiceUrl"?: string;
  "pulsarAdminUrl"?: string;
  "installUserCodeDependencies"?: boolean;
  "pythonDependencyRepository"?: string;
  "pythonExtraDependencyRepository"?: string;
  "extraFunctionDependenciesDir"?: string;
  "customLabels"?: { [key: string]: string };
  "expectedMetricsCollectionInterval"?: number;
  "changeConfigMap"?: string;
  "changeConfigMapNamespace"?: string;
  "percentMemoryPadding"?: number;
  "cpuOverCommitRatio"?: number;
  "memoryOverCommitRatio"?: number;
  "grpcPort"?: number;
  "metricsPort"?: number;
  "narExtractionDirectory"?: string;
  "functionInstanceClassPath"?: string;
  "gracePeriodSeconds"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "k8Uri",
      baseName: "k8Uri",
      type: "string",
    },
    {
      name: "jobNamespace",
      baseName: "jobNamespace",
      type: "string",
    },
    {
      name: "jobName",
      baseName: "jobName",
      type: "string",
    },
    {
      name: "pulsarDockerImageName",
      baseName: "pulsarDockerImageName",
      type: "string",
    },
    {
      name: "functionDockerImages",
      baseName: "functionDockerImages",
      type: "{ [key: string]: string; }",
    },
    {
      name: "imagePullPolicy",
      baseName: "imagePullPolicy",
      type: "string",
    },
    {
      name: "pulsarRootDir",
      baseName: "pulsarRootDir",
      type: "string",
    },
    {
      name: "configAdminCLI",
      baseName: "configAdminCLI",
      type: "string",
    },
    {
      name: "submittingInsidePod",
      baseName: "submittingInsidePod",
      type: "boolean",
    },
    {
      name: "pulsarServiceUrl",
      baseName: "pulsarServiceUrl",
      type: "string",
    },
    {
      name: "pulsarAdminUrl",
      baseName: "pulsarAdminUrl",
      type: "string",
    },
    {
      name: "installUserCodeDependencies",
      baseName: "installUserCodeDependencies",
      type: "boolean",
    },
    {
      name: "pythonDependencyRepository",
      baseName: "pythonDependencyRepository",
      type: "string",
    },
    {
      name: "pythonExtraDependencyRepository",
      baseName: "pythonExtraDependencyRepository",
      type: "string",
    },
    {
      name: "extraFunctionDependenciesDir",
      baseName: "extraFunctionDependenciesDir",
      type: "string",
    },
    {
      name: "customLabels",
      baseName: "customLabels",
      type: "{ [key: string]: string; }",
    },
    {
      name: "expectedMetricsCollectionInterval",
      baseName: "expectedMetricsCollectionInterval",
      type: "number",
    },
    {
      name: "changeConfigMap",
      baseName: "changeConfigMap",
      type: "string",
    },
    {
      name: "changeConfigMapNamespace",
      baseName: "changeConfigMapNamespace",
      type: "string",
    },
    {
      name: "percentMemoryPadding",
      baseName: "percentMemoryPadding",
      type: "number",
    },
    {
      name: "cpuOverCommitRatio",
      baseName: "cpuOverCommitRatio",
      type: "number",
    },
    {
      name: "memoryOverCommitRatio",
      baseName: "memoryOverCommitRatio",
      type: "number",
    },
    {
      name: "grpcPort",
      baseName: "grpcPort",
      type: "number",
    },
    {
      name: "metricsPort",
      baseName: "metricsPort",
      type: "number",
    },
    {
      name: "narExtractionDirectory",
      baseName: "narExtractionDirectory",
      type: "string",
    },
    {
      name: "functionInstanceClassPath",
      baseName: "functionInstanceClassPath",
      type: "string",
    },
    {
      name: "gracePeriodSeconds",
      baseName: "gracePeriodSeconds",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return KubernetesContainerFactory.attributeTypeMap;
  }
}

export class LedgerDetails {
  "entries"?: number;
  "timestamp"?: number;
  "size"?: number;
  "ledgerId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "entries",
      baseName: "entries",
      type: "number",
    },
    {
      name: "timestamp",
      baseName: "timestamp",
      type: "number",
    },
    {
      name: "size",
      baseName: "size",
      type: "number",
    },
    {
      name: "ledgerId",
      baseName: "ledgerId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return LedgerDetails.attributeTypeMap;
  }
}

export class LedgerInfo {
  "ledgerId"?: number;
  "entries"?: number;
  "size"?: number;
  "offloaded"?: boolean;
  "metadata"?: string;
  "underReplicated"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ledgerId",
      baseName: "ledgerId",
      type: "number",
    },
    {
      name: "entries",
      baseName: "entries",
      type: "number",
    },
    {
      name: "size",
      baseName: "size",
      type: "number",
    },
    {
      name: "offloaded",
      baseName: "offloaded",
      type: "boolean",
    },
    {
      name: "metadata",
      baseName: "metadata",
      type: "string",
    },
    {
      name: "underReplicated",
      baseName: "underReplicated",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return LedgerInfo.attributeTypeMap;
  }
}

export class LinkedNode {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return LinkedNode.attributeTypeMap;
  }
}

export class LinkedNodeDeserializationProblemHandler {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return LinkedNodeDeserializationProblemHandler.attributeTypeMap;
  }
}

export class LoadReport {
  "name"?: string;
  "brokerVersionString"?: string;
  "webServiceUrl"?: string;
  "webServiceUrlTls"?: string;
  "pulsarServiceUrl"?: string;
  "pulsarServiceUrlTls"?: string;
  "persistentTopicsEnabled"?: boolean;
  "nonPersistentTopicsEnabled"?: boolean;
  "timestamp"?: number;
  "msgRateIn"?: number;
  "msgRateOut"?: number;
  "numTopics"?: number;
  "numConsumers"?: number;
  "numProducers"?: number;
  "numBundles"?: number;
  "protocols"?: { [key: string]: string };
  "systemResourceUsage"?: SystemResourceUsage;
  "bundleStats"?: { [key: string]: NamespaceBundleStats };
  "bundleGains"?: Array<string>;
  "bundleLosses"?: Array<string>;
  "allocatedCPU"?: number;
  "allocatedMemory"?: number;
  "allocatedBandwidthIn"?: number;
  "allocatedBandwidthOut"?: number;
  "allocatedMsgRateIn"?: number;
  "allocatedMsgRateOut"?: number;
  "preAllocatedCPU"?: number;
  "preAllocatedMemory"?: number;
  "preAllocatedBandwidthIn"?: number;
  "preAllocatedBandwidthOut"?: number;
  "preAllocatedMsgRateIn"?: number;
  "preAllocatedMsgRateOut"?: number;
  "underLoaded"?: boolean;
  "overLoaded"?: boolean;
  "loadReportType"?: string;
  "memory"?: ResourceUsage;
  "cpu"?: ResourceUsage;
  "directMemory"?: ResourceUsage;
  "lastUpdate"?: number;
  "bandwidthIn"?: ResourceUsage;
  "msgThroughputIn"?: number;
  "msgThroughputOut"?: number;
  "bandwidthOut"?: ResourceUsage;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "brokerVersionString",
      baseName: "brokerVersionString",
      type: "string",
    },
    {
      name: "webServiceUrl",
      baseName: "webServiceUrl",
      type: "string",
    },
    {
      name: "webServiceUrlTls",
      baseName: "webServiceUrlTls",
      type: "string",
    },
    {
      name: "pulsarServiceUrl",
      baseName: "pulsarServiceUrl",
      type: "string",
    },
    {
      name: "pulsarServiceUrlTls",
      baseName: "pulsarServiceUrlTls",
      type: "string",
    },
    {
      name: "persistentTopicsEnabled",
      baseName: "persistentTopicsEnabled",
      type: "boolean",
    },
    {
      name: "nonPersistentTopicsEnabled",
      baseName: "nonPersistentTopicsEnabled",
      type: "boolean",
    },
    {
      name: "timestamp",
      baseName: "timestamp",
      type: "number",
    },
    {
      name: "msgRateIn",
      baseName: "msgRateIn",
      type: "number",
    },
    {
      name: "msgRateOut",
      baseName: "msgRateOut",
      type: "number",
    },
    {
      name: "numTopics",
      baseName: "numTopics",
      type: "number",
    },
    {
      name: "numConsumers",
      baseName: "numConsumers",
      type: "number",
    },
    {
      name: "numProducers",
      baseName: "numProducers",
      type: "number",
    },
    {
      name: "numBundles",
      baseName: "numBundles",
      type: "number",
    },
    {
      name: "protocols",
      baseName: "protocols",
      type: "{ [key: string]: string; }",
    },
    {
      name: "systemResourceUsage",
      baseName: "systemResourceUsage",
      type: "SystemResourceUsage",
    },
    {
      name: "bundleStats",
      baseName: "bundleStats",
      type: "{ [key: string]: NamespaceBundleStats; }",
    },
    {
      name: "bundleGains",
      baseName: "bundleGains",
      type: "Array<string>",
    },
    {
      name: "bundleLosses",
      baseName: "bundleLosses",
      type: "Array<string>",
    },
    {
      name: "allocatedCPU",
      baseName: "allocatedCPU",
      type: "number",
    },
    {
      name: "allocatedMemory",
      baseName: "allocatedMemory",
      type: "number",
    },
    {
      name: "allocatedBandwidthIn",
      baseName: "allocatedBandwidthIn",
      type: "number",
    },
    {
      name: "allocatedBandwidthOut",
      baseName: "allocatedBandwidthOut",
      type: "number",
    },
    {
      name: "allocatedMsgRateIn",
      baseName: "allocatedMsgRateIn",
      type: "number",
    },
    {
      name: "allocatedMsgRateOut",
      baseName: "allocatedMsgRateOut",
      type: "number",
    },
    {
      name: "preAllocatedCPU",
      baseName: "preAllocatedCPU",
      type: "number",
    },
    {
      name: "preAllocatedMemory",
      baseName: "preAllocatedMemory",
      type: "number",
    },
    {
      name: "preAllocatedBandwidthIn",
      baseName: "preAllocatedBandwidthIn",
      type: "number",
    },
    {
      name: "preAllocatedBandwidthOut",
      baseName: "preAllocatedBandwidthOut",
      type: "number",
    },
    {
      name: "preAllocatedMsgRateIn",
      baseName: "preAllocatedMsgRateIn",
      type: "number",
    },
    {
      name: "preAllocatedMsgRateOut",
      baseName: "preAllocatedMsgRateOut",
      type: "number",
    },
    {
      name: "underLoaded",
      baseName: "underLoaded",
      type: "boolean",
    },
    {
      name: "overLoaded",
      baseName: "overLoaded",
      type: "boolean",
    },
    {
      name: "loadReportType",
      baseName: "loadReportType",
      type: "string",
    },
    {
      name: "memory",
      baseName: "memory",
      type: "ResourceUsage",
    },
    {
      name: "cpu",
      baseName: "cpu",
      type: "ResourceUsage",
    },
    {
      name: "directMemory",
      baseName: "directMemory",
      type: "ResourceUsage",
    },
    {
      name: "lastUpdate",
      baseName: "lastUpdate",
      type: "number",
    },
    {
      name: "bandwidthIn",
      baseName: "bandwidthIn",
      type: "ResourceUsage",
    },
    {
      name: "msgThroughputIn",
      baseName: "msgThroughputIn",
      type: "number",
    },
    {
      name: "msgThroughputOut",
      baseName: "msgThroughputOut",
      type: "number",
    },
    {
      name: "bandwidthOut",
      baseName: "bandwidthOut",
      type: "ResourceUsage",
    },
  ];

  static getAttributeTypeMap() {
    return LoadReport.attributeTypeMap;
  }
}

export class Locale {
  "language"?: string;
  "script"?: string;
  "variant"?: string;
  "displayName"?: string;
  "country"?: string;
  "unicodeLocaleAttributes"?: Array<string>;
  "unicodeLocaleKeys"?: Array<string>;
  "displayLanguage"?: string;
  "displayScript"?: string;
  "displayCountry"?: string;
  "displayVariant"?: string;
  "extensionKeys"?: Array<string>;
  "iso3Language"?: string;
  "iso3Country"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "language",
      baseName: "language",
      type: "string",
    },
    {
      name: "script",
      baseName: "script",
      type: "string",
    },
    {
      name: "variant",
      baseName: "variant",
      type: "string",
    },
    {
      name: "displayName",
      baseName: "displayName",
      type: "string",
    },
    {
      name: "country",
      baseName: "country",
      type: "string",
    },
    {
      name: "unicodeLocaleAttributes",
      baseName: "unicodeLocaleAttributes",
      type: "Array<string>",
    },
    {
      name: "unicodeLocaleKeys",
      baseName: "unicodeLocaleKeys",
      type: "Array<string>",
    },
    {
      name: "displayLanguage",
      baseName: "displayLanguage",
      type: "string",
    },
    {
      name: "displayScript",
      baseName: "displayScript",
      type: "string",
    },
    {
      name: "displayCountry",
      baseName: "displayCountry",
      type: "string",
    },
    {
      name: "displayVariant",
      baseName: "displayVariant",
      type: "string",
    },
    {
      name: "extensionKeys",
      baseName: "extensionKeys",
      type: "Array<string>",
    },
    {
      name: "iso3Language",
      baseName: "iso3Language",
      type: "string",
    },
    {
      name: "iso3Country",
      baseName: "iso3Country",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Locale.attributeTypeMap;
  }
}

export class LongBuilder {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return LongBuilder.attributeTypeMap;
  }
}

export class LongRunningProcessStatus {
  "status"?: LongRunningProcessStatus.StatusEnum;
  "lastError"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "status",
      baseName: "status",
      type: "LongRunningProcessStatus.StatusEnum",
    },
    {
      name: "lastError",
      baseName: "lastError",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return LongRunningProcessStatus.attributeTypeMap;
  }
}

export namespace LongRunningProcessStatus {
  export enum StatusEnum {
    NOTRUN = <any>"NOT_RUN",
    RUNNING = <any>"RUNNING",
    SUCCESS = <any>"SUCCESS",
    ERROR = <any>"ERROR",
  }
}
export class LongSchemaVersion {
  "version"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "version",
      baseName: "version",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return LongSchemaVersion.attributeTypeMap;
  }
}

export class MemoryLimit {
  "absoluteValue"?: number;
  "percentOfMaxDirectMemory"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "absoluteValue",
      baseName: "absoluteValue",
      type: "number",
    },
    {
      name: "percentOfMaxDirectMemory",
      baseName: "percentOfMaxDirectMemory",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return MemoryLimit.attributeTypeMap;
  }
}

export class MessageId {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return MessageId.attributeTypeMap;
  }
}

export class Metrics {
  "metrics"?: { [key: string]: any };
  "dimensions"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "metrics",
      baseName: "metrics",
      type: "{ [key: string]: any; }",
    },
    {
      name: "dimensions",
      baseName: "dimensions",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return Metrics.attributeTypeMap;
  }
}

export class ModelPackage {
  "name"?: string;
  "annotations"?: Array<Annotation>;
  "declaredAnnotations"?: Array<Annotation>;
  "sealed"?: boolean;
  "specificationTitle"?: string;
  "specificationVersion"?: string;
  "specificationVendor"?: string;
  "implementationTitle"?: string;
  "implementationVersion"?: string;
  "implementationVendor"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "annotations",
      baseName: "annotations",
      type: "Array<Annotation>",
    },
    {
      name: "declaredAnnotations",
      baseName: "declaredAnnotations",
      type: "Array<Annotation>",
    },
    {
      name: "sealed",
      baseName: "sealed",
      type: "boolean",
    },
    {
      name: "specificationTitle",
      baseName: "specificationTitle",
      type: "string",
    },
    {
      name: "specificationVersion",
      baseName: "specificationVersion",
      type: "string",
    },
    {
      name: "specificationVendor",
      baseName: "specificationVendor",
      type: "string",
    },
    {
      name: "implementationTitle",
      baseName: "implementationTitle",
      type: "string",
    },
    {
      name: "implementationVersion",
      baseName: "implementationVersion",
      type: "string",
    },
    {
      name: "implementationVendor",
      baseName: "implementationVendor",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ModelPackage.attributeTypeMap;
  }
}

export class Module {
  "name"?: string;
  "classLoader"?: ClassLoader;
  "descriptor"?: ModuleDescriptor;
  "named"?: boolean;
  "annotations"?: Array<Annotation>;
  "declaredAnnotations"?: Array<Annotation>;
  "packages"?: Array<string>;
  "layer"?: ModuleLayer;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "classLoader",
      baseName: "classLoader",
      type: "ClassLoader",
    },
    {
      name: "descriptor",
      baseName: "descriptor",
      type: "ModuleDescriptor",
    },
    {
      name: "named",
      baseName: "named",
      type: "boolean",
    },
    {
      name: "annotations",
      baseName: "annotations",
      type: "Array<Annotation>",
    },
    {
      name: "declaredAnnotations",
      baseName: "declaredAnnotations",
      type: "Array<Annotation>",
    },
    {
      name: "packages",
      baseName: "packages",
      type: "Array<string>",
    },
    {
      name: "layer",
      baseName: "layer",
      type: "ModuleLayer",
    },
  ];

  static getAttributeTypeMap() {
    return Module.attributeTypeMap;
  }
}

export class ModuleDescriptor {
  "open"?: boolean;
  "automatic"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "open",
      baseName: "open",
      type: "boolean",
    },
    {
      name: "automatic",
      baseName: "automatic",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return ModuleDescriptor.attributeTypeMap;
  }
}

export class ModuleLayer {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return ModuleLayer.attributeTypeMap;
  }
}

export class NamespaceBundleStats {
  "msgRateIn"?: number;
  "msgThroughputIn"?: number;
  "msgRateOut"?: number;
  "msgThroughputOut"?: number;
  "consumerCount"?: number;
  "producerCount"?: number;
  "topics"?: number;
  "cacheSize"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "msgRateIn",
      baseName: "msgRateIn",
      type: "number",
    },
    {
      name: "msgThroughputIn",
      baseName: "msgThroughputIn",
      type: "number",
    },
    {
      name: "msgRateOut",
      baseName: "msgRateOut",
      type: "number",
    },
    {
      name: "msgThroughputOut",
      baseName: "msgThroughputOut",
      type: "number",
    },
    {
      name: "consumerCount",
      baseName: "consumerCount",
      type: "number",
    },
    {
      name: "producerCount",
      baseName: "producerCount",
      type: "number",
    },
    {
      name: "topics",
      baseName: "topics",
      type: "number",
    },
    {
      name: "cacheSize",
      baseName: "cacheSize",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return NamespaceBundleStats.attributeTypeMap;
  }
}

/**
 * The data of namespace isolation configuration
 */
export class NamespaceIsolationData {
  /**
   * The list of namespaces to apply this namespace isolation data
   */
  "namespaces"?: Array<string>;
  /**
   * The list of primary brokers for serving the list of namespaces in this isolation policy
   */
  "primary"?: Array<string>;
  /**
   * The list of secondary brokers for serving the list of namespaces in this isolation policy
   */
  "secondary"?: Array<string>;
  /**
   * The data of auto-failover policy configuration
   */
  "autoFailoverPolicy"?: AutoFailoverPolicyData;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "namespaces",
      baseName: "namespaces",
      type: "Array<string>",
    },
    {
      name: "primary",
      baseName: "primary",
      type: "Array<string>",
    },
    {
      name: "secondary",
      baseName: "secondary",
      type: "Array<string>",
    },
    {
      name: "autoFailoverPolicy",
      baseName: "auto_failover_policy",
      type: "AutoFailoverPolicyData",
    },
  ];

  static getAttributeTypeMap() {
    return NamespaceIsolationData.attributeTypeMap;
  }
}

export class NamespaceOwnershipStatus {
  "brokerAssignment"?: NamespaceOwnershipStatus.BrokerAssignmentEnum;
  "isControlled"?: boolean;
  "isActive"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "brokerAssignment",
      baseName: "broker_assignment",
      type: "NamespaceOwnershipStatus.BrokerAssignmentEnum",
    },
    {
      name: "isControlled",
      baseName: "is_controlled",
      type: "boolean",
    },
    {
      name: "isActive",
      baseName: "is_active",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return NamespaceOwnershipStatus.attributeTypeMap;
  }
}

export namespace NamespaceOwnershipStatus {
  export enum BrokerAssignmentEnum {
    Primary = <any>"primary",
    Secondary = <any>"secondary",
    Shared = <any>"shared",
  }
}
export class Number {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return Number.attributeTypeMap;
  }
}

export class NumberFormat {
  "groupingUsed"?: boolean;
  "parseIntegerOnly"?: boolean;
  "maximumIntegerDigits"?: number;
  "minimumIntegerDigits"?: number;
  "maximumFractionDigits"?: number;
  "minimumFractionDigits"?: number;
  "roundingMode"?: NumberFormat.RoundingModeEnum;
  "currency"?: Currency;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "groupingUsed",
      baseName: "groupingUsed",
      type: "boolean",
    },
    {
      name: "parseIntegerOnly",
      baseName: "parseIntegerOnly",
      type: "boolean",
    },
    {
      name: "maximumIntegerDigits",
      baseName: "maximumIntegerDigits",
      type: "number",
    },
    {
      name: "minimumIntegerDigits",
      baseName: "minimumIntegerDigits",
      type: "number",
    },
    {
      name: "maximumFractionDigits",
      baseName: "maximumFractionDigits",
      type: "number",
    },
    {
      name: "minimumFractionDigits",
      baseName: "minimumFractionDigits",
      type: "number",
    },
    {
      name: "roundingMode",
      baseName: "roundingMode",
      type: "NumberFormat.RoundingModeEnum",
    },
    {
      name: "currency",
      baseName: "currency",
      type: "Currency",
    },
  ];

  static getAttributeTypeMap() {
    return NumberFormat.attributeTypeMap;
  }
}

export namespace NumberFormat {
  export enum RoundingModeEnum {
    UP = <any>"UP",
    DOWN = <any>"DOWN",
    CEILING = <any>"CEILING",
    FLOOR = <any>"FLOOR",
    HALFUP = <any>"HALF_UP",
    HALFDOWN = <any>"HALF_DOWN",
    HALFEVEN = <any>"HALF_EVEN",
    UNNECESSARY = <any>"UNNECESSARY",
  }
}
export class ObjectCodec {
  "factory"?: JsonFactory;
  "jsonFactory"?: JsonFactory;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "factory",
      baseName: "factory",
      type: "JsonFactory",
    },
    {
      name: "jsonFactory",
      baseName: "jsonFactory",
      type: "JsonFactory",
    },
  ];

  static getAttributeTypeMap() {
    return ObjectCodec.attributeTypeMap;
  }
}

export class ObjectMapper {
  "factory"?: JsonFactory;
  "typeFactory"?: TypeFactory;
  "serializationConfig"?: SerializationConfig;
  "deserializationConfig"?: DeserializationConfig;
  "deserializationContext"?: DeserializationContext;
  "serializerFactory"?: SerializerFactory;
  "serializerProvider"?: SerializerProvider;
  "serializerProviderInstance"?: SerializerProvider;
  "visibilityChecker"?: VisibilityCheckerObject;
  "subtypeResolver"?: SubtypeResolver;
  "propertyNamingStrategy"?: PropertyNamingStrategy;
  "nodeFactory"?: JsonNodeFactory;
  "jsonFactory"?: JsonFactory;
  "dateFormat"?: DateFormat;
  "injectableValues"?: InjectableValues;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "factory",
      baseName: "factory",
      type: "JsonFactory",
    },
    {
      name: "typeFactory",
      baseName: "typeFactory",
      type: "TypeFactory",
    },
    {
      name: "serializationConfig",
      baseName: "serializationConfig",
      type: "SerializationConfig",
    },
    {
      name: "deserializationConfig",
      baseName: "deserializationConfig",
      type: "DeserializationConfig",
    },
    {
      name: "deserializationContext",
      baseName: "deserializationContext",
      type: "DeserializationContext",
    },
    {
      name: "serializerFactory",
      baseName: "serializerFactory",
      type: "SerializerFactory",
    },
    {
      name: "serializerProvider",
      baseName: "serializerProvider",
      type: "SerializerProvider",
    },
    {
      name: "serializerProviderInstance",
      baseName: "serializerProviderInstance",
      type: "SerializerProvider",
    },
    {
      name: "visibilityChecker",
      baseName: "visibilityChecker",
      type: "VisibilityCheckerObject",
    },
    {
      name: "subtypeResolver",
      baseName: "subtypeResolver",
      type: "SubtypeResolver",
    },
    {
      name: "propertyNamingStrategy",
      baseName: "propertyNamingStrategy",
      type: "PropertyNamingStrategy",
    },
    {
      name: "nodeFactory",
      baseName: "nodeFactory",
      type: "JsonNodeFactory",
    },
    {
      name: "jsonFactory",
      baseName: "jsonFactory",
      type: "JsonFactory",
    },
    {
      name: "dateFormat",
      baseName: "dateFormat",
      type: "DateFormat",
    },
    {
      name: "injectableValues",
      baseName: "injectableValues",
      type: "InjectableValues",
    },
  ];

  static getAttributeTypeMap() {
    return ObjectMapper.attributeTypeMap;
  }
}

export class OffloadPolicies {
  "managedLedgerOffloadPrefetchRounds"?: number;
  "managedLedgerOffloadDriver"?: string;
  "offloadersDirectory"?: string;
  "managedLedgerOffloadMaxThreads"?: number;
  "managedLedgerOffloadThresholdInBytes"?: number;
  "managedLedgerOffloadDeletionLagInMillis"?: number;
  "managedLedgerOffloadedReadPriority"?: OffloadPolicies.ManagedLedgerOffloadedReadPriorityEnum;
  "s3ManagedLedgerOffloadRegion"?: string;
  "s3ManagedLedgerOffloadBucket"?: string;
  "s3ManagedLedgerOffloadServiceEndpoint"?: string;
  "s3ManagedLedgerOffloadMaxBlockSizeInBytes"?: number;
  "s3ManagedLedgerOffloadCredentialId"?: string;
  "s3ManagedLedgerOffloadCredentialSecret"?: string;
  "s3ManagedLedgerOffloadRole"?: string;
  "s3ManagedLedgerOffloadRoleSessionName"?: string;
  "s3ManagedLedgerOffloadReadBufferSizeInBytes"?: number;
  "gcsManagedLedgerOffloadRegion"?: string;
  "gcsManagedLedgerOffloadBucket"?: string;
  "gcsManagedLedgerOffloadMaxBlockSizeInBytes"?: number;
  "gcsManagedLedgerOffloadReadBufferSizeInBytes"?: number;
  "gcsManagedLedgerOffloadServiceAccountKeyFile"?: string;
  "fileSystemProfilePath"?: string;
  "fileSystemURI"?: string;
  "managedLedgerOffloadBucket"?: string;
  "managedLedgerOffloadRegion"?: string;
  "managedLedgerOffloadServiceEndpoint"?: string;
  "managedLedgerOffloadMaxBlockSizeInBytes"?: number;
  "managedLedgerOffloadReadBufferSizeInBytes"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "managedLedgerOffloadPrefetchRounds",
      baseName: "managedLedgerOffloadPrefetchRounds",
      type: "number",
    },
    {
      name: "managedLedgerOffloadDriver",
      baseName: "managedLedgerOffloadDriver",
      type: "string",
    },
    {
      name: "offloadersDirectory",
      baseName: "offloadersDirectory",
      type: "string",
    },
    {
      name: "managedLedgerOffloadMaxThreads",
      baseName: "managedLedgerOffloadMaxThreads",
      type: "number",
    },
    {
      name: "managedLedgerOffloadThresholdInBytes",
      baseName: "managedLedgerOffloadThresholdInBytes",
      type: "number",
    },
    {
      name: "managedLedgerOffloadDeletionLagInMillis",
      baseName: "managedLedgerOffloadDeletionLagInMillis",
      type: "number",
    },
    {
      name: "managedLedgerOffloadedReadPriority",
      baseName: "managedLedgerOffloadedReadPriority",
      type: "OffloadPolicies.ManagedLedgerOffloadedReadPriorityEnum",
    },
    {
      name: "s3ManagedLedgerOffloadRegion",
      baseName: "s3ManagedLedgerOffloadRegion",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadBucket",
      baseName: "s3ManagedLedgerOffloadBucket",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadServiceEndpoint",
      baseName: "s3ManagedLedgerOffloadServiceEndpoint",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadMaxBlockSizeInBytes",
      baseName: "s3ManagedLedgerOffloadMaxBlockSizeInBytes",
      type: "number",
    },
    {
      name: "s3ManagedLedgerOffloadCredentialId",
      baseName: "s3ManagedLedgerOffloadCredentialId",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadCredentialSecret",
      baseName: "s3ManagedLedgerOffloadCredentialSecret",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadRole",
      baseName: "s3ManagedLedgerOffloadRole",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadRoleSessionName",
      baseName: "s3ManagedLedgerOffloadRoleSessionName",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadReadBufferSizeInBytes",
      baseName: "s3ManagedLedgerOffloadReadBufferSizeInBytes",
      type: "number",
    },
    {
      name: "gcsManagedLedgerOffloadRegion",
      baseName: "gcsManagedLedgerOffloadRegion",
      type: "string",
    },
    {
      name: "gcsManagedLedgerOffloadBucket",
      baseName: "gcsManagedLedgerOffloadBucket",
      type: "string",
    },
    {
      name: "gcsManagedLedgerOffloadMaxBlockSizeInBytes",
      baseName: "gcsManagedLedgerOffloadMaxBlockSizeInBytes",
      type: "number",
    },
    {
      name: "gcsManagedLedgerOffloadReadBufferSizeInBytes",
      baseName: "gcsManagedLedgerOffloadReadBufferSizeInBytes",
      type: "number",
    },
    {
      name: "gcsManagedLedgerOffloadServiceAccountKeyFile",
      baseName: "gcsManagedLedgerOffloadServiceAccountKeyFile",
      type: "string",
    },
    {
      name: "fileSystemProfilePath",
      baseName: "fileSystemProfilePath",
      type: "string",
    },
    {
      name: "fileSystemURI",
      baseName: "fileSystemURI",
      type: "string",
    },
    {
      name: "managedLedgerOffloadBucket",
      baseName: "managedLedgerOffloadBucket",
      type: "string",
    },
    {
      name: "managedLedgerOffloadRegion",
      baseName: "managedLedgerOffloadRegion",
      type: "string",
    },
    {
      name: "managedLedgerOffloadServiceEndpoint",
      baseName: "managedLedgerOffloadServiceEndpoint",
      type: "string",
    },
    {
      name: "managedLedgerOffloadMaxBlockSizeInBytes",
      baseName: "managedLedgerOffloadMaxBlockSizeInBytes",
      type: "number",
    },
    {
      name: "managedLedgerOffloadReadBufferSizeInBytes",
      baseName: "managedLedgerOffloadReadBufferSizeInBytes",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return OffloadPolicies.attributeTypeMap;
  }
}

export namespace OffloadPolicies {
  export enum ManagedLedgerOffloadedReadPriorityEnum {
    BOOKKEEPERFIRST = <any>"BOOKKEEPER_FIRST",
    TIEREDSTORAGEFIRST = <any>"TIERED_STORAGE_FIRST",
  }
}
export class OffloadPoliciesImpl {
  "offloadersDirectory"?: string;
  "managedLedgerOffloadDriver"?: string;
  "managedLedgerOffloadMaxThreads"?: number;
  "managedLedgerOffloadPrefetchRounds"?: number;
  "managedLedgerOffloadThresholdInBytes"?: number;
  "managedLedgerOffloadDeletionLagInMillis"?: number;
  "managedLedgerOffloadedReadPriority"?: OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriorityEnum;
  "s3ManagedLedgerOffloadRegion"?: string;
  "s3ManagedLedgerOffloadBucket"?: string;
  "s3ManagedLedgerOffloadServiceEndpoint"?: string;
  "s3ManagedLedgerOffloadMaxBlockSizeInBytes"?: number;
  "s3ManagedLedgerOffloadReadBufferSizeInBytes"?: number;
  "s3ManagedLedgerOffloadCredentialId"?: string;
  "s3ManagedLedgerOffloadCredentialSecret"?: string;
  "s3ManagedLedgerOffloadRole"?: string;
  "s3ManagedLedgerOffloadRoleSessionName"?: string;
  "gcsManagedLedgerOffloadRegion"?: string;
  "gcsManagedLedgerOffloadBucket"?: string;
  "gcsManagedLedgerOffloadMaxBlockSizeInBytes"?: number;
  "gcsManagedLedgerOffloadReadBufferSizeInBytes"?: number;
  "gcsManagedLedgerOffloadServiceAccountKeyFile"?: string;
  "fileSystemProfilePath"?: string;
  "fileSystemURI"?: string;
  "managedLedgerOffloadBucket"?: string;
  "managedLedgerOffloadRegion"?: string;
  "managedLedgerOffloadServiceEndpoint"?: string;
  "managedLedgerOffloadMaxBlockSizeInBytes"?: number;
  "managedLedgerOffloadReadBufferSizeInBytes"?: number;
  "s3Driver"?: boolean;
  "gcsDriver"?: boolean;
  "fileSystemDriver"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "offloadersDirectory",
      baseName: "offloadersDirectory",
      type: "string",
    },
    {
      name: "managedLedgerOffloadDriver",
      baseName: "managedLedgerOffloadDriver",
      type: "string",
    },
    {
      name: "managedLedgerOffloadMaxThreads",
      baseName: "managedLedgerOffloadMaxThreads",
      type: "number",
    },
    {
      name: "managedLedgerOffloadPrefetchRounds",
      baseName: "managedLedgerOffloadPrefetchRounds",
      type: "number",
    },
    {
      name: "managedLedgerOffloadThresholdInBytes",
      baseName: "managedLedgerOffloadThresholdInBytes",
      type: "number",
    },
    {
      name: "managedLedgerOffloadDeletionLagInMillis",
      baseName: "managedLedgerOffloadDeletionLagInMillis",
      type: "number",
    },
    {
      name: "managedLedgerOffloadedReadPriority",
      baseName: "managedLedgerOffloadedReadPriority",
      type: "OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriorityEnum",
    },
    {
      name: "s3ManagedLedgerOffloadRegion",
      baseName: "s3ManagedLedgerOffloadRegion",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadBucket",
      baseName: "s3ManagedLedgerOffloadBucket",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadServiceEndpoint",
      baseName: "s3ManagedLedgerOffloadServiceEndpoint",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadMaxBlockSizeInBytes",
      baseName: "s3ManagedLedgerOffloadMaxBlockSizeInBytes",
      type: "number",
    },
    {
      name: "s3ManagedLedgerOffloadReadBufferSizeInBytes",
      baseName: "s3ManagedLedgerOffloadReadBufferSizeInBytes",
      type: "number",
    },
    {
      name: "s3ManagedLedgerOffloadCredentialId",
      baseName: "s3ManagedLedgerOffloadCredentialId",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadCredentialSecret",
      baseName: "s3ManagedLedgerOffloadCredentialSecret",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadRole",
      baseName: "s3ManagedLedgerOffloadRole",
      type: "string",
    },
    {
      name: "s3ManagedLedgerOffloadRoleSessionName",
      baseName: "s3ManagedLedgerOffloadRoleSessionName",
      type: "string",
    },
    {
      name: "gcsManagedLedgerOffloadRegion",
      baseName: "gcsManagedLedgerOffloadRegion",
      type: "string",
    },
    {
      name: "gcsManagedLedgerOffloadBucket",
      baseName: "gcsManagedLedgerOffloadBucket",
      type: "string",
    },
    {
      name: "gcsManagedLedgerOffloadMaxBlockSizeInBytes",
      baseName: "gcsManagedLedgerOffloadMaxBlockSizeInBytes",
      type: "number",
    },
    {
      name: "gcsManagedLedgerOffloadReadBufferSizeInBytes",
      baseName: "gcsManagedLedgerOffloadReadBufferSizeInBytes",
      type: "number",
    },
    {
      name: "gcsManagedLedgerOffloadServiceAccountKeyFile",
      baseName: "gcsManagedLedgerOffloadServiceAccountKeyFile",
      type: "string",
    },
    {
      name: "fileSystemProfilePath",
      baseName: "fileSystemProfilePath",
      type: "string",
    },
    {
      name: "fileSystemURI",
      baseName: "fileSystemURI",
      type: "string",
    },
    {
      name: "managedLedgerOffloadBucket",
      baseName: "managedLedgerOffloadBucket",
      type: "string",
    },
    {
      name: "managedLedgerOffloadRegion",
      baseName: "managedLedgerOffloadRegion",
      type: "string",
    },
    {
      name: "managedLedgerOffloadServiceEndpoint",
      baseName: "managedLedgerOffloadServiceEndpoint",
      type: "string",
    },
    {
      name: "managedLedgerOffloadMaxBlockSizeInBytes",
      baseName: "managedLedgerOffloadMaxBlockSizeInBytes",
      type: "number",
    },
    {
      name: "managedLedgerOffloadReadBufferSizeInBytes",
      baseName: "managedLedgerOffloadReadBufferSizeInBytes",
      type: "number",
    },
    {
      name: "s3Driver",
      baseName: "s3Driver",
      type: "boolean",
    },
    {
      name: "gcsDriver",
      baseName: "gcsDriver",
      type: "boolean",
    },
    {
      name: "fileSystemDriver",
      baseName: "fileSystemDriver",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return OffloadPoliciesImpl.attributeTypeMap;
  }
}

export namespace OffloadPoliciesImpl {
  export enum ManagedLedgerOffloadedReadPriorityEnum {
    BOOKKEEPERFIRST = <any>"BOOKKEEPER_FIRST",
    TIEREDSTORAGEFIRST = <any>"TIERED_STORAGE_FIRST",
  }
}
export class OutputDecorator {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return OutputDecorator.attributeTypeMap;
  }
}

export class OutputStream {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return OutputStream.attributeTypeMap;
  }
}

export class PartitionedTopicMetadata {
  "partitions"?: number;
  "properties"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "partitions",
      baseName: "partitions",
      type: "number",
    },
    {
      name: "properties",
      baseName: "properties",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return PartitionedTopicMetadata.attributeTypeMap;
  }
}

export class PendingBookieOpsStats {
  "dataLedgerOpenOp"?: number;
  "dataLedgerCloseOp"?: number;
  "dataLedgerCreateOp"?: number;
  "dataLedgerDeleteOp"?: number;
  "cursorLedgerOpenOp"?: number;
  "cursorLedgerCloseOp"?: number;
  "cursorLedgerCreateOp"?: number;
  "cursorLedgerDeleteOp"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "dataLedgerOpenOp",
      baseName: "dataLedgerOpenOp",
      type: "number",
    },
    {
      name: "dataLedgerCloseOp",
      baseName: "dataLedgerCloseOp",
      type: "number",
    },
    {
      name: "dataLedgerCreateOp",
      baseName: "dataLedgerCreateOp",
      type: "number",
    },
    {
      name: "dataLedgerDeleteOp",
      baseName: "dataLedgerDeleteOp",
      type: "number",
    },
    {
      name: "cursorLedgerOpenOp",
      baseName: "cursorLedgerOpenOp",
      type: "number",
    },
    {
      name: "cursorLedgerCloseOp",
      baseName: "cursorLedgerCloseOp",
      type: "number",
    },
    {
      name: "cursorLedgerCreateOp",
      baseName: "cursorLedgerCreateOp",
      type: "number",
    },
    {
      name: "cursorLedgerDeleteOp",
      baseName: "cursorLedgerDeleteOp",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return PendingBookieOpsStats.attributeTypeMap;
  }
}

export class PersistencePolicies {
  "bookkeeperEnsemble"?: number;
  "bookkeeperWriteQuorum"?: number;
  "bookkeeperAckQuorum"?: number;
  "managedLedgerMaxMarkDeleteRate"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "bookkeeperEnsemble",
      baseName: "bookkeeperEnsemble",
      type: "number",
    },
    {
      name: "bookkeeperWriteQuorum",
      baseName: "bookkeeperWriteQuorum",
      type: "number",
    },
    {
      name: "bookkeeperAckQuorum",
      baseName: "bookkeeperAckQuorum",
      type: "number",
    },
    {
      name: "managedLedgerMaxMarkDeleteRate",
      baseName: "managedLedgerMaxMarkDeleteRate",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return PersistencePolicies.attributeTypeMap;
  }
}

export class PersistentOfflineTopicStats {
  "storageSize"?: number;
  "totalMessages"?: number;
  "messageBacklog"?: number;
  "brokerName"?: string;
  "topicName"?: string;
  "dataLedgerDetails"?: Array<LedgerDetails>;
  "cursorDetails"?: { [key: string]: CursorDetails };
  "statGeneratedAt"?: Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "storageSize",
      baseName: "storageSize",
      type: "number",
    },
    {
      name: "totalMessages",
      baseName: "totalMessages",
      type: "number",
    },
    {
      name: "messageBacklog",
      baseName: "messageBacklog",
      type: "number",
    },
    {
      name: "brokerName",
      baseName: "brokerName",
      type: "string",
    },
    {
      name: "topicName",
      baseName: "topicName",
      type: "string",
    },
    {
      name: "dataLedgerDetails",
      baseName: "dataLedgerDetails",
      type: "Array<LedgerDetails>",
    },
    {
      name: "cursorDetails",
      baseName: "cursorDetails",
      type: "{ [key: string]: CursorDetails; }",
    },
    {
      name: "statGeneratedAt",
      baseName: "statGeneratedAt",
      type: "Date",
    },
  ];

  static getAttributeTypeMap() {
    return PersistentOfflineTopicStats.attributeTypeMap;
  }
}

export class PersistentTopicInternalStats {
  "entriesAddedCounter"?: number;
  "numberOfEntries"?: number;
  "totalSize"?: number;
  "currentLedgerEntries"?: number;
  "currentLedgerSize"?: number;
  "lastLedgerCreatedTimestamp"?: string;
  "lastLedgerCreationFailureTimestamp"?: string;
  "waitingCursorsCount"?: number;
  "pendingAddEntriesCount"?: number;
  "lastConfirmedEntry"?: string;
  "state"?: string;
  "ledgers"?: Array<LedgerInfo>;
  "cursors"?: { [key: string]: CursorStats };
  "schemaLedgers"?: Array<LedgerInfo>;
  "compactedLedger"?: LedgerInfo;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "entriesAddedCounter",
      baseName: "entriesAddedCounter",
      type: "number",
    },
    {
      name: "numberOfEntries",
      baseName: "numberOfEntries",
      type: "number",
    },
    {
      name: "totalSize",
      baseName: "totalSize",
      type: "number",
    },
    {
      name: "currentLedgerEntries",
      baseName: "currentLedgerEntries",
      type: "number",
    },
    {
      name: "currentLedgerSize",
      baseName: "currentLedgerSize",
      type: "number",
    },
    {
      name: "lastLedgerCreatedTimestamp",
      baseName: "lastLedgerCreatedTimestamp",
      type: "string",
    },
    {
      name: "lastLedgerCreationFailureTimestamp",
      baseName: "lastLedgerCreationFailureTimestamp",
      type: "string",
    },
    {
      name: "waitingCursorsCount",
      baseName: "waitingCursorsCount",
      type: "number",
    },
    {
      name: "pendingAddEntriesCount",
      baseName: "pendingAddEntriesCount",
      type: "number",
    },
    {
      name: "lastConfirmedEntry",
      baseName: "lastConfirmedEntry",
      type: "string",
    },
    {
      name: "state",
      baseName: "state",
      type: "string",
    },
    {
      name: "ledgers",
      baseName: "ledgers",
      type: "Array<LedgerInfo>",
    },
    {
      name: "cursors",
      baseName: "cursors",
      type: "{ [key: string]: CursorStats; }",
    },
    {
      name: "schemaLedgers",
      baseName: "schemaLedgers",
      type: "Array<LedgerInfo>",
    },
    {
      name: "compactedLedger",
      baseName: "compactedLedger",
      type: "LedgerInfo",
    },
  ];

  static getAttributeTypeMap() {
    return PersistentTopicInternalStats.attributeTypeMap;
  }
}

export class Policies {
  "authPolicies"?: AuthPolicies;
  "replicationClusters"?: Array<string>;
  "bundles"?: BundlesData;
  "backlogQuotaMap"?: { [key: string]: BacklogQuota };
  "clusterDispatchRate"?: { [key: string]: DispatchRateImpl };
  "topicDispatchRate"?: { [key: string]: DispatchRateImpl };
  "subscriptionDispatchRate"?: { [key: string]: DispatchRateImpl };
  "replicatorDispatchRate"?: { [key: string]: DispatchRateImpl };
  "clusterSubscribeRate"?: { [key: string]: SubscribeRate };
  "persistence"?: PersistencePolicies;
  "deduplicationEnabled"?: boolean;
  "autoTopicCreationOverride"?: AutoTopicCreationOverride;
  "autoSubscriptionCreationOverride"?: AutoSubscriptionCreationOverride;
  "publishMaxMessageRate"?: { [key: string]: PublishRate };
  "latencyStatsSampleRate"?: { [key: string]: number };
  "messageTtlInSeconds"?: number;
  "subscriptionExpirationTimeMinutes"?: number;
  "retentionPolicies"?: RetentionPolicies;
  "deleted"?: boolean;
  "encryptionRequired"?: boolean;
  "delayedDeliveryPolicies"?: DelayedDeliveryPolicies;
  "inactiveTopicPolicies"?: InactiveTopicPolicies;
  "subscriptionAuthMode"?: Policies.SubscriptionAuthModeEnum;
  "maxProducersPerTopic"?: number;
  "maxConsumersPerTopic"?: number;
  "maxConsumersPerSubscription"?: number;
  "maxUnackedMessagesPerConsumer"?: number;
  "maxUnackedMessagesPerSubscription"?: number;
  "maxSubscriptionsPerTopic"?: number;
  "compactionThreshold"?: number;
  "offloadThreshold"?: number;
  "offloadDeletionLagMs"?: number;
  "maxTopicsPerNamespace"?: number;
  "schemaAutoUpdateCompatibilityStrategy"?: Policies.SchemaAutoUpdateCompatibilityStrategyEnum;
  "schemaCompatibilityStrategy"?: Policies.SchemaCompatibilityStrategyEnum;
  "isAllowAutoUpdateSchema"?: boolean;
  "schemaValidationEnforced"?: boolean;
  "offloadPolicies"?: OffloadPolicies;
  "deduplicationSnapshotIntervalSeconds"?: number;
  "subscriptionTypesEnabled"?: Array<string>;
  "properties"?: { [key: string]: string };
  "resourceGroupName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "authPolicies",
      baseName: "auth_policies",
      type: "AuthPolicies",
    },
    {
      name: "replicationClusters",
      baseName: "replication_clusters",
      type: "Array<string>",
    },
    {
      name: "bundles",
      baseName: "bundles",
      type: "BundlesData",
    },
    {
      name: "backlogQuotaMap",
      baseName: "backlog_quota_map",
      type: "{ [key: string]: BacklogQuota; }",
    },
    {
      name: "clusterDispatchRate",
      baseName: "clusterDispatchRate",
      type: "{ [key: string]: DispatchRateImpl; }",
    },
    {
      name: "topicDispatchRate",
      baseName: "topicDispatchRate",
      type: "{ [key: string]: DispatchRateImpl; }",
    },
    {
      name: "subscriptionDispatchRate",
      baseName: "subscriptionDispatchRate",
      type: "{ [key: string]: DispatchRateImpl; }",
    },
    {
      name: "replicatorDispatchRate",
      baseName: "replicatorDispatchRate",
      type: "{ [key: string]: DispatchRateImpl; }",
    },
    {
      name: "clusterSubscribeRate",
      baseName: "clusterSubscribeRate",
      type: "{ [key: string]: SubscribeRate; }",
    },
    {
      name: "persistence",
      baseName: "persistence",
      type: "PersistencePolicies",
    },
    {
      name: "deduplicationEnabled",
      baseName: "deduplicationEnabled",
      type: "boolean",
    },
    {
      name: "autoTopicCreationOverride",
      baseName: "autoTopicCreationOverride",
      type: "AutoTopicCreationOverride",
    },
    {
      name: "autoSubscriptionCreationOverride",
      baseName: "autoSubscriptionCreationOverride",
      type: "AutoSubscriptionCreationOverride",
    },
    {
      name: "publishMaxMessageRate",
      baseName: "publishMaxMessageRate",
      type: "{ [key: string]: PublishRate; }",
    },
    {
      name: "latencyStatsSampleRate",
      baseName: "latency_stats_sample_rate",
      type: "{ [key: string]: number; }",
    },
    {
      name: "messageTtlInSeconds",
      baseName: "message_ttl_in_seconds",
      type: "number",
    },
    {
      name: "subscriptionExpirationTimeMinutes",
      baseName: "subscription_expiration_time_minutes",
      type: "number",
    },
    {
      name: "retentionPolicies",
      baseName: "retention_policies",
      type: "RetentionPolicies",
    },
    {
      name: "deleted",
      baseName: "deleted",
      type: "boolean",
    },
    {
      name: "encryptionRequired",
      baseName: "encryption_required",
      type: "boolean",
    },
    {
      name: "delayedDeliveryPolicies",
      baseName: "delayed_delivery_policies",
      type: "DelayedDeliveryPolicies",
    },
    {
      name: "inactiveTopicPolicies",
      baseName: "inactive_topic_policies",
      type: "InactiveTopicPolicies",
    },
    {
      name: "subscriptionAuthMode",
      baseName: "subscription_auth_mode",
      type: "Policies.SubscriptionAuthModeEnum",
    },
    {
      name: "maxProducersPerTopic",
      baseName: "max_producers_per_topic",
      type: "number",
    },
    {
      name: "maxConsumersPerTopic",
      baseName: "max_consumers_per_topic",
      type: "number",
    },
    {
      name: "maxConsumersPerSubscription",
      baseName: "max_consumers_per_subscription",
      type: "number",
    },
    {
      name: "maxUnackedMessagesPerConsumer",
      baseName: "max_unacked_messages_per_consumer",
      type: "number",
    },
    {
      name: "maxUnackedMessagesPerSubscription",
      baseName: "max_unacked_messages_per_subscription",
      type: "number",
    },
    {
      name: "maxSubscriptionsPerTopic",
      baseName: "max_subscriptions_per_topic",
      type: "number",
    },
    {
      name: "compactionThreshold",
      baseName: "compaction_threshold",
      type: "number",
    },
    {
      name: "offloadThreshold",
      baseName: "offload_threshold",
      type: "number",
    },
    {
      name: "offloadDeletionLagMs",
      baseName: "offload_deletion_lag_ms",
      type: "number",
    },
    {
      name: "maxTopicsPerNamespace",
      baseName: "max_topics_per_namespace",
      type: "number",
    },
    {
      name: "schemaAutoUpdateCompatibilityStrategy",
      baseName: "schema_auto_update_compatibility_strategy",
      type: "Policies.SchemaAutoUpdateCompatibilityStrategyEnum",
    },
    {
      name: "schemaCompatibilityStrategy",
      baseName: "schema_compatibility_strategy",
      type: "Policies.SchemaCompatibilityStrategyEnum",
    },
    {
      name: "isAllowAutoUpdateSchema",
      baseName: "is_allow_auto_update_schema",
      type: "boolean",
    },
    {
      name: "schemaValidationEnforced",
      baseName: "schema_validation_enforced",
      type: "boolean",
    },
    {
      name: "offloadPolicies",
      baseName: "offload_policies",
      type: "OffloadPolicies",
    },
    {
      name: "deduplicationSnapshotIntervalSeconds",
      baseName: "deduplicationSnapshotIntervalSeconds",
      type: "number",
    },
    {
      name: "subscriptionTypesEnabled",
      baseName: "subscription_types_enabled",
      type: "Array<string>",
    },
    {
      name: "properties",
      baseName: "properties",
      type: "{ [key: string]: string; }",
    },
    {
      name: "resourceGroupName",
      baseName: "resource_group_name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Policies.attributeTypeMap;
  }
}

export namespace Policies {
  export enum SubscriptionAuthModeEnum {
    None = <any>"None",
    Prefix = <any>"Prefix",
  }
  export enum SchemaAutoUpdateCompatibilityStrategyEnum {
    AutoUpdateDisabled = <any>"AutoUpdateDisabled",
    Backward = <any>"Backward",
    Forward = <any>"Forward",
    Full = <any>"Full",
    AlwaysCompatible = <any>"AlwaysCompatible",
    BackwardTransitive = <any>"BackwardTransitive",
    ForwardTransitive = <any>"ForwardTransitive",
    FullTransitive = <any>"FullTransitive",
  }
  export enum SchemaCompatibilityStrategyEnum {
    UNDEFINED = <any>"UNDEFINED",
    ALWAYSINCOMPATIBLE = <any>"ALWAYS_INCOMPATIBLE",
    ALWAYSCOMPATIBLE = <any>"ALWAYS_COMPATIBLE",
    BACKWARD = <any>"BACKWARD",
    FORWARD = <any>"FORWARD",
    FULL = <any>"FULL",
    BACKWARDTRANSITIVE = <any>"BACKWARD_TRANSITIVE",
    FORWARDTRANSITIVE = <any>"FORWARD_TRANSITIVE",
    FULLTRANSITIVE = <any>"FULL_TRANSITIVE",
  }
}
export class PoolArenaStats {
  "numSmallSubpages"?: number;
  "numChunkLists"?: number;
  "smallSubpages"?: Array<PoolSubpageStats>;
  "chunkLists"?: Array<PoolChunkListStats>;
  "numAllocations"?: number;
  "numSmallAllocations"?: number;
  "numNormalAllocations"?: number;
  "numHugeAllocations"?: number;
  "numDeallocations"?: number;
  "numSmallDeallocations"?: number;
  "numNormalDeallocations"?: number;
  "numHugeDeallocations"?: number;
  "numActiveAllocations"?: number;
  "numActiveSmallAllocations"?: number;
  "numActiveNormalAllocations"?: number;
  "numActiveHugeAllocations"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "numSmallSubpages",
      baseName: "numSmallSubpages",
      type: "number",
    },
    {
      name: "numChunkLists",
      baseName: "numChunkLists",
      type: "number",
    },
    {
      name: "smallSubpages",
      baseName: "smallSubpages",
      type: "Array<PoolSubpageStats>",
    },
    {
      name: "chunkLists",
      baseName: "chunkLists",
      type: "Array<PoolChunkListStats>",
    },
    {
      name: "numAllocations",
      baseName: "numAllocations",
      type: "number",
    },
    {
      name: "numSmallAllocations",
      baseName: "numSmallAllocations",
      type: "number",
    },
    {
      name: "numNormalAllocations",
      baseName: "numNormalAllocations",
      type: "number",
    },
    {
      name: "numHugeAllocations",
      baseName: "numHugeAllocations",
      type: "number",
    },
    {
      name: "numDeallocations",
      baseName: "numDeallocations",
      type: "number",
    },
    {
      name: "numSmallDeallocations",
      baseName: "numSmallDeallocations",
      type: "number",
    },
    {
      name: "numNormalDeallocations",
      baseName: "numNormalDeallocations",
      type: "number",
    },
    {
      name: "numHugeDeallocations",
      baseName: "numHugeDeallocations",
      type: "number",
    },
    {
      name: "numActiveAllocations",
      baseName: "numActiveAllocations",
      type: "number",
    },
    {
      name: "numActiveSmallAllocations",
      baseName: "numActiveSmallAllocations",
      type: "number",
    },
    {
      name: "numActiveNormalAllocations",
      baseName: "numActiveNormalAllocations",
      type: "number",
    },
    {
      name: "numActiveHugeAllocations",
      baseName: "numActiveHugeAllocations",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return PoolArenaStats.attributeTypeMap;
  }
}

export class PoolChunkListStats {
  "minUsage"?: number;
  "maxUsage"?: number;
  "chunks"?: Array<PoolChunkStats>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "minUsage",
      baseName: "minUsage",
      type: "number",
    },
    {
      name: "maxUsage",
      baseName: "maxUsage",
      type: "number",
    },
    {
      name: "chunks",
      baseName: "chunks",
      type: "Array<PoolChunkStats>",
    },
  ];

  static getAttributeTypeMap() {
    return PoolChunkListStats.attributeTypeMap;
  }
}

export class PoolChunkStats {
  "usage"?: number;
  "chunkSize"?: number;
  "freeBytes"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "usage",
      baseName: "usage",
      type: "number",
    },
    {
      name: "chunkSize",
      baseName: "chunkSize",
      type: "number",
    },
    {
      name: "freeBytes",
      baseName: "freeBytes",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return PoolChunkStats.attributeTypeMap;
  }
}

export class PoolSubpageStats {
  "maxNumElements"?: number;
  "numAvailable"?: number;
  "elementSize"?: number;
  "pageSize"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "maxNumElements",
      baseName: "maxNumElements",
      type: "number",
    },
    {
      name: "numAvailable",
      baseName: "numAvailable",
      type: "number",
    },
    {
      name: "elementSize",
      baseName: "elementSize",
      type: "number",
    },
    {
      name: "pageSize",
      baseName: "pageSize",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return PoolSubpageStats.attributeTypeMap;
  }
}

export class PostSchemaPayload {
  "type"?: string;
  "schema"?: string;
  "properties"?: { [key: string]: string };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "string",
    },
    {
      name: "schema",
      baseName: "schema",
      type: "string",
    },
    {
      name: "properties",
      baseName: "properties",
      type: "{ [key: string]: string; }",
    },
  ];

  static getAttributeTypeMap() {
    return PostSchemaPayload.attributeTypeMap;
  }
}

export class PostSchemaResponse {
  "version"?: SchemaVersion;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "version",
      baseName: "version",
      type: "SchemaVersion",
    },
  ];

  static getAttributeTypeMap() {
    return PostSchemaResponse.attributeTypeMap;
  }
}

export class PrettyPrinter {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return PrettyPrinter.attributeTypeMap;
  }
}

export class ProcessContainerFactory {
  "javaInstanceJarLocation"?: string;
  "pythonInstanceLocation"?: string;
  "logDirectory"?: string;
  "extraFunctionDependenciesDir"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "javaInstanceJarLocation",
      baseName: "javaInstanceJarLocation",
      type: "string",
    },
    {
      name: "pythonInstanceLocation",
      baseName: "pythonInstanceLocation",
      type: "string",
    },
    {
      name: "logDirectory",
      baseName: "logDirectory",
      type: "string",
    },
    {
      name: "extraFunctionDependenciesDir",
      baseName: "extraFunctionDependenciesDir",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ProcessContainerFactory.attributeTypeMap;
  }
}

export class PropertyName {
  "empty"?: boolean;
  "simpleName"?: string;
  "namespace"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "empty",
      baseName: "empty",
      type: "boolean",
    },
    {
      name: "simpleName",
      baseName: "simpleName",
      type: "string",
    },
    {
      name: "namespace",
      baseName: "namespace",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return PropertyName.attributeTypeMap;
  }
}

export class PropertyNamingStrategy {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return PropertyNamingStrategy.attributeTypeMap;
  }
}

export class PublicKey {
  "encoded"?: Array<string>;
  "format"?: string;
  "algorithm"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "encoded",
      baseName: "encoded",
      type: "Array<string>",
    },
    {
      name: "format",
      baseName: "format",
      type: "string",
    },
    {
      name: "algorithm",
      baseName: "algorithm",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return PublicKey.attributeTypeMap;
  }
}

export class PublishRate {
  "publishThrottlingRateInMsg"?: number;
  "publishThrottlingRateInByte"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "publishThrottlingRateInMsg",
      baseName: "publishThrottlingRateInMsg",
      type: "number",
    },
    {
      name: "publishThrottlingRateInByte",
      baseName: "publishThrottlingRateInByte",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return PublishRate.attributeTypeMap;
  }
}

export class RawBookieInfo {
  "bookieId"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "bookieId",
      baseName: "bookieId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return RawBookieInfo.attributeTypeMap;
  }
}

export class ResetCursorData {
  "ledgerId"?: number;
  "entryId"?: number;
  "partitionIndex"?: number;
  "batchIndex"?: number;
  "properties"?: { [key: string]: string };
  "excluded"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ledgerId",
      baseName: "ledgerId",
      type: "number",
    },
    {
      name: "entryId",
      baseName: "entryId",
      type: "number",
    },
    {
      name: "partitionIndex",
      baseName: "partitionIndex",
      type: "number",
    },
    {
      name: "batchIndex",
      baseName: "batchIndex",
      type: "number",
    },
    {
      name: "properties",
      baseName: "properties",
      type: "{ [key: string]: string; }",
    },
    {
      name: "excluded",
      baseName: "excluded",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return ResetCursorData.attributeTypeMap;
  }
}

export class ResourceDescription {
  "usagePct"?: number;
  "resourceUsage"?: { [key: string]: ResourceUsage };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "usagePct",
      baseName: "usagePct",
      type: "number",
    },
    {
      name: "resourceUsage",
      baseName: "resourceUsage",
      type: "{ [key: string]: ResourceUsage; }",
    },
  ];

  static getAttributeTypeMap() {
    return ResourceDescription.attributeTypeMap;
  }
}

export class ResourceGroup {
  "publishRateInMsgs"?: number;
  "publishRateInBytes"?: number;
  "dispatchRateInMsgs"?: number;
  "dispatchRateInBytes"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "publishRateInMsgs",
      baseName: "publishRateInMsgs",
      type: "number",
    },
    {
      name: "publishRateInBytes",
      baseName: "publishRateInBytes",
      type: "number",
    },
    {
      name: "dispatchRateInMsgs",
      baseName: "dispatchRateInMsgs",
      type: "number",
    },
    {
      name: "dispatchRateInBytes",
      baseName: "dispatchRateInBytes",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return ResourceGroup.attributeTypeMap;
  }
}

export class ResourceQuota {
  "msgRateIn"?: number;
  "msgRateOut"?: number;
  "bandwidthIn"?: number;
  "bandwidthOut"?: number;
  "memory"?: number;
  "dynamic"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "msgRateIn",
      baseName: "msgRateIn",
      type: "number",
    },
    {
      name: "msgRateOut",
      baseName: "msgRateOut",
      type: "number",
    },
    {
      name: "bandwidthIn",
      baseName: "bandwidthIn",
      type: "number",
    },
    {
      name: "bandwidthOut",
      baseName: "bandwidthOut",
      type: "number",
    },
    {
      name: "memory",
      baseName: "memory",
      type: "number",
    },
    {
      name: "dynamic",
      baseName: "dynamic",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return ResourceQuota.attributeTypeMap;
  }
}

export class ResourceUnit {
  "resourceId"?: string;
  "availableResource"?: ResourceDescription;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "resourceId",
      baseName: "resourceId",
      type: "string",
    },
    {
      name: "availableResource",
      baseName: "availableResource",
      type: "ResourceDescription",
    },
  ];

  static getAttributeTypeMap() {
    return ResourceUnit.attributeTypeMap;
  }
}

export class ResourceUsage {
  "usage"?: number;
  "limit"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "usage",
      baseName: "usage",
      type: "number",
    },
    {
      name: "limit",
      baseName: "limit",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return ResourceUsage.attributeTypeMap;
  }
}

export class Resources {
  "cpu"?: number;
  "ram"?: number;
  "disk"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "cpu",
      baseName: "cpu",
      type: "number",
    },
    {
      name: "ram",
      baseName: "ram",
      type: "number",
    },
    {
      name: "disk",
      baseName: "disk",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return Resources.attributeTypeMap;
  }
}

export class RetentionPolicies {
  "retentionTimeInMinutes"?: number;
  "retentionSizeInMB"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "retentionTimeInMinutes",
      baseName: "retentionTimeInMinutes",
      type: "number",
    },
    {
      name: "retentionSizeInMB",
      baseName: "retentionSizeInMB",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return RetentionPolicies.attributeTypeMap;
  }
}

export class SchemaVersion {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return SchemaVersion.attributeTypeMap;
  }
}

export class SerializationConfig {
  "annotationIntrospector"?: AnnotationIntrospector;
  "defaultPropertyInclusion"?: Value;
  "filterProvider"?: FilterProvider;
  "defaultPrettyPrinter"?: PrettyPrinter;
  "serializationInclusion"?: SerializationConfig.SerializationInclusionEnum;
  "serializationFeatures"?: number;
  "attributes"?: ContextAttributes;
  "rootName"?: string;
  "subtypeResolver"?: SubtypeResolver;
  "fullRootName"?: PropertyName;
  "defaultVisibilityChecker"?: VisibilityCheckerObject;
  "locale"?: Locale;
  "timeZone"?: TimeZone;
  "typeFactory"?: TypeFactory;
  "propertyNamingStrategy"?: PropertyNamingStrategy;
  "handlerInstantiator"?: HandlerInstantiator;
  "dateFormat"?: DateFormat;
  "base64Variant"?: Base64Variant;
  "annotationProcessingEnabled"?: boolean;
  "classIntrospector"?: ClassIntrospector;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "annotationIntrospector",
      baseName: "annotationIntrospector",
      type: "AnnotationIntrospector",
    },
    {
      name: "defaultPropertyInclusion",
      baseName: "defaultPropertyInclusion",
      type: "Value",
    },
    {
      name: "filterProvider",
      baseName: "filterProvider",
      type: "FilterProvider",
    },
    {
      name: "defaultPrettyPrinter",
      baseName: "defaultPrettyPrinter",
      type: "PrettyPrinter",
    },
    {
      name: "serializationInclusion",
      baseName: "serializationInclusion",
      type: "SerializationConfig.SerializationInclusionEnum",
    },
    {
      name: "serializationFeatures",
      baseName: "serializationFeatures",
      type: "number",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "ContextAttributes",
    },
    {
      name: "rootName",
      baseName: "rootName",
      type: "string",
    },
    {
      name: "subtypeResolver",
      baseName: "subtypeResolver",
      type: "SubtypeResolver",
    },
    {
      name: "fullRootName",
      baseName: "fullRootName",
      type: "PropertyName",
    },
    {
      name: "defaultVisibilityChecker",
      baseName: "defaultVisibilityChecker",
      type: "VisibilityCheckerObject",
    },
    {
      name: "locale",
      baseName: "locale",
      type: "Locale",
    },
    {
      name: "timeZone",
      baseName: "timeZone",
      type: "TimeZone",
    },
    {
      name: "typeFactory",
      baseName: "typeFactory",
      type: "TypeFactory",
    },
    {
      name: "propertyNamingStrategy",
      baseName: "propertyNamingStrategy",
      type: "PropertyNamingStrategy",
    },
    {
      name: "handlerInstantiator",
      baseName: "handlerInstantiator",
      type: "HandlerInstantiator",
    },
    {
      name: "dateFormat",
      baseName: "dateFormat",
      type: "DateFormat",
    },
    {
      name: "base64Variant",
      baseName: "base64Variant",
      type: "Base64Variant",
    },
    {
      name: "annotationProcessingEnabled",
      baseName: "annotationProcessingEnabled",
      type: "boolean",
    },
    {
      name: "classIntrospector",
      baseName: "classIntrospector",
      type: "ClassIntrospector",
    },
  ];

  static getAttributeTypeMap() {
    return SerializationConfig.attributeTypeMap;
  }
}

export namespace SerializationConfig {
  export enum SerializationInclusionEnum {
    ALWAYS = <any>"ALWAYS",
    NONNULL = <any>"NON_NULL",
    NONABSENT = <any>"NON_ABSENT",
    NONEMPTY = <any>"NON_EMPTY",
    NONDEFAULT = <any>"NON_DEFAULT",
    USEDEFAULTS = <any>"USE_DEFAULTS",
  }
}
export class SerializerFactory {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return SerializerFactory.attributeTypeMap;
  }
}

export class SerializerProvider {
  "locale"?: Locale;
  "timeZone"?: TimeZone;
  "config"?: SerializationConfig;
  "typeFactory"?: TypeFactory;
  "annotationIntrospector"?: AnnotationIntrospector;
  "defaultNullValueSerializer"?: JsonSerializerObject;
  "filterProvider"?: FilterProvider;
  "defaultNullKeySerializer"?: JsonSerializerObject;
  "generator"?: JsonGenerator;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "locale",
      baseName: "locale",
      type: "Locale",
    },
    {
      name: "timeZone",
      baseName: "timeZone",
      type: "TimeZone",
    },
    {
      name: "config",
      baseName: "config",
      type: "SerializationConfig",
    },
    {
      name: "typeFactory",
      baseName: "typeFactory",
      type: "TypeFactory",
    },
    {
      name: "annotationIntrospector",
      baseName: "annotationIntrospector",
      type: "AnnotationIntrospector",
    },
    {
      name: "defaultNullValueSerializer",
      baseName: "defaultNullValueSerializer",
      type: "JsonSerializerObject",
    },
    {
      name: "filterProvider",
      baseName: "filterProvider",
      type: "FilterProvider",
    },
    {
      name: "defaultNullKeySerializer",
      baseName: "defaultNullKeySerializer",
      type: "JsonSerializerObject",
    },
    {
      name: "generator",
      baseName: "generator",
      type: "JsonGenerator",
    },
  ];

  static getAttributeTypeMap() {
    return SerializerProvider.attributeTypeMap;
  }
}

export class ShortBuilder {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return ShortBuilder.attributeTypeMap;
  }
}

export class Sinks {
  "sinkList"?: Array<ConnectorDefinition>;
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sinkList",
      baseName: "sinkList",
      type: "Array<ConnectorDefinition>",
    },
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return Sinks.attributeTypeMap;
  }
}

export class SinksWorkerService {
  "sinkList"?: Array<ConnectorDefinition>;
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sinkList",
      baseName: "sinkList",
      type: "Array<ConnectorDefinition>",
    },
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return SinksWorkerService.attributeTypeMap;
  }
}

export class SocketAddress {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return SocketAddress.attributeTypeMap;
  }
}

export class Sources {
  "sourceList"?: Array<ConnectorDefinition>;
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sourceList",
      baseName: "sourceList",
      type: "Array<ConnectorDefinition>",
    },
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return Sources.attributeTypeMap;
  }
}

export class SourcesWorkerService {
  "sourceList"?: Array<ConnectorDefinition>;
  "listOfConnectors"?: Array<ConnectorDefinition>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sourceList",
      baseName: "sourceList",
      type: "Array<ConnectorDefinition>",
    },
    {
      name: "listOfConnectors",
      baseName: "listOfConnectors",
      type: "Array<ConnectorDefinition>",
    },
  ];

  static getAttributeTypeMap() {
    return SourcesWorkerService.attributeTypeMap;
  }
}

export class SubscribeRate {
  "subscribeThrottlingRatePerConsumer"?: number;
  "ratePeriodInSecond"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "subscribeThrottlingRatePerConsumer",
      baseName: "subscribeThrottlingRatePerConsumer",
      type: "number",
    },
    {
      name: "ratePeriodInSecond",
      baseName: "ratePeriodInSecond",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubscribeRate.attributeTypeMap;
  }
}

export class SubtypeResolver {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return SubtypeResolver.attributeTypeMap;
  }
}

export class SystemResourceUsage {
  "bandwidthIn"?: ResourceUsage;
  "bandwidthOut"?: ResourceUsage;
  "cpu"?: ResourceUsage;
  "memory"?: ResourceUsage;
  "directMemory"?: ResourceUsage;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "bandwidthIn",
      baseName: "bandwidthIn",
      type: "ResourceUsage",
    },
    {
      name: "bandwidthOut",
      baseName: "bandwidthOut",
      type: "ResourceUsage",
    },
    {
      name: "cpu",
      baseName: "cpu",
      type: "ResourceUsage",
    },
    {
      name: "memory",
      baseName: "memory",
      type: "ResourceUsage",
    },
    {
      name: "directMemory",
      baseName: "directMemory",
      type: "ResourceUsage",
    },
  ];

  static getAttributeTypeMap() {
    return SystemResourceUsage.attributeTypeMap;
  }
}

/**
 * Information of adminRoles and allowedClusters for tenant
 */
export class TenantInfo {
  /**
   * Comma separated list of auth principal allowed to administrate the tenant.
   */
  "adminRoles"?: Array<string>;
  /**
   * Comma separated allowed clusters.
   */
  "allowedClusters"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "adminRoles",
      baseName: "adminRoles",
      type: "Array<string>",
    },
    {
      name: "allowedClusters",
      baseName: "allowedClusters",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return TenantInfo.attributeTypeMap;
  }
}

export class ThreadContainerFactory {
  "threadGroupName"?: string;
  "pulsarClientMemoryLimit"?: MemoryLimit;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "threadGroupName",
      baseName: "threadGroupName",
      type: "string",
    },
    {
      name: "pulsarClientMemoryLimit",
      baseName: "pulsarClientMemoryLimit",
      type: "MemoryLimit",
    },
  ];

  static getAttributeTypeMap() {
    return ThreadContainerFactory.attributeTypeMap;
  }
}

export class TimeZone {
  "displayName"?: string;
  "id"?: string;
  "dstsavings"?: number;
  "rawOffset"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "displayName",
      baseName: "displayName",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "dstsavings",
      baseName: "dstsavings",
      type: "number",
    },
    {
      name: "rawOffset",
      baseName: "rawOffset",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return TimeZone.attributeTypeMap;
  }
}

export class TypeBindings {
  "empty"?: boolean;
  "typeParameters"?: Array<JavaType>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "empty",
      baseName: "empty",
      type: "boolean",
    },
    {
      name: "typeParameters",
      baseName: "typeParameters",
      type: "Array<JavaType>",
    },
  ];

  static getAttributeTypeMap() {
    return TypeBindings.attributeTypeMap;
  }
}

export class TypeFactory {
  "classLoader"?: ClassLoader;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "classLoader",
      baseName: "classLoader",
      type: "ClassLoader",
    },
  ];

  static getAttributeTypeMap() {
    return TypeFactory.attributeTypeMap;
  }
}

export class Value {
  "contentInclusion"?: Value.ContentInclusionEnum;
  "valueInclusion"?: Value.ValueInclusionEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "contentInclusion",
      baseName: "contentInclusion",
      type: "Value.ContentInclusionEnum",
    },
    {
      name: "valueInclusion",
      baseName: "valueInclusion",
      type: "Value.ValueInclusionEnum",
    },
  ];

  static getAttributeTypeMap() {
    return Value.attributeTypeMap;
  }
}

export namespace Value {
  export enum ContentInclusionEnum {
    ALWAYS = <any>"ALWAYS",
    NONNULL = <any>"NON_NULL",
    NONABSENT = <any>"NON_ABSENT",
    NONEMPTY = <any>"NON_EMPTY",
    NONDEFAULT = <any>"NON_DEFAULT",
    USEDEFAULTS = <any>"USE_DEFAULTS",
  }
  export enum ValueInclusionEnum {
    ALWAYS = <any>"ALWAYS",
    NONNULL = <any>"NON_NULL",
    NONABSENT = <any>"NON_ABSENT",
    NONEMPTY = <any>"NON_EMPTY",
    NONDEFAULT = <any>"NON_DEFAULT",
    USEDEFAULTS = <any>"USE_DEFAULTS",
  }
}
export class VisibilityChecker {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return VisibilityChecker.attributeTypeMap;
  }
}

export class VisibilityCheckerObject {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return VisibilityCheckerObject.attributeTypeMap;
  }
}

export class WorkerConfig {
  "workerId"?: string;
  "workerHostname"?: string;
  "workerPort"?: number;
  "workerPortTls"?: number;
  "authenticateMetricsEndpoint"?: boolean;
  "includeStandardPrometheusMetrics"?: boolean;
  "jvmGCMetricsLoggerClassName"?: string;
  "numHttpServerThreads"?: number;
  "httpRequestsLimitEnabled"?: boolean;
  "httpRequestsMaxPerSecond"?: number;
  "maxConcurrentHttpRequests"?: number;
  "httpServerThreadPoolQueueSize"?: number;
  "httpServerAcceptQueueSize"?: number;
  "maxHttpServerConnections"?: number;
  "configurationStoreServers"?: string;
  "configurationMetadataStoreUrl"?: string;
  "metadataStoreSessionTimeoutMillis"?: number;
  "metadataStoreOperationTimeoutSeconds"?: number;
  "metadataStoreCacheExpirySeconds"?: number;
  "zooKeeperSessionTimeoutMillis"?: number;
  "zooKeeperOperationTimeoutSeconds"?: number;
  "zooKeeperCacheExpirySeconds"?: number;
  "connectorsDirectory"?: string;
  "narExtractionDirectory"?: string;
  "validateConnectorConfig"?: boolean;
  "uploadBuiltinSinksSources"?: boolean;
  "functionsDirectory"?: string;
  "functionMetadataTopicName"?: string;
  "useCompactedMetadataTopic"?: boolean;
  "functionWebServiceUrl"?: string;
  "pulsarServiceUrl"?: string;
  "pulsarWebServiceUrl"?: string;
  "clusterCoordinationTopicName"?: string;
  "pulsarFunctionsNamespace"?: string;
  "pulsarFunctionsCluster"?: string;
  "numFunctionPackageReplicas"?: number;
  "functionsWorkerEnablePackageManagement"?: boolean;
  "downloadDirectory"?: string;
  "stateStorageServiceUrl"?: string;
  "stateStorageProviderImplementation"?: string;
  "functionAssignmentTopicName"?: string;
  "schedulerClassName"?: string;
  "failureCheckFreqMs"?: number;
  "rescheduleTimeoutMs"?: number;
  "rebalanceCheckFreqSec"?: number;
  "workerListProbeIntervalSec"?: number;
  "initialBrokerReconnectMaxRetries"?: number;
  "assignmentWriteMaxRetries"?: number;
  "instanceLivenessCheckFreqMs"?: number;
  "brokerClientAuthenticationEnabled"?: boolean;
  "brokerClientAuthenticationPlugin"?: string;
  "brokerClientAuthenticationParameters"?: string;
  "bookkeeperClientAuthenticationPlugin"?: string;
  "bookkeeperClientAuthenticationParametersName"?: string;
  "bookkeeperClientAuthenticationParameters"?: string;
  "topicCompactionFrequencySec"?: number;
  "tlsEnabled"?: boolean;
  "tlsCertificateFilePath"?: string;
  "tlsKeyFilePath"?: string;
  "tlsTrustCertsFilePath"?: string;
  "tlsAllowInsecureConnection"?: boolean;
  "tlsRequireTrustedClientCertOnConnect"?: boolean;
  "useTls"?: boolean;
  "tlsEnableHostnameVerification"?: boolean;
  "tlsCertRefreshCheckDurationSec"?: number;
  "tlsEnabledWithKeyStore"?: boolean;
  "tlsProvider"?: string;
  "tlsKeyStoreType"?: string;
  "tlsKeyStore"?: string;
  "tlsKeyStorePassword"?: string;
  "tlsTrustStoreType"?: string;
  "tlsTrustStore"?: string;
  "tlsTrustStorePassword"?: string;
  "webServiceTlsProtocols"?: Array<string>;
  "webServiceTlsCiphers"?: Array<string>;
  "authenticationEnabled"?: boolean;
  "authenticationProviders"?: Array<string>;
  "authorizationEnabled"?: boolean;
  "authorizationProvider"?: string;
  "superUserRoles"?: Array<string>;
  "saslJaasClientAllowedIds"?: string;
  "saslJaasServerSectionName"?: string;
  "saslJaasServerRoleTokenSignerSecretPath"?: string;
  "kinitCommand"?: string;
  "properties"?: { [key: string]: string };
  "initializedDlogMetadata"?: boolean;
  "brokerClientTrustCertsFilePath"?: string;
  "functionRuntimeFactoryClassName"?: string;
  "functionRuntimeFactoryConfigs"?: { [key: string]: any };
  "secretsProviderConfiguratorClassName"?: string;
  "secretsProviderConfiguratorConfig"?: { [key: string]: string };
  "functionInstanceMinResources"?: Resources;
  "functionInstanceMaxResources"?: Resources;
  "functionInstanceResourceGranularities"?: Resources;
  "functionInstanceResourceChangeInLockStep"?: boolean;
  "functionAuthProviderClassName"?: string;
  "runtimeCustomizerClassName"?: string;
  "runtimeCustomizerConfig"?: { [key: string]: any };
  "maxPendingAsyncRequests"?: number;
  "forwardSourceMessageProperty"?: boolean;
  "additionalJavaRuntimeArguments"?: Array<string>;
  "functionsWorkerServiceNarPackage"?: string;
  "functionsWorkerServiceCustomConfigs"?: { [key: string]: any };
  "exposeAdminClientEnabled"?: boolean;
  "threadContainerFactory"?: ThreadContainerFactory;
  "processContainerFactory"?: ProcessContainerFactory;
  "kubernetesContainerFactory"?: KubernetesContainerFactory;
  "clientAuthenticationParameters"?: string;
  "clientAuthenticationPlugin"?: string;
  "functionMetadataTopic"?: string;
  "clusterCoordinationTopic"?: string;
  "functionAssignmentTopic"?: string;
  "tlsTrustChainBytes"?: Array<string>;
  "workerWebAddress"?: string;
  "workerWebAddressTls"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "workerId",
      baseName: "workerId",
      type: "string",
    },
    {
      name: "workerHostname",
      baseName: "workerHostname",
      type: "string",
    },
    {
      name: "workerPort",
      baseName: "workerPort",
      type: "number",
    },
    {
      name: "workerPortTls",
      baseName: "workerPortTls",
      type: "number",
    },
    {
      name: "authenticateMetricsEndpoint",
      baseName: "authenticateMetricsEndpoint",
      type: "boolean",
    },
    {
      name: "includeStandardPrometheusMetrics",
      baseName: "includeStandardPrometheusMetrics",
      type: "boolean",
    },
    {
      name: "jvmGCMetricsLoggerClassName",
      baseName: "jvmGCMetricsLoggerClassName",
      type: "string",
    },
    {
      name: "numHttpServerThreads",
      baseName: "numHttpServerThreads",
      type: "number",
    },
    {
      name: "httpRequestsLimitEnabled",
      baseName: "httpRequestsLimitEnabled",
      type: "boolean",
    },
    {
      name: "httpRequestsMaxPerSecond",
      baseName: "httpRequestsMaxPerSecond",
      type: "number",
    },
    {
      name: "maxConcurrentHttpRequests",
      baseName: "maxConcurrentHttpRequests",
      type: "number",
    },
    {
      name: "httpServerThreadPoolQueueSize",
      baseName: "httpServerThreadPoolQueueSize",
      type: "number",
    },
    {
      name: "httpServerAcceptQueueSize",
      baseName: "httpServerAcceptQueueSize",
      type: "number",
    },
    {
      name: "maxHttpServerConnections",
      baseName: "maxHttpServerConnections",
      type: "number",
    },
    {
      name: "configurationStoreServers",
      baseName: "configurationStoreServers",
      type: "string",
    },
    {
      name: "configurationMetadataStoreUrl",
      baseName: "configurationMetadataStoreUrl",
      type: "string",
    },
    {
      name: "metadataStoreSessionTimeoutMillis",
      baseName: "metadataStoreSessionTimeoutMillis",
      type: "number",
    },
    {
      name: "metadataStoreOperationTimeoutSeconds",
      baseName: "metadataStoreOperationTimeoutSeconds",
      type: "number",
    },
    {
      name: "metadataStoreCacheExpirySeconds",
      baseName: "metadataStoreCacheExpirySeconds",
      type: "number",
    },
    {
      name: "zooKeeperSessionTimeoutMillis",
      baseName: "zooKeeperSessionTimeoutMillis",
      type: "number",
    },
    {
      name: "zooKeeperOperationTimeoutSeconds",
      baseName: "zooKeeperOperationTimeoutSeconds",
      type: "number",
    },
    {
      name: "zooKeeperCacheExpirySeconds",
      baseName: "zooKeeperCacheExpirySeconds",
      type: "number",
    },
    {
      name: "connectorsDirectory",
      baseName: "connectorsDirectory",
      type: "string",
    },
    {
      name: "narExtractionDirectory",
      baseName: "narExtractionDirectory",
      type: "string",
    },
    {
      name: "validateConnectorConfig",
      baseName: "validateConnectorConfig",
      type: "boolean",
    },
    {
      name: "uploadBuiltinSinksSources",
      baseName: "uploadBuiltinSinksSources",
      type: "boolean",
    },
    {
      name: "functionsDirectory",
      baseName: "functionsDirectory",
      type: "string",
    },
    {
      name: "functionMetadataTopicName",
      baseName: "functionMetadataTopicName",
      type: "string",
    },
    {
      name: "useCompactedMetadataTopic",
      baseName: "useCompactedMetadataTopic",
      type: "boolean",
    },
    {
      name: "functionWebServiceUrl",
      baseName: "functionWebServiceUrl",
      type: "string",
    },
    {
      name: "pulsarServiceUrl",
      baseName: "pulsarServiceUrl",
      type: "string",
    },
    {
      name: "pulsarWebServiceUrl",
      baseName: "pulsarWebServiceUrl",
      type: "string",
    },
    {
      name: "clusterCoordinationTopicName",
      baseName: "clusterCoordinationTopicName",
      type: "string",
    },
    {
      name: "pulsarFunctionsNamespace",
      baseName: "pulsarFunctionsNamespace",
      type: "string",
    },
    {
      name: "pulsarFunctionsCluster",
      baseName: "pulsarFunctionsCluster",
      type: "string",
    },
    {
      name: "numFunctionPackageReplicas",
      baseName: "numFunctionPackageReplicas",
      type: "number",
    },
    {
      name: "functionsWorkerEnablePackageManagement",
      baseName: "functionsWorkerEnablePackageManagement",
      type: "boolean",
    },
    {
      name: "downloadDirectory",
      baseName: "downloadDirectory",
      type: "string",
    },
    {
      name: "stateStorageServiceUrl",
      baseName: "stateStorageServiceUrl",
      type: "string",
    },
    {
      name: "stateStorageProviderImplementation",
      baseName: "stateStorageProviderImplementation",
      type: "string",
    },
    {
      name: "functionAssignmentTopicName",
      baseName: "functionAssignmentTopicName",
      type: "string",
    },
    {
      name: "schedulerClassName",
      baseName: "schedulerClassName",
      type: "string",
    },
    {
      name: "failureCheckFreqMs",
      baseName: "failureCheckFreqMs",
      type: "number",
    },
    {
      name: "rescheduleTimeoutMs",
      baseName: "rescheduleTimeoutMs",
      type: "number",
    },
    {
      name: "rebalanceCheckFreqSec",
      baseName: "rebalanceCheckFreqSec",
      type: "number",
    },
    {
      name: "workerListProbeIntervalSec",
      baseName: "workerListProbeIntervalSec",
      type: "number",
    },
    {
      name: "initialBrokerReconnectMaxRetries",
      baseName: "initialBrokerReconnectMaxRetries",
      type: "number",
    },
    {
      name: "assignmentWriteMaxRetries",
      baseName: "assignmentWriteMaxRetries",
      type: "number",
    },
    {
      name: "instanceLivenessCheckFreqMs",
      baseName: "instanceLivenessCheckFreqMs",
      type: "number",
    },
    {
      name: "brokerClientAuthenticationEnabled",
      baseName: "brokerClientAuthenticationEnabled",
      type: "boolean",
    },
    {
      name: "brokerClientAuthenticationPlugin",
      baseName: "brokerClientAuthenticationPlugin",
      type: "string",
    },
    {
      name: "brokerClientAuthenticationParameters",
      baseName: "brokerClientAuthenticationParameters",
      type: "string",
    },
    {
      name: "bookkeeperClientAuthenticationPlugin",
      baseName: "bookkeeperClientAuthenticationPlugin",
      type: "string",
    },
    {
      name: "bookkeeperClientAuthenticationParametersName",
      baseName: "bookkeeperClientAuthenticationParametersName",
      type: "string",
    },
    {
      name: "bookkeeperClientAuthenticationParameters",
      baseName: "bookkeeperClientAuthenticationParameters",
      type: "string",
    },
    {
      name: "topicCompactionFrequencySec",
      baseName: "topicCompactionFrequencySec",
      type: "number",
    },
    {
      name: "tlsEnabled",
      baseName: "tlsEnabled",
      type: "boolean",
    },
    {
      name: "tlsCertificateFilePath",
      baseName: "tlsCertificateFilePath",
      type: "string",
    },
    {
      name: "tlsKeyFilePath",
      baseName: "tlsKeyFilePath",
      type: "string",
    },
    {
      name: "tlsTrustCertsFilePath",
      baseName: "tlsTrustCertsFilePath",
      type: "string",
    },
    {
      name: "tlsAllowInsecureConnection",
      baseName: "tlsAllowInsecureConnection",
      type: "boolean",
    },
    {
      name: "tlsRequireTrustedClientCertOnConnect",
      baseName: "tlsRequireTrustedClientCertOnConnect",
      type: "boolean",
    },
    {
      name: "useTls",
      baseName: "useTls",
      type: "boolean",
    },
    {
      name: "tlsEnableHostnameVerification",
      baseName: "tlsEnableHostnameVerification",
      type: "boolean",
    },
    {
      name: "tlsCertRefreshCheckDurationSec",
      baseName: "tlsCertRefreshCheckDurationSec",
      type: "number",
    },
    {
      name: "tlsEnabledWithKeyStore",
      baseName: "tlsEnabledWithKeyStore",
      type: "boolean",
    },
    {
      name: "tlsProvider",
      baseName: "tlsProvider",
      type: "string",
    },
    {
      name: "tlsKeyStoreType",
      baseName: "tlsKeyStoreType",
      type: "string",
    },
    {
      name: "tlsKeyStore",
      baseName: "tlsKeyStore",
      type: "string",
    },
    {
      name: "tlsKeyStorePassword",
      baseName: "tlsKeyStorePassword",
      type: "string",
    },
    {
      name: "tlsTrustStoreType",
      baseName: "tlsTrustStoreType",
      type: "string",
    },
    {
      name: "tlsTrustStore",
      baseName: "tlsTrustStore",
      type: "string",
    },
    {
      name: "tlsTrustStorePassword",
      baseName: "tlsTrustStorePassword",
      type: "string",
    },
    {
      name: "webServiceTlsProtocols",
      baseName: "webServiceTlsProtocols",
      type: "Array<string>",
    },
    {
      name: "webServiceTlsCiphers",
      baseName: "webServiceTlsCiphers",
      type: "Array<string>",
    },
    {
      name: "authenticationEnabled",
      baseName: "authenticationEnabled",
      type: "boolean",
    },
    {
      name: "authenticationProviders",
      baseName: "authenticationProviders",
      type: "Array<string>",
    },
    {
      name: "authorizationEnabled",
      baseName: "authorizationEnabled",
      type: "boolean",
    },
    {
      name: "authorizationProvider",
      baseName: "authorizationProvider",
      type: "string",
    },
    {
      name: "superUserRoles",
      baseName: "superUserRoles",
      type: "Array<string>",
    },
    {
      name: "saslJaasClientAllowedIds",
      baseName: "saslJaasClientAllowedIds",
      type: "string",
    },
    {
      name: "saslJaasServerSectionName",
      baseName: "saslJaasServerSectionName",
      type: "string",
    },
    {
      name: "saslJaasServerRoleTokenSignerSecretPath",
      baseName: "saslJaasServerRoleTokenSignerSecretPath",
      type: "string",
    },
    {
      name: "kinitCommand",
      baseName: "kinitCommand",
      type: "string",
    },
    {
      name: "properties",
      baseName: "properties",
      type: "{ [key: string]: string; }",
    },
    {
      name: "initializedDlogMetadata",
      baseName: "initializedDlogMetadata",
      type: "boolean",
    },
    {
      name: "brokerClientTrustCertsFilePath",
      baseName: "brokerClientTrustCertsFilePath",
      type: "string",
    },
    {
      name: "functionRuntimeFactoryClassName",
      baseName: "functionRuntimeFactoryClassName",
      type: "string",
    },
    {
      name: "functionRuntimeFactoryConfigs",
      baseName: "functionRuntimeFactoryConfigs",
      type: "{ [key: string]: any; }",
    },
    {
      name: "secretsProviderConfiguratorClassName",
      baseName: "secretsProviderConfiguratorClassName",
      type: "string",
    },
    {
      name: "secretsProviderConfiguratorConfig",
      baseName: "secretsProviderConfiguratorConfig",
      type: "{ [key: string]: string; }",
    },
    {
      name: "functionInstanceMinResources",
      baseName: "functionInstanceMinResources",
      type: "Resources",
    },
    {
      name: "functionInstanceMaxResources",
      baseName: "functionInstanceMaxResources",
      type: "Resources",
    },
    {
      name: "functionInstanceResourceGranularities",
      baseName: "functionInstanceResourceGranularities",
      type: "Resources",
    },
    {
      name: "functionInstanceResourceChangeInLockStep",
      baseName: "functionInstanceResourceChangeInLockStep",
      type: "boolean",
    },
    {
      name: "functionAuthProviderClassName",
      baseName: "functionAuthProviderClassName",
      type: "string",
    },
    {
      name: "runtimeCustomizerClassName",
      baseName: "runtimeCustomizerClassName",
      type: "string",
    },
    {
      name: "runtimeCustomizerConfig",
      baseName: "runtimeCustomizerConfig",
      type: "{ [key: string]: any; }",
    },
    {
      name: "maxPendingAsyncRequests",
      baseName: "maxPendingAsyncRequests",
      type: "number",
    },
    {
      name: "forwardSourceMessageProperty",
      baseName: "forwardSourceMessageProperty",
      type: "boolean",
    },
    {
      name: "additionalJavaRuntimeArguments",
      baseName: "additionalJavaRuntimeArguments",
      type: "Array<string>",
    },
    {
      name: "functionsWorkerServiceNarPackage",
      baseName: "functionsWorkerServiceNarPackage",
      type: "string",
    },
    {
      name: "functionsWorkerServiceCustomConfigs",
      baseName: "functionsWorkerServiceCustomConfigs",
      type: "{ [key: string]: any; }",
    },
    {
      name: "exposeAdminClientEnabled",
      baseName: "exposeAdminClientEnabled",
      type: "boolean",
    },
    {
      name: "threadContainerFactory",
      baseName: "threadContainerFactory",
      type: "ThreadContainerFactory",
    },
    {
      name: "processContainerFactory",
      baseName: "processContainerFactory",
      type: "ProcessContainerFactory",
    },
    {
      name: "kubernetesContainerFactory",
      baseName: "kubernetesContainerFactory",
      type: "KubernetesContainerFactory",
    },
    {
      name: "clientAuthenticationParameters",
      baseName: "clientAuthenticationParameters",
      type: "string",
    },
    {
      name: "clientAuthenticationPlugin",
      baseName: "clientAuthenticationPlugin",
      type: "string",
    },
    {
      name: "functionMetadataTopic",
      baseName: "functionMetadataTopic",
      type: "string",
    },
    {
      name: "clusterCoordinationTopic",
      baseName: "clusterCoordinationTopic",
      type: "string",
    },
    {
      name: "functionAssignmentTopic",
      baseName: "functionAssignmentTopic",
      type: "string",
    },
    {
      name: "tlsTrustChainBytes",
      baseName: "tlsTrustChainBytes",
      type: "Array<string>",
    },
    {
      name: "workerWebAddress",
      baseName: "workerWebAddress",
      type: "string",
    },
    {
      name: "workerWebAddressTls",
      baseName: "workerWebAddressTls",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return WorkerConfig.attributeTypeMap;
  }
}

export class WorkerFunctionInstanceStats {
  "name"?: string;
  "metrics"?: FunctionInstanceStatsData;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "metrics",
      baseName: "metrics",
      type: "FunctionInstanceStatsData",
    },
  ];

  static getAttributeTypeMap() {
    return WorkerFunctionInstanceStats.attributeTypeMap;
  }
}

export class WorkerInfo {
  "workerId"?: string;
  "workerHostname"?: string;
  "port"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "workerId",
      baseName: "workerId",
      type: "string",
    },
    {
      name: "workerHostname",
      baseName: "workerHostname",
      type: "string",
    },
    {
      name: "port",
      baseName: "port",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return WorkerInfo.attributeTypeMap;
  }
}

export class WorkerService {
  "sources"?: SourcesWorkerService;
  "initialized"?: boolean;
  "workerConfig"?: WorkerConfig;
  "functionsV2"?: FunctionsV2WorkerService;
  "workers"?: WorkersWorkerService;
  "functions"?: FunctionsWorkerService;
  "sinks"?: SinksWorkerService;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sources",
      baseName: "sources",
      type: "SourcesWorkerService",
    },
    {
      name: "initialized",
      baseName: "initialized",
      type: "boolean",
    },
    {
      name: "workerConfig",
      baseName: "workerConfig",
      type: "WorkerConfig",
    },
    {
      name: "functionsV2",
      baseName: "functionsV2",
      type: "FunctionsV2WorkerService",
    },
    {
      name: "workers",
      baseName: "workers",
      type: "WorkersWorkerService",
    },
    {
      name: "functions",
      baseName: "functions",
      type: "FunctionsWorkerService",
    },
    {
      name: "sinks",
      baseName: "sinks",
      type: "SinksWorkerService",
    },
  ];

  static getAttributeTypeMap() {
    return WorkerService.attributeTypeMap;
  }
}

export class Workers {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return Workers.attributeTypeMap;
  }
}

export class WorkersWorkerService {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return WorkersWorkerService.attributeTypeMap;
  }
}

let enumsMap: { [index: string]: any } = {
  "AuthPolicies.NamespaceAuthenticationEnum":
    AuthPolicies.NamespaceAuthenticationEnum,
  "AuthPolicies.TopicAuthenticationEnum": AuthPolicies.TopicAuthenticationEnum,
  "AutoFailoverPolicyData.PolicyTypeEnum":
    AutoFailoverPolicyData.PolicyTypeEnum,
  "BacklogQuota.PolicyEnum": BacklogQuota.PolicyEnum,
  "ClusterData.ProxyProtocolEnum": ClusterData.ProxyProtocolEnum,
  "GetSchemaResponse.TypeEnum": GetSchemaResponse.TypeEnum,
  "InactiveTopicPolicies.InactiveTopicDeleteModeEnum":
    InactiveTopicPolicies.InactiveTopicDeleteModeEnum,
  "JsonParser.CurrentTokenEnum": JsonParser.CurrentTokenEnum,
  "JsonParser.LastClearedTokenEnum": JsonParser.LastClearedTokenEnum,
  "JsonParser.NumberTypeEnum": JsonParser.NumberTypeEnum,
  "LongRunningProcessStatus.StatusEnum": LongRunningProcessStatus.StatusEnum,
  "NamespaceOwnershipStatus.BrokerAssignmentEnum":
    NamespaceOwnershipStatus.BrokerAssignmentEnum,
  "NumberFormat.RoundingModeEnum": NumberFormat.RoundingModeEnum,
  "OffloadPolicies.ManagedLedgerOffloadedReadPriorityEnum":
    OffloadPolicies.ManagedLedgerOffloadedReadPriorityEnum,
  "OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriorityEnum":
    OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriorityEnum,
  "Policies.SubscriptionAuthModeEnum": Policies.SubscriptionAuthModeEnum,
  "Policies.SchemaAutoUpdateCompatibilityStrategyEnum":
    Policies.SchemaAutoUpdateCompatibilityStrategyEnum,
  "Policies.SchemaCompatibilityStrategyEnum":
    Policies.SchemaCompatibilityStrategyEnum,
  "SerializationConfig.SerializationInclusionEnum":
    SerializationConfig.SerializationInclusionEnum,
  "Value.ContentInclusionEnum": Value.ContentInclusionEnum,
  "Value.ValueInclusionEnum": Value.ValueInclusionEnum,
};

let typeMap: { [index: string]: any } = {
  AllocatorStats: AllocatorStats,
  Annotation: Annotation,
  AnnotationIntrospector: AnnotationIntrospector,
  ArrayBuilders: ArrayBuilders,
  AuthPolicies: AuthPolicies,
  AuthenticationDataSource: AuthenticationDataSource,
  AutoFailoverPolicyData: AutoFailoverPolicyData,
  AutoSubscriptionCreationOverride: AutoSubscriptionCreationOverride,
  AutoTopicCreationOverride: AutoTopicCreationOverride,
  BacklogQuota: BacklogQuota,
  Base64Variant: Base64Variant,
  BookieAffinityGroupData: BookieAffinityGroupData,
  BookieInfo: BookieInfo,
  BookiesClusterInfo: BookiesClusterInfo,
  BooleanBuilder: BooleanBuilder,
  BrokerInfo: BrokerInfo,
  BrokerNamespaceIsolationData: BrokerNamespaceIsolationData,
  BundlesData: BundlesData,
  ByteBuilder: ByteBuilder,
  Certificate: Certificate,
  CharacterEscapes: CharacterEscapes,
  ClassIntrospector: ClassIntrospector,
  ClassLoader: ClassLoader,
  ClusterData: ClusterData,
  CompletableFuture: CompletableFuture,
  CompletableFutureClusterData: CompletableFutureClusterData,
  CompletableFuturePartitionedTopicMetadata:
    CompletableFuturePartitionedTopicMetadata,
  CompletableFutureResourceQuota: CompletableFutureResourceQuota,
  CompletableFutureVoid: CompletableFutureVoid,
  ConnectorDefinition: ConnectorDefinition,
  ContextAttributes: ContextAttributes,
  Currency: Currency,
  CursorDetails: CursorDetails,
  CursorStats: CursorStats,
  DateFormat: DateFormat,
  DelayedDeliveryPolicies: DelayedDeliveryPolicies,
  DeleteSchemaResponse: DeleteSchemaResponse,
  DeserializationConfig: DeserializationConfig,
  DeserializationContext: DeserializationContext,
  DeserializerFactory: DeserializerFactory,
  DispatchRate: DispatchRate,
  DispatchRateImpl: DispatchRateImpl,
  DoubleBuilder: DoubleBuilder,
  FailureDomain: FailureDomain,
  FilterProvider: FilterProvider,
  FloatBuilder: FloatBuilder,
  FormatSchema: FormatSchema,
  FunctionInstanceStatsData: FunctionInstanceStatsData,
  FunctionInstanceStatsDataBase: FunctionInstanceStatsDataBase,
  Functions: Functions,
  FunctionsV2: FunctionsV2,
  FunctionsV2WorkerService: FunctionsV2WorkerService,
  FunctionsWorkerService: FunctionsWorkerService,
  GetAllVersionsSchemaResponse: GetAllVersionsSchemaResponse,
  GetSchemaResponse: GetSchemaResponse,
  HandlerInstantiator: HandlerInstantiator,
  InactiveTopicPolicies: InactiveTopicPolicies,
  InjectableValues: InjectableValues,
  InputDecorator: InputDecorator,
  IntBuilder: IntBuilder,
  InternalConfigurationData: InternalConfigurationData,
  IsCompatibilityResponse: IsCompatibilityResponse,
  JavaType: JavaType,
  JsonFactory: JsonFactory,
  JsonGenerator: JsonGenerator,
  JsonLocation: JsonLocation,
  JsonNodeFactory: JsonNodeFactory,
  JsonParser: JsonParser,
  JsonSerializer: JsonSerializer,
  JsonSerializerObject: JsonSerializerObject,
  JsonStreamContext: JsonStreamContext,
  KubernetesContainerFactory: KubernetesContainerFactory,
  LedgerDetails: LedgerDetails,
  LedgerInfo: LedgerInfo,
  LinkedNode: LinkedNode,
  LinkedNodeDeserializationProblemHandler:
    LinkedNodeDeserializationProblemHandler,
  LoadReport: LoadReport,
  Locale: Locale,
  LongBuilder: LongBuilder,
  LongRunningProcessStatus: LongRunningProcessStatus,
  LongSchemaVersion: LongSchemaVersion,
  MemoryLimit: MemoryLimit,
  MessageId: MessageId,
  Metrics: Metrics,
  ModelPackage: ModelPackage,
  Module: Module,
  ModuleDescriptor: ModuleDescriptor,
  ModuleLayer: ModuleLayer,
  NamespaceBundleStats: NamespaceBundleStats,
  NamespaceIsolationData: NamespaceIsolationData,
  NamespaceOwnershipStatus: NamespaceOwnershipStatus,
  Number: Number,
  NumberFormat: NumberFormat,
  ObjectCodec: ObjectCodec,
  ObjectMapper: ObjectMapper,
  OffloadPolicies: OffloadPolicies,
  OffloadPoliciesImpl: OffloadPoliciesImpl,
  OutputDecorator: OutputDecorator,
  OutputStream: OutputStream,
  PartitionedTopicMetadata: PartitionedTopicMetadata,
  PendingBookieOpsStats: PendingBookieOpsStats,
  PersistencePolicies: PersistencePolicies,
  PersistentOfflineTopicStats: PersistentOfflineTopicStats,
  PersistentTopicInternalStats: PersistentTopicInternalStats,
  Policies: Policies,
  PoolArenaStats: PoolArenaStats,
  PoolChunkListStats: PoolChunkListStats,
  PoolChunkStats: PoolChunkStats,
  PoolSubpageStats: PoolSubpageStats,
  PostSchemaPayload: PostSchemaPayload,
  PostSchemaResponse: PostSchemaResponse,
  PrettyPrinter: PrettyPrinter,
  ProcessContainerFactory: ProcessContainerFactory,
  PropertyName: PropertyName,
  PropertyNamingStrategy: PropertyNamingStrategy,
  PublicKey: PublicKey,
  PublishRate: PublishRate,
  RawBookieInfo: RawBookieInfo,
  ResetCursorData: ResetCursorData,
  ResourceDescription: ResourceDescription,
  ResourceGroup: ResourceGroup,
  ResourceQuota: ResourceQuota,
  ResourceUnit: ResourceUnit,
  ResourceUsage: ResourceUsage,
  Resources: Resources,
  RetentionPolicies: RetentionPolicies,
  SchemaVersion: SchemaVersion,
  SerializationConfig: SerializationConfig,
  SerializerFactory: SerializerFactory,
  SerializerProvider: SerializerProvider,
  ShortBuilder: ShortBuilder,
  Sinks: Sinks,
  SinksWorkerService: SinksWorkerService,
  SocketAddress: SocketAddress,
  Sources: Sources,
  SourcesWorkerService: SourcesWorkerService,
  SubscribeRate: SubscribeRate,
  SubtypeResolver: SubtypeResolver,
  SystemResourceUsage: SystemResourceUsage,
  TenantInfo: TenantInfo,
  ThreadContainerFactory: ThreadContainerFactory,
  TimeZone: TimeZone,
  TypeBindings: TypeBindings,
  TypeFactory: TypeFactory,
  Value: Value,
  VisibilityChecker: VisibilityChecker,
  VisibilityCheckerObject: VisibilityCheckerObject,
  WorkerConfig: WorkerConfig,
  WorkerFunctionInstanceStats: WorkerFunctionInstanceStats,
  WorkerInfo: WorkerInfo,
  WorkerService: WorkerService,
  Workers: Workers,
  WorkersWorkerService: WorkersWorkerService,
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password,
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = "";

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == "header" &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum BookiesApiApiKeys {}

export class BookiesApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: BookiesApiApiKeys, value: string) {
    (this.authentications as any)[BookiesApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Removed the rack placement information for a specific bookie in the cluster
   * @param bookie
   * @param {*} [options] Override http request options.
   */
  public deleteBookieRackInfo(
    bookie: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/bookies/racks-info/{bookie}".replace(
        "{" + "bookie" + "}",
        encodeURIComponent(String(bookie))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'bookie' is not null or undefined
    if (bookie === null || bookie === undefined) {
      throw new Error(
        "Required parameter bookie was null or undefined when calling deleteBookieRackInfo."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Gets raw information for all the bookies in the cluster
   * @param {*} [options] Override http request options.
   */
  public getAllBookies(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: BookiesClusterInfo }> {
    const localVarPath = this.basePath + "/bookies/all";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: BookiesClusterInfo;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "BookiesClusterInfo");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Gets the rack placement information for a specific bookie in the cluster
   * @param bookie
   * @param {*} [options] Override http request options.
   */
  public getBookieRackInfo(
    bookie: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: BookieInfo }> {
    const localVarPath =
      this.basePath +
      "/bookies/racks-info/{bookie}".replace(
        "{" + "bookie" + "}",
        encodeURIComponent(String(bookie))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'bookie' is not null or undefined
    if (bookie === null || bookie === undefined) {
      throw new Error(
        "Required parameter bookie was null or undefined when calling getBookieRackInfo."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: BookieInfo }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "BookieInfo");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Gets the rack placement information for all the bookies in the cluster
   * @param {*} [options] Override http request options.
   */
  public getBookiesRackInfo(
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: { [key: string]: BookieInfo } };
  }> {
    const localVarPath = this.basePath + "/bookies/racks-info";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: { [key: string]: BookieInfo } };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: { [key: string]: BookieInfo; }; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Updates the rack placement information for a specific bookie in the cluster (note. bookie address format:`address:port`)
   * @param bookie
   * @param group
   * @param {*} [options] Override http request options.
   */
  public updateBookieRackInfo(
    bookie: string,
    group?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/bookies/racks-info/{bookie}".replace(
        "{" + "bookie" + "}",
        encodeURIComponent(String(bookie))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'bookie' is not null or undefined
    if (bookie === null || bookie === undefined) {
      throw new Error(
        "Required parameter bookie was null or undefined when calling updateBookieRackInfo."
      );
    }

    if (group !== undefined) {
      localVarQueryParameters["group"] = ObjectSerializer.serialize(
        group,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum BrokerStatsApiApiKeys {}

export class BrokerStatsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: BrokerStatsApiApiKeys, value: string) {
    (this.authentications as any)[BrokerStatsApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get the stats for the Netty allocator. Available allocators are 'default' and 'ml-cache'
   * @param allocator
   * @param {*} [options] Override http request options.
   */
  public getAllocatorStats(
    allocator: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: AllocatorStats }> {
    const localVarPath =
      this.basePath +
      "/broker-stats/allocator-stats/{allocator}".replace(
        "{" + "allocator" + "}",
        encodeURIComponent(String(allocator))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'allocator' is not null or undefined
    if (allocator === null || allocator === undefined) {
      throw new Error(
        "Required parameter allocator was null or undefined when calling getAllocatorStats."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: AllocatorStats }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "AllocatorStats");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This API gives the current broker availability in percent, each resource percentage usage is calculated and thensum of all of the resource usage percent is called broker-resource-availability<br/><br/>THIS API IS ONLY FOR USE BY TESTING FOR CONFIRMING NAMESPACE ALLOCATION ALGORITHM
   * @summary Broker availability report
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getBrokerResourceAvailability(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: ResourceUnit };
  }> {
    const localVarPath =
      this.basePath +
      "/broker-stats/broker-resource-availability/{tenant}/{namespace}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBrokerResourceAvailability."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBrokerResourceAvailability."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: ResourceUnit };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: ResourceUnit; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * consists of topics stats & systemResourceUsage
   * @summary Get Load for this broker
   * @param {*} [options] Override http request options.
   */
  public getLoadReport(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: LoadReport }> {
    const localVarPath = this.basePath + "/broker-stats/load-report";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: LoadReport }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "LoadReport");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get all the mbean details of this broker JVM
   * @param {*} [options] Override http request options.
   */
  public getMBeans(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<Metrics> }> {
    const localVarPath = this.basePath + "/broker-stats/mbeans";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<Metrics> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<Metrics>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Requested should be executed by Monitoring agent on each broker to fetch the metrics
   * @summary Gets the metrics for Monitoring
   * @param {*} [options] Override http request options.
   */
  public getMetrics(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<Metrics> }> {
    const localVarPath = this.basePath + "/broker-stats/metrics";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<Metrics> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<Metrics>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get pending bookie client op stats by namesapce
   * @param {*} [options] Override http request options.
   */
  public getPendingBookieOpsStats(
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: PendingBookieOpsStats };
  }> {
    const localVarPath = this.basePath + "/broker-stats/bookieops";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: PendingBookieOpsStats };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: PendingBookieOpsStats; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all the topic stats by namespace
   * @param {*} [options] Override http request options.
   */
  public getTopics2(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: OutputStream }> {
    const localVarPath = this.basePath + "/broker-stats/topics";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: OutputStream }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "OutputStream");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum BrokersApiApiKeys {}

export class BrokersApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: BrokersApiApiKeys, value: string) {
    (this.authentications as any)[BrokersApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary An REST endpoint to trigger backlogQuotaCheck
   * @param {*} [options] Override http request options.
   */
  public backlogQuotaCheck(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/brokers/backlog-quota-check";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete dynamic ServiceConfiguration into metadata only. This operation requires Pulsar super-user privileges.
   * @param configName
   * @param {*} [options] Override http request options.
   */
  public deleteDynamicConfiguration(
    configName: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/brokers/configuration/{configName}".replace(
        "{" + "configName" + "}",
        encodeURIComponent(String(configName))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'configName' is not null or undefined
    if (configName === null || configName === undefined) {
      throw new Error(
        "Required parameter configName was null or undefined when calling deleteDynamicConfiguration."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of active brokers (web service addresses) in the cluster.If authorization is not enabled, any cluster name is valid.
   * @param cluster
   * @param {*} [options] Override http request options.
   */
  public getActiveBrokers(
    cluster: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/brokers/{cluster}".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getActiveBrokers."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get value of all dynamic configurations' value overridden on local config
   * @param {*} [options] Override http request options.
   */
  public getAllDynamicConfigurations(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/brokers/configuration/values";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get all updatable dynamic configurations's name
   * @param {*} [options] Override http request options.
   */
  public getDynamicConfigurationName(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/brokers/configuration";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the internal configuration data
   * @param {*} [options] Override http request options.
   */
  public getInternalConfigurationData(
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: InternalConfigurationData;
  }> {
    const localVarPath = this.basePath + "/brokers/internal-configuration";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: InternalConfigurationData;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "InternalConfigurationData"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the information of the leader broker.
   * @param {*} [options] Override http request options.
   */
  public getLeaderBroker(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: BrokerInfo }> {
    const localVarPath = this.basePath + "/brokers/leaderBroker";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: BrokerInfo }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "BrokerInfo");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of namespaces served by the specific broker
   * @param clusterName
   * @param brokerWebserviceurl
   * @param {*} [options] Override http request options.
   */
  public getOwnedNamespaces(
    clusterName: string,
    brokerWebserviceurl: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: NamespaceOwnershipStatus };
  }> {
    const localVarPath =
      this.basePath +
      "/brokers/{clusterName}/{broker-webserviceurl}/ownedNamespaces"
        .replace(
          "{" + "clusterName" + "}",
          encodeURIComponent(String(clusterName))
        )
        .replace(
          "{" + "broker-webserviceurl" + "}",
          encodeURIComponent(String(brokerWebserviceurl))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'clusterName' is not null or undefined
    if (clusterName === null || clusterName === undefined) {
      throw new Error(
        "Required parameter clusterName was null or undefined when calling getOwnedNamespaces."
      );
    }

    // verify required parameter 'brokerWebserviceurl' is not null or undefined
    if (brokerWebserviceurl === null || brokerWebserviceurl === undefined) {
      throw new Error(
        "Required parameter brokerWebserviceurl was null or undefined when calling getOwnedNamespaces."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: NamespaceOwnershipStatus };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: NamespaceOwnershipStatus; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all runtime configurations. This operation requires Pulsar super-user privileges.
   * @param {*} [options] Override http request options.
   */
  public getRuntimeConfiguration(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/brokers/configuration/runtime";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Run a healthCheck against the broker
   * @param topicVersion
   * @param {*} [options] Override http request options.
   */
  public healthCheck(
    topicVersion?: "V1" | "V2",
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/brokers/health";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (topicVersion !== undefined) {
      localVarQueryParameters["topicVersion"] = ObjectSerializer.serialize(
        topicVersion,
        "'V1' | 'V2'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Check if the broker is fully initialized
   * @param {*} [options] Override http request options.
   */
  public isReady(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/brokers/ready";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Shutdown broker gracefully.
   * @param maxConcurrentUnloadPerSec if the value absent(value&#x3D;0) means no concurrent limitation.
   * @param forcedTerminateTopic
   * @param {*} [options] Override http request options.
   */
  public shutDownBrokerGracefully(
    maxConcurrentUnloadPerSec?: number,
    forcedTerminateTopic?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/brokers/shutdown";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (maxConcurrentUnloadPerSec !== undefined) {
      localVarQueryParameters["maxConcurrentUnloadPerSec"] =
        ObjectSerializer.serialize(maxConcurrentUnloadPerSec, "number");
    }

    if (forcedTerminateTopic !== undefined) {
      localVarQueryParameters["forcedTerminateTopic"] =
        ObjectSerializer.serialize(forcedTerminateTopic, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update dynamic serviceconfiguration into zk only. This operation requires Pulsar super-user privileges.
   * @param configName
   * @param configValue
   * @param {*} [options] Override http request options.
   */
  public updateDynamicConfiguration(
    configName: string,
    configValue: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/brokers/configuration/{configName}/{configValue}"
        .replace(
          "{" + "configName" + "}",
          encodeURIComponent(String(configName))
        )
        .replace(
          "{" + "configValue" + "}",
          encodeURIComponent(String(configValue))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'configName' is not null or undefined
    if (configName === null || configName === undefined) {
      throw new Error(
        "Required parameter configName was null or undefined when calling updateDynamicConfiguration."
      );
    }

    // verify required parameter 'configValue' is not null or undefined
    if (configValue === null || configValue === undefined) {
      throw new Error(
        "Required parameter configValue was null or undefined when calling updateDynamicConfiguration."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get version of current broker
   * @param {*} [options] Override http request options.
   */
  public version(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: string }> {
    const localVarPath = this.basePath + "/brokers/version";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ClustersApiApiKeys {}

export class ClustersApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ClustersApiApiKeys, value: string) {
    (this.authentications as any)[ClustersApiApiKeys[key]].apiKey = value;
  }
  /**
   * This operation requires Pulsar superuser privileges, and the name cannot contain the '/' characters.
   * @summary Create a new cluster.
   * @param cluster The cluster name
   * @param body The cluster data
   * @param {*} [options] Override http request options.
   */
  public createCluster(
    cluster: string,
    body: ClusterData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling createCluster."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling createCluster."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "ClusterData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Delete an existing cluster.
   * @param cluster The cluster name
   * @param {*} [options] Override http request options.
   */
  public deleteCluster(
    cluster: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling deleteCluster."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Delete the failure domain of the cluster
   * @param cluster The cluster name
   * @param domainName The failure domain name
   * @param {*} [options] Override http request options.
   */
  public deleteFailureDomain(
    cluster: string,
    domainName: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/failureDomains/{domainName}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace(
          "{" + "domainName" + "}",
          encodeURIComponent(String(domainName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling deleteFailureDomain."
      );
    }

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling deleteFailureDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Delete namespace isolation policy.
   * @param cluster The cluster name
   * @param policyName The namespace isolation policy name
   * @param {*} [options] Override http request options.
   */
  public deleteNamespaceIsolationPolicy(
    cluster: string,
    policyName: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/namespaceIsolationPolicies/{policyName}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace(
          "{" + "policyName" + "}",
          encodeURIComponent(String(policyName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling deleteNamespaceIsolationPolicy."
      );
    }

    // verify required parameter 'policyName' is not null or undefined
    if (policyName === null || policyName === undefined) {
      throw new Error(
        "Required parameter policyName was null or undefined when calling deleteNamespaceIsolationPolicy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get a broker with namespace-isolation policies attached to it.
   * @param cluster The cluster name
   * @param broker The broker name (&lt;broker-hostname&gt;:&lt;web-service-port&gt;)
   * @param {*} [options] Override http request options.
   */
  public getBrokerWithNamespaceIsolationPolicy(
    cluster: string,
    broker: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: BrokerNamespaceIsolationData;
  }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/namespaceIsolationPolicies/brokers/{broker}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace("{" + "broker" + "}", encodeURIComponent(String(broker)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getBrokerWithNamespaceIsolationPolicy."
      );
    }

    // verify required parameter 'broker' is not null or undefined
    if (broker === null || broker === undefined) {
      throw new Error(
        "Required parameter broker was null or undefined when calling getBrokerWithNamespaceIsolationPolicy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: BrokerNamespaceIsolationData;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "BrokerNamespaceIsolationData"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get list of brokers with namespace-isolation policies attached to them.
   * @param cluster The cluster name
   * @param {*} [options] Override http request options.
   */
  public getBrokersWithNamespaceIsolationPolicy(
    cluster: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: Array<BrokerNamespaceIsolationData>;
  }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/namespaceIsolationPolicies/brokers".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getBrokersWithNamespaceIsolationPolicy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<BrokerNamespaceIsolationData>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "Array<BrokerNamespaceIsolationData>"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get the configuration for the specified cluster.
   * @param cluster The cluster name
   * @param {*} [options] Override http request options.
   */
  public getCluster(
    cluster: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: ClusterData }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getCluster."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: ClusterData }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "ClusterData");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of all the Pulsar clusters.
   * @param {*} [options] Override http request options.
   */
  public getClusters(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath = this.basePath + "/clusters";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get a domain in a cluster
   * @param cluster The cluster name
   * @param domainName The failure domain name
   * @param {*} [options] Override http request options.
   */
  public getDomain(
    cluster: string,
    domainName: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: FailureDomain }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/failureDomains/{domainName}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace(
          "{" + "domainName" + "}",
          encodeURIComponent(String(domainName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getDomain."
      );
    }

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling getDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: FailureDomain }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "FailureDomain");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get the cluster failure domains.
   * @param cluster The cluster name
   * @param {*} [options] Override http request options.
   */
  public getFailureDomains(
    cluster: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: FailureDomain };
  }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/failureDomains".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getFailureDomains."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: FailureDomain };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: FailureDomain; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get the namespace isolation policies assigned to the cluster.
   * @param cluster The cluster name
   * @param {*} [options] Override http request options.
   */
  public getNamespaceIsolationPolicies(
    cluster: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: NamespaceIsolationData };
  }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/namespaceIsolationPolicies".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getNamespaceIsolationPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: NamespaceIsolationData };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: NamespaceIsolationData; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get the single namespace isolation policy assigned to the cluster.
   * @param cluster The cluster name
   * @param policyName The name of the namespace isolation policy
   * @param {*} [options] Override http request options.
   */
  public getNamespaceIsolationPolicy(
    cluster: string,
    policyName: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: NamespaceIsolationData }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/namespaceIsolationPolicies/{policyName}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace(
          "{" + "policyName" + "}",
          encodeURIComponent(String(policyName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getNamespaceIsolationPolicy."
      );
    }

    // verify required parameter 'policyName' is not null or undefined
    if (policyName === null || policyName === undefined) {
      throw new Error(
        "Required parameter policyName was null or undefined when calling getNamespaceIsolationPolicy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: NamespaceIsolationData;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "NamespaceIsolationData");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Get the peer-cluster data for the specified cluster.
   * @param cluster The cluster name
   * @param {*} [options] Override http request options.
   */
  public getPeerCluster(
    cluster: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/peers".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getPeerCluster."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Set the failure domain of the cluster.
   * @param cluster The cluster name
   * @param domainName The failure domain name
   * @param body The configuration data of a failure domain
   * @param {*} [options] Override http request options.
   */
  public setFailureDomain(
    cluster: string,
    domainName: string,
    body: FailureDomain,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/failureDomains/{domainName}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace(
          "{" + "domainName" + "}",
          encodeURIComponent(String(domainName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling setFailureDomain."
      );
    }

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling setFailureDomain."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setFailureDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "FailureDomain"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Set namespace isolation policy.
   * @param cluster The cluster name
   * @param policyName The namespace isolation policy name
   * @param body The namespace isolation policy data
   * @param {*} [options] Override http request options.
   */
  public setNamespaceIsolationPolicy(
    cluster: string,
    policyName: string,
    body: NamespaceIsolationData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/namespaceIsolationPolicies/{policyName}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace(
          "{" + "policyName" + "}",
          encodeURIComponent(String(policyName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling setNamespaceIsolationPolicy."
      );
    }

    // verify required parameter 'policyName' is not null or undefined
    if (policyName === null || policyName === undefined) {
      throw new Error(
        "Required parameter policyName was null or undefined when calling setNamespaceIsolationPolicy."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setNamespaceIsolationPolicy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "NamespaceIsolationData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Update peer-cluster-list for a cluster.
   * @param cluster The cluster name
   * @param body The list of peer cluster names
   * @param {*} [options] Override http request options.
   */
  public setPeerClusterNames(
    cluster: string,
    body: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}/peers".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling setPeerClusterNames."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setPeerClusterNames."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar superuser privileges.
   * @summary Update the configuration for a cluster.
   * @param cluster The cluster name
   * @param body The cluster data
   * @param {*} [options] Override http request options.
   */
  public updateCluster(
    cluster: string,
    body: ClusterData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/clusters/{cluster}".replace(
        "{" + "cluster" + "}",
        encodeURIComponent(String(cluster))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling updateCluster."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling updateCluster."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "ClusterData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum DefaultApiApiKeys {}

export class DefaultApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DefaultApiApiKeys, value: string) {
    (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Drains this worker, i.e., moves its work-assignments to other workers
   * @param {*} [options] Override http request options.
   */
  public drain(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/worker/drain";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Drains the specified worker, i.e., moves its work-assignments to other workers
   * @param workerId
   * @param {*} [options] Override http request options.
   */
  public drainAtLeader(
    workerId?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/worker/leader/drain";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (workerId !== undefined) {
      localVarQueryParameters["workerId"] = ObjectSerializer.serialize(
        workerId,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Fetches information about which Pulsar Functions are assigned to which Pulsar clusters
   * @param {*} [options] Override http request options.
   */
  public getAssignments(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: { [key: string]: any } }> {
    const localVarPath = this.basePath + "/worker/assignments";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: any };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "{ [key: string]: any; }");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Fetches information about the Pulsar cluster running Pulsar Functions
   * @param {*} [options] Override http request options.
   */
  public getCluster(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<WorkerInfo> }> {
    const localVarPath = this.basePath + "/worker/cluster";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<WorkerInfo>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<WorkerInfo>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Fetches info about the leader node of the Pulsar cluster running Pulsar Functions
   * @param {*} [options] Override http request options.
   */
  public getClusterLeader(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: WorkerInfo }> {
    const localVarPath = this.basePath + "/worker/cluster/leader";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: WorkerInfo }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "WorkerInfo");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Fetches a list of supported Pulsar IO connectors currently running in cluster mode
   * @param {*} [options] Override http request options.
   */
  public getConnectorsList(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<any> }> {
    const localVarPath = this.basePath + "/worker/connectors";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<any> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<any>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the status of any ongoing drain operation at this worker
   * @param {*} [options] Override http request options.
   */
  public getDrainStatus(
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: LongRunningProcessStatus;
  }> {
    const localVarPath = this.basePath + "/worker/drain";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: LongRunningProcessStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "LongRunningProcessStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the status of any ongoing drain operation at the specified worker
   * @param workerId
   * @param {*} [options] Override http request options.
   */
  public getDrainStatusFromLeader(
    workerId?: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: LongRunningProcessStatus;
  }> {
    const localVarPath = this.basePath + "/worker/leader/drain";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (workerId !== undefined) {
      localVarQueryParameters["workerId"] = ObjectSerializer.serialize(
        workerId,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: LongRunningProcessStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "LongRunningProcessStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Request should be executed by Monitoring agent on each worker to fetch the worker-metrics
   * @summary Gets the metrics for Monitoring
   * @param {*} [options] Override http request options.
   */
  public getMetrics(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<Metrics> }> {
    const localVarPath = this.basePath + "/worker-stats/metrics";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<Metrics> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<Metrics>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Requested should be executed by Monitoring agent on each worker to fetch the metrics
   * @summary Get metrics for all functions owned by worker
   * @param {*} [options] Override http request options.
   */
  public getStats(
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: Array<WorkerFunctionInstanceStats>;
  }> {
    const localVarPath = this.basePath + "/worker-stats/functionsmetrics";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: Array<WorkerFunctionInstanceStats>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "Array<WorkerFunctionInstanceStats>"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Checks if this node is the leader and is ready to service requests
   * @param {*} [options] Override http request options.
   */
  public isLeaderReady(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: boolean }> {
    const localVarPath = this.basePath + "/worker/cluster/leader/ready";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: boolean }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "boolean");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Triggers a rebalance of functions to workers
   * @param {*} [options] Override http request options.
   */
  public rebalance(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath = this.basePath + "/worker/rebalance";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum NamespacesApiApiKeys {}

export class NamespacesApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: NamespacesApiApiKeys, value: string) {
    (this.authentications as any)[NamespacesApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Clear backlog for all topics on a namespace.
   * @param tenant
   * @param namespace
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public clearNamespaceBacklog(
    tenant: string,
    namespace: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/clearBacklog"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling clearNamespaceBacklog."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling clearNamespaceBacklog."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Clear backlog for a given subscription on all topics on a namespace.
   * @param tenant
   * @param namespace
   * @param subscription
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public clearNamespaceBacklogForSubscription(
    tenant: string,
    namespace: string,
    subscription: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/clearBacklog/{subscription}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace(
          "{" + "subscription" + "}",
          encodeURIComponent(String(subscription))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling clearNamespaceBacklogForSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling clearNamespaceBacklogForSubscription."
      );
    }

    // verify required parameter 'subscription' is not null or undefined
    if (subscription === null || subscription === undefined) {
      throw new Error(
        "Required parameter subscription was null or undefined when calling clearNamespaceBacklogForSubscription."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Clear backlog for all topics on a namespace bundle.
   * @param tenant
   * @param namespace
   * @param bundle
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public clearNamespaceBundleBacklog(
    tenant: string,
    namespace: string,
    bundle: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling clearNamespaceBundleBacklog."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling clearNamespaceBundleBacklog."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling clearNamespaceBundleBacklog."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Clear backlog for a given subscription on all topics on a namespace bundle.
   * @param tenant
   * @param namespace
   * @param subscription
   * @param bundle
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public clearNamespaceBundleBacklogForSubscription(
    tenant: string,
    namespace: string,
    subscription: string,
    bundle: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/{bundle}/clearBacklog/{subscription}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace(
          "{" + "subscription" + "}",
          encodeURIComponent(String(subscription))
        )
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling clearNamespaceBundleBacklogForSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling clearNamespaceBundleBacklogForSubscription."
      );
    }

    // verify required parameter 'subscription' is not null or undefined
    if (subscription === null || subscription === undefined) {
      throw new Error(
        "Required parameter subscription was null or undefined when calling clearNamespaceBundleBacklogForSubscription."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling clearNamespaceBundleBacklogForSubscription."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Clear the namespace configured offload deletion lag. The topics in the namespace will fallback to using the default configured deletion lag for the broker
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public clearOffloadDeletionLag(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling clearOffloadDeletionLag."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling clearOffloadDeletionLag."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get property value for a given key on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public clearProperties(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/properties"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling clearProperties."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling clearProperties."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Creates a new namespace with the specified policies
   * @param tenant
   * @param namespace
   * @param body Policies for the namespace
   * @param {*} [options] Override http request options.
   */
  public createNamespace(
    tenant: string,
    namespace: string,
    body?: Policies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createNamespace."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createNamespace."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Policies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete the bookie-affinity-group from namespace-local policy.
   * @param property
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public deleteBookieAffinityGroup(
    property: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{property}/{namespace}/persistence/bookieAffinity"
        .replace("{" + "property" + "}", encodeURIComponent(String(property)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'property' is not null or undefined
    if (property === null || property === undefined) {
      throw new Error(
        "Required parameter property was null or undefined when calling deleteBookieAffinityGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteBookieAffinityGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
   * @summary Delete maximum number of uncompacted bytes in a topic before compaction is triggered.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public deleteCompactionThreshold(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteCompactionThreshold."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete dispatch-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public deleteDispatchRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a namespace and all the topics under it.
   * @param tenant
   * @param namespace
   * @param force
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public deleteNamespace(
    tenant: string,
    namespace: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteNamespace."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteNamespace."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a namespace bundle and all the topics under it.
   * @param tenant
   * @param namespace
   * @param bundle
   * @param force
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public deleteNamespaceBundle(
    tenant: string,
    namespace: string,
    bundle: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/{bundle}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteNamespaceBundle."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteNamespaceBundle."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling deleteNamespaceBundle."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete the persistence configuration for all topics on a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public deletePersistence(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deletePersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deletePersistence."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete subscribe-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public deleteSubscribeRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteSubscribeRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete Subscription dispatch-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public deleteSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteSubscriptionDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get all namespaces that are grouped by given anti-affinity group in a given cluster. api can be only accessed by admin of any of the existing tenant
   * @param cluster
   * @param group
   * @param tenant
   * @param {*} [options] Override http request options.
   */
  public getAntiAffinityNamespaces(
    cluster: string,
    group: string,
    tenant?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{cluster}/antiAffinity/{group}"
        .replace("{" + "cluster" + "}", encodeURIComponent(String(cluster)))
        .replace("{" + "group" + "}", encodeURIComponent(String(group)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'cluster' is not null or undefined
    if (cluster === null || cluster === undefined) {
      throw new Error(
        "Required parameter cluster was null or undefined when calling getAntiAffinityNamespaces."
      );
    }

    // verify required parameter 'group' is not null or undefined
    if (group === null || group === undefined) {
      throw new Error(
        "Required parameter group was null or undefined when calling getAntiAffinityNamespaces."
      );
    }

    if (tenant !== undefined) {
      localVarQueryParameters["tenant"] = ObjectSerializer.serialize(
        tenant,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get autoSubscriptionCreation info in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getAutoSubscriptionCreation(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: AutoSubscriptionCreationOverride;
  }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/autoSubscriptionCreation"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getAutoSubscriptionCreation."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getAutoSubscriptionCreation."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: AutoSubscriptionCreationOverride;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "AutoSubscriptionCreationOverride"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get autoTopicCreation info in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getAutoTopicCreation(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/autoTopicCreation"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getAutoTopicCreation."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getAutoTopicCreation."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get backlog quota map on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getBacklogQuotaMap(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: BacklogQuota };
  }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/backlogQuotaMap"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBacklogQuotaMap."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBacklogQuotaMap."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: BacklogQuota };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: BacklogQuota; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the bookie-affinity-group from namespace-local policy.
   * @param property
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getBookieAffinityGroup(
    property: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: BookieAffinityGroupData }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{property}/{namespace}/persistence/bookieAffinity"
        .replace("{" + "property" + "}", encodeURIComponent(String(property)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'property' is not null or undefined
    if (property === null || property === undefined) {
      throw new Error(
        "Required parameter property was null or undefined when calling getBookieAffinityGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBookieAffinityGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: BookieAffinityGroupData;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "BookieAffinityGroupData");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the bundles split data.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getBundlesData(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: BundlesData }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/bundles"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBundlesData."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBundlesData."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: BundlesData }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "BundlesData");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
   * @summary Maximum number of uncompacted bytes in topics before compaction is triggered.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getCompactionThreshold(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getCompactionThreshold."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get broker side deduplication for all topics in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getDeduplication(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/deduplication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDeduplication."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get deduplicationSnapshotInterval config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get delayed delivery messages config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: DelayedDeliveryPolicies }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: DelayedDeliveryPolicies;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "DelayedDeliveryPolicies");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get dispatch-rate configured for the namespace, null means dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getDispatchRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: DispatchRate }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: DispatchRate }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "DispatchRate");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message encryption required status in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getEncryptionRequired(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: boolean }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/encryptionRequired"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getEncryptionRequired."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getEncryptionRequired."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: boolean }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "boolean");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get inactive topic policies config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: InactiveTopicPolicies }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: InactiveTopicPolicies;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InactiveTopicPolicies");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary The flag of whether allow auto update schema
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getIsAllowAutoUpdateSchema(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: boolean }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getIsAllowAutoUpdateSchema."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getIsAllowAutoUpdateSchema."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: boolean }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "boolean");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxConsumersPerSubscription config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxConsumersPerTopic config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getMaxConsumersPerTopic(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxConsumersPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxConsumersPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxConsumersPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxProducersPerTopic config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getMaxProducersPerTopic(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxProducersPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxProducersPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxProducersPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxSubscriptionsPerTopic config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxTopicsPerNamespace config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getMaxTopicsPerNamespace(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxTopicsPerNamespace"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxTopicsPerNamespace."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxTopicsPerNamespace."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxUnackedMessagesPerConsumer config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getMaxUnackedMessagesPerConsumer(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxUnackedMessagesPerConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxUnackedMessagesPerConsumer."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxUnackedMessagesPerSubscription config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getMaxUnackedmessagesPerSubscription(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxUnackedmessagesPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxUnackedmessagesPerSubscription."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get anti-affinity group of a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getNamespaceAntiAffinityGroup(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: string }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/antiAffinity"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getNamespaceAntiAffinityGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getNamespaceAntiAffinityGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the message TTL for the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getNamespaceMessageTTL(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getNamespaceMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getNamespaceMessageTTL."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the replication clusters for a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getNamespaceReplicationClusters(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getNamespaceReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getNamespaceReplicationClusters."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the resourcegroup attached to the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getNamespaceResourceGroup(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: string }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/resourcegroup"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getNamespaceResourceGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getNamespaceResourceGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * A negative value denotes that deletion has been completely disabled. 'null' denotes that the topics in the namespace will fall back to the broker default for deletion lag.
   * @summary Number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getOffloadDeletionLag(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getOffloadDeletionLag."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getOffloadDeletionLag."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get offload configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getOffloadPolicies(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: OffloadPoliciesImpl }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getOffloadPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: OffloadPoliciesImpl;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "OffloadPoliciesImpl");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * A negative value disables automatic offloading
   * @summary Maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getOffloadThreshold(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/offloadThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getOffloadThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getOffloadThreshold."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Retrieve the permissions for a subscription.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getPermissionOnSubscription(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: { [key: string]: Array<string> };
  }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/permissions/subscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPermissionOnSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPermissionOnSubscription."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: { [key: string]: Array<string> };
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "{ [key: string]: Array<string>; }"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Retrieve the permissions for a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getPermissions(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/permissions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPermissions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPermissions."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the persistence configuration for a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getPersistence(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: PersistencePolicies }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPersistence."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: PersistencePolicies;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "PersistencePolicies");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the dump all the policies specified for a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getPolicies(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Policies }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Policies }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Policies");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get key value pair properties for a given namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getProperties(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/properties"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getProperties."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getProperties."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get property value for a given key on a namespace.
   * @param tenant
   * @param namespace
   * @param key
   * @param {*} [options] Override http request options.
   */
  public getProperty(
    tenant: string,
    namespace: string,
    key: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/property/{key}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "key" + "}", encodeURIComponent(String(key)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getProperty."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getProperty."
      );
    }

    // verify required parameter 'key' is not null or undefined
    if (key === null || key === undefined) {
      throw new Error(
        "Required parameter key was null or undefined when calling getProperty."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get replicator dispatch-rate configured for the namespace, null means replicator dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: DispatchRate }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: DispatchRate }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "DispatchRate");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get retention config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getRetention(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: RetentionPolicies }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getRetention."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: RetentionPolicies;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RetentionPolicies");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
   * @summary The strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getSchemaAutoUpdateCompatibilityStrategy(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: string }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchemaAutoUpdateCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchemaAutoUpdateCompatibilityStrategy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary The strategy of the namespace schema compatibility
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: string }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
   * @summary Get schema validation enforced flag for namespace.
   * @param tenant
   * @param namespace
   * @param applied
   * @param {*} [options] Override http request options.
   */
  public getSchemaValidtionEnforced(
    tenant: string,
    namespace: string,
    applied?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: boolean }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/schemaValidationEnforced"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchemaValidtionEnforced."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchemaValidtionEnforced."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: boolean }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "boolean");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get subscribe-rate configured for the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getSubscribeRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: SubscribeRate }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscribeRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: SubscribeRate }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "SubscribeRate");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get subscription auth mode in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionAuthMode(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: string }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionAuthMode"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionAuthMode."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionAuthMode."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "string");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get subscription dispatch-rate configured for the namespace, null means subscription dispatch-rate not configured, -1 means msg-dispatch-rate or byte-dispatch-rate not configured in dispatch-rate yet
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: DispatchRate }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: DispatchRate }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "DispatchRate");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the subscription expiration time for the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionExpirationTime(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: number }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionExpirationTime"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionExpirationTime."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionExpirationTime."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: number }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "number");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary The set of whether allow subscription types
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of all the namespaces for a certain tenant.
   * @param tenant
   * @param {*} [options] Override http request options.
   */
  public getTenantNamespaces(
    tenant: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}".replace(
        "{" + "tenant" + "}",
        encodeURIComponent(String(tenant))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getTenantNamespaces."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get hash positions for topics
   * @param tenant
   * @param namespace
   * @param bundle
   * @param topics
   * @param {*} [options] Override http request options.
   */
  public getTopicHashPositions(
    tenant: string,
    namespace: string,
    bundle: string,
    topics?: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/{bundle}/topicHashPositions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getTopicHashPositions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getTopicHashPositions."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling getTopicHashPositions."
      );
    }

    if (topics !== undefined) {
      localVarQueryParameters["topics"] = ObjectSerializer.serialize(
        topics,
        "Array<string>"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of all the topics under a certain namespace.
   * @param tenant
   * @param namespace
   * @param mode
   * @param {*} [options] Override http request options.
   */
  public getTopics(
    tenant: string,
    namespace: string,
    mode?: "PERSISTENT" | "NON_PERSISTENT" | "ALL",
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/topics"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getTopics."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getTopics."
      );
    }

    if (mode !== undefined) {
      localVarQueryParameters["mode"] = ObjectSerializer.serialize(
        mode,
        "'PERSISTENT' | 'NON_PERSISTENT' | 'ALL'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Grant a new permission to a role on a namespace.
   * @param tenant
   * @param namespace
   * @param role
   * @param body List of permissions for the specified role
   * @param {*} [options] Override http request options.
   */
  public grantPermissionOnNamespace(
    tenant: string,
    namespace: string,
    role: string,
    body?: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/permissions/{role}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "role" + "}", encodeURIComponent(String(role)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling grantPermissionOnNamespace."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling grantPermissionOnNamespace."
      );
    }

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        "Required parameter role was null or undefined when calling grantPermissionOnNamespace."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Enable or disable broker side deduplication for all topics in a namespace
   * @param tenant
   * @param namespace
   * @param body Flag for disabling or enabling broker side deduplication for all topics in the specified namespace
   * @param {*} [options] Override http request options.
   */
  public modifyDeduplication(
    tenant: string,
    namespace: string,
    body: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/deduplication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling modifyDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling modifyDeduplication."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling modifyDeduplication."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Message encryption is required or not for all topics in a namespace
   * @param tenant
   * @param namespace
   * @param body Flag defining if message encryption is required
   * @param {*} [options] Override http request options.
   */
  public modifyEncryptionRequired(
    tenant: string,
    namespace: string,
    body: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/encryptionRequired"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling modifyEncryptionRequired."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling modifyEncryptionRequired."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling modifyEncryptionRequired."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove override of broker's allowAutoSubscriptionCreation in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeAutoSubscriptionCreation(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/autoSubscriptionCreation"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeAutoSubscriptionCreation."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeAutoSubscriptionCreation."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove override of broker's allowAutoTopicCreation in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeAutoTopicCreation(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/autoTopicCreation"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeAutoTopicCreation."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeAutoTopicCreation."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove a backlog quota policy from a namespace.
   * @param tenant
   * @param namespace
   * @param backlogQuotaType
   * @param {*} [options] Override http request options.
   */
  public removeBacklogQuota(
    tenant: string,
    namespace: string,
    backlogQuotaType?: "destination_storage" | "message_age",
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/backlogQuota"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeBacklogQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeBacklogQuota."
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove broker side deduplication for all topics in a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeDeduplication(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/deduplication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeDeduplication."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete delayed delivery messages config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeDelayedDeliveryPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove inactive topic policies from a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeInactiveTopicPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set maxConsumersPerSubscription configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxConsumersPerTopic configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeMaxConsumersPerTopic(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxConsumersPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxConsumersPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxConsumersPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxProducersPerTopic configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeMaxProducersPerTopic(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxProducersPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxProducersPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxProducersPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxSubscriptionsPerTopic configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxUnackedMessagesPerConsumer config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeMaxUnackedmessagesPerConsumer(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxUnackedmessagesPerConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxUnackedmessagesPerConsumer."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxUnackedMessagesPerSubscription config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeMaxUnackedmessagesPerSubscription(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxUnackedmessagesPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxUnackedmessagesPerSubscription."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove anti-affinity group of a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeNamespaceAntiAffinityGroup(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/antiAffinity"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeNamespaceAntiAffinityGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeNamespaceAntiAffinityGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message TTL in seconds for namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeNamespaceMessageTTL(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeNamespaceMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeNamespaceMessageTTL."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete resourcegroup for a namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeNamespaceResourceGroup(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/resourcegroup"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeNamespaceResourceGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeNamespaceResourceGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set offload configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeOffloadPolicies(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/removeOffloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeOffloadPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get property value for a given key on a namespace.
   * @param tenant
   * @param namespace
   * @param key
   * @param {*} [options] Override http request options.
   */
  public removeProperty(
    tenant: string,
    namespace: string,
    key: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/property/{key}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "key" + "}", encodeURIComponent(String(key)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeProperty."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeProperty."
      );
    }

    // verify required parameter 'key' is not null or undefined
    if (key === null || key === undefined) {
      throw new Error(
        "Required parameter key was null or undefined when calling removeProperty."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove replicator dispatch-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Remove retention configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Retention policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public removeRetention(
    tenant: string,
    namespace: string,
    body?: RetentionPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeRetention."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RetentionPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove subscription expiration time for namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionExpirationTime(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionExpirationTime"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionExpirationTime."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionExpirationTime."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Remove subscription types enabled on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Revoke all permissions to a role on a namespace.
   * @param tenant
   * @param namespace
   * @param role
   * @param {*} [options] Override http request options.
   */
  public revokePermissionsOnNamespace(
    tenant: string,
    namespace: string,
    role: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/permissions/{role}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "role" + "}", encodeURIComponent(String(role)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling revokePermissionsOnNamespace."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling revokePermissionsOnNamespace."
      );
    }

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        "Required parameter role was null or undefined when calling revokePermissionsOnNamespace."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Trigger the scan of offloaded Ledgers on the LedgerOffloader for the given namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public scanOffloadedLedgers(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/scanOffloadedLedgers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling scanOffloadedLedgers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling scanOffloadedLedgers."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Override broker's allowAutoSubscriptionCreation setting for a namespace
   * @param tenant
   * @param namespace
   * @param body Settings for automatic subscription creation
   * @param {*} [options] Override http request options.
   */
  public setAutoSubscriptionCreation(
    tenant: string,
    namespace: string,
    body?: AutoSubscriptionCreationOverride,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/autoSubscriptionCreation"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setAutoSubscriptionCreation."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setAutoSubscriptionCreation."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        body,
        "AutoSubscriptionCreationOverride"
      ),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Override broker's allowAutoTopicCreation setting for a namespace
   * @param tenant
   * @param namespace
   * @param body Settings for automatic topic creation
   * @param {*} [options] Override http request options.
   */
  public setAutoTopicCreation(
    tenant: string,
    namespace: string,
    body: AutoTopicCreationOverride,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/autoTopicCreation"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setAutoTopicCreation."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setAutoTopicCreation."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setAutoTopicCreation."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "AutoTopicCreationOverride"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set a backlog quota for all the topics on a namespace.
   * @param tenant
   * @param namespace
   * @param backlogQuotaType
   * @param body Backlog quota for all topics of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setBacklogQuota(
    tenant: string,
    namespace: string,
    backlogQuotaType?: "destination_storage" | "message_age",
    body?: BacklogQuota,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/backlogQuota"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setBacklogQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setBacklogQuota."
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "BacklogQuota"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set the bookie-affinity-group to namespace-persistent policy.
   * @param tenant
   * @param namespace
   * @param body Bookie affinity group for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setBookieAffinityGroup(
    tenant: string,
    namespace: string,
    body?: BookieAffinityGroupData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/persistence/bookieAffinity"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setBookieAffinityGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setBookieAffinityGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "BookieAffinityGroupData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The backlog size is compared to the threshold periodically. A threshold of 0 disabled automatic compaction
   * @summary Set maximum number of uncompacted bytes in a topic before compaction is triggered.
   * @param tenant
   * @param namespace
   * @param body Maximum number of uncompacted bytes in a topic of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setCompactionThreshold(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setCompactionThreshold."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setCompactionThreshold."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set deduplicationSnapshotInterval config on a namespace.
   * @param tenant
   * @param namespace
   * @param body Interval to take deduplication snapshot per topic
   * @param {*} [options] Override http request options.
   */
  public setDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set delayed delivery messages config on a namespace.
   * @param tenant
   * @param namespace
   * @param body Delayed delivery policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    body?: DelayedDeliveryPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DelayedDeliveryPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set dispatch-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param body Dispatch rate for all topics of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setDispatchRate(
    tenant: string,
    namespace: string,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set inactive topic policies config on a namespace.
   * @param tenant
   * @param namespace
   * @param body Inactive topic policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    body?: InactiveTopicPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "InactiveTopicPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxTopicsPerNamespace config on a namespace.
   * @param tenant
   * @param namespace
   * @param body Number of maximum topics for specific namespace
   * @param {*} [options] Override http request options.
   */
  public setInactiveTopicPolicies_1(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxTopicsPerNamespace"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setInactiveTopicPolicies_1."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setInactiveTopicPolicies_1."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setInactiveTopicPolicies_1."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxTopicsPerNamespace config on a namespace.
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public setInactiveTopicPolicies_2(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxTopicsPerNamespace"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setInactiveTopicPolicies_2."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setInactiveTopicPolicies_2."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update flag of whether allow auto update schema
   * @param tenant
   * @param namespace
   * @param body Flag of whether to allow auto update schema
   * @param {*} [options] Override http request options.
   */
  public setIsAllowAutoUpdateSchema(
    tenant: string,
    namespace: string,
    body: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/isAllowAutoUpdateSchema"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setIsAllowAutoUpdateSchema."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setIsAllowAutoUpdateSchema."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setIsAllowAutoUpdateSchema."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set maxConsumersPerSubscription configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Number of maximum consumers per subscription
   * @param {*} [options] Override http request options.
   */
  public setMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set maxConsumersPerTopic configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Number of maximum consumers per topic
   * @param {*} [options] Override http request options.
   */
  public setMaxConsumersPerTopic(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxConsumersPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxConsumersPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxConsumersPerTopic."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setMaxConsumersPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set maxProducersPerTopic configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Number of maximum producers per topic
   * @param {*} [options] Override http request options.
   */
  public setMaxProducersPerTopic(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxProducersPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxProducersPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxProducersPerTopic."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setMaxProducersPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set maxSubscriptionsPerTopic configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Number of maximum subscriptions per topic
   * @param {*} [options] Override http request options.
   */
  public setMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set maxConsumersPerTopic configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Number of maximum unacked messages per consumer
   * @param {*} [options] Override http request options.
   */
  public setMaxUnackedMessagesPerConsumer(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxUnackedMessagesPerConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxUnackedMessagesPerConsumer."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setMaxUnackedMessagesPerConsumer."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set maxUnackedMessagesPerSubscription configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Number of maximum unacked messages per subscription
   * @param {*} [options] Override http request options.
   */
  public setMaxUnackedMessagesPerSubscription(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/maxUnackedMessagesPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxUnackedMessagesPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxUnackedMessagesPerSubscription."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setMaxUnackedMessagesPerSubscription."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set anti-affinity group for a namespace
   * @param tenant
   * @param namespace
   * @param body Anti-affinity group for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setNamespaceAntiAffinityGroup(
    tenant: string,
    namespace: string,
    body: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/antiAffinity"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setNamespaceAntiAffinityGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setNamespaceAntiAffinityGroup."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setNamespaceAntiAffinityGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message TTL in seconds for namespace
   * @param tenant
   * @param namespace
   * @param body TTL in seconds for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setNamespaceMessageTTL(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setNamespaceMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setNamespaceMessageTTL."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setNamespaceMessageTTL."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set the replication clusters for a namespace.
   * @param tenant
   * @param namespace
   * @param body List of replication clusters
   * @param {*} [options] Override http request options.
   */
  public setNamespaceReplicationClusters(
    tenant: string,
    namespace: string,
    body: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setNamespaceReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setNamespaceReplicationClusters."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setNamespaceReplicationClusters."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set resourcegroup for a namespace
   * @param tenant
   * @param namespace
   * @param resourcegroup
   * @param {*} [options] Override http request options.
   */
  public setNamespaceResourceGroup(
    tenant: string,
    namespace: string,
    resourcegroup: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/resourcegroup/{resourcegroup}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace(
          "{" + "resourcegroup" + "}",
          encodeURIComponent(String(resourcegroup))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setNamespaceResourceGroup."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setNamespaceResourceGroup."
      );
    }

    // verify required parameter 'resourcegroup' is not null or undefined
    if (resourcegroup === null || resourcegroup === undefined) {
      throw new Error(
        "Required parameter resourcegroup was null or undefined when calling setNamespaceResourceGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * A negative value disables the deletion completely.
   * @summary Set number of milliseconds to wait before deleting a ledger segment which has been offloaded from the Pulsar cluster's local storage (i.e. BookKeeper)
   * @param tenant
   * @param namespace
   * @param body New number of milliseconds to wait before deleting a ledger segment which has been offloaded
   * @param {*} [options] Override http request options.
   */
  public setOffloadDeletionLag(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/offloadDeletionLagMs"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setOffloadDeletionLag."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setOffloadDeletionLag."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setOffloadDeletionLag."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set offload configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Offload policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setOffloadPolicies(
    tenant: string,
    namespace: string,
    body: OffloadPoliciesImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setOffloadPolicies."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setOffloadPolicies."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "OffloadPoliciesImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * -1 will revert to using the cluster default. A negative value disables automatic offloading.
   * @summary Set maximum number of bytes stored on the pulsar cluster for a topic, before the broker will start offloading to longterm storage
   * @param tenant
   * @param namespace
   * @param body Maximum number of bytes stored on the pulsar cluster for a topic of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setOffloadThreshold(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/offloadThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setOffloadThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setOffloadThreshold."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setOffloadThreshold."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set the persistence configuration for all the topics on a namespace.
   * @param tenant
   * @param namespace
   * @param body Persistence policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setPersistence(
    tenant: string,
    namespace: string,
    body: PersistencePolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setPersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setPersistence."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setPersistence."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PersistencePolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Put key value pairs property on a namespace.
   * @param tenant
   * @param namespace
   * @param body Key value pair properties for the namespace
   * @param {*} [options] Override http request options.
   */
  public setProperties(
    tenant: string,
    namespace: string,
    body: any,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/properties"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setProperties."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setProperties."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setProperties."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "any"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Put a key value pair property on a namespace.
   * @param tenant
   * @param namespace
   * @param key
   * @param value
   * @param {*} [options] Override http request options.
   */
  public setProperty(
    tenant: string,
    namespace: string,
    key: string,
    value: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/property/{key}/{value}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "key" + "}", encodeURIComponent(String(key)))
        .replace("{" + "value" + "}", encodeURIComponent(String(value)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setProperty."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setProperty."
      );
    }

    // verify required parameter 'key' is not null or undefined
    if (key === null || key === undefined) {
      throw new Error(
        "Required parameter key was null or undefined when calling setProperty."
      );
    }

    // verify required parameter 'value' is not null or undefined
    if (value === null || value === undefined) {
      throw new Error(
        "Required parameter value was null or undefined when calling setProperty."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set replicator dispatch-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param body Replicator dispatch rate for all topics of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set retention configuration on a namespace.
   * @param tenant
   * @param namespace
   * @param body Retention policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setRetention(
    tenant: string,
    namespace: string,
    body?: RetentionPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setRetention."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RetentionPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The value AutoUpdateDisabled prevents producers from updating the schema.  If set to AutoUpdateDisabled, schemas must be updated through the REST api
   * @summary Update the strategy used to check the compatibility of new schemas, provided by producers, before automatically updating the schema
   * @param tenant
   * @param namespace
   * @param body Strategy used to check the compatibility of new schemas
   * @param {*} [options] Override http request options.
   */
  public setSchemaAutoUpdateCompatibilityStrategy(
    tenant: string,
    namespace: string,
    body?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/schemaAutoUpdateCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSchemaAutoUpdateCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSchemaAutoUpdateCompatibilityStrategy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update the strategy used to check the compatibility of new schema
   * @param tenant
   * @param namespace
   * @param body Strategy used to check the compatibility of new schema
   * @param {*} [options] Override http request options.
   */
  public setSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    body?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * If the flag is set to true, when a producer without a schema attempts to produce to a topic with schema in this namespace, the producer will be failed to connect. PLEASE be carefully on using this, since non-java clients don't support schema.if you enable this setting, it will cause non-java clients failed to produce.
   * @summary Set schema validation enforced flag on namespace.
   * @param tenant
   * @param namespace
   * @param body Flag of whether validation is enforced on the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setSchemaValidationEnforced(
    tenant: string,
    namespace: string,
    body: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/schemaValidationEnforced"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set subscribe-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param body Subscribe rate for all topics of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setSubscribeRate(
    tenant: string,
    namespace: string,
    body?: SubscribeRate,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscribeRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "SubscribeRate"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary  Set a subscription auth mode for all the topics on a namespace.
   * @param tenant
   * @param namespace
   * @param body Subscription auth mode for all topics of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionAuthMode(
    tenant: string,
    namespace: string,
    body?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionAuthMode"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionAuthMode."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionAuthMode."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set Subscription dispatch-rate throttling for all topics of the namespace
   * @param tenant
   * @param namespace
   * @param body Subscription dispatch rate for all topics of the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set subscription expiration time in minutes for namespace
   * @param tenant
   * @param namespace
   * @param body Expiration time in minutes for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionExpirationTime(
    tenant: string,
    namespace: string,
    body: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionExpirationTime"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionExpirationTime."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionExpirationTime."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setSubscriptionExpirationTime."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update set of whether allow share sub type
   * @param tenant
   * @param namespace
   * @param body Set of whether allow subscription types
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    body: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Split a namespace bundle
   * @param tenant
   * @param namespace
   * @param bundle
   * @param authoritative
   * @param unload
   * @param splitAlgorithmName
   * @param body splitBoundaries
   * @param {*} [options] Override http request options.
   */
  public splitNamespaceBundle(
    tenant: string,
    namespace: string,
    bundle: string,
    authoritative?: boolean,
    unload?: boolean,
    splitAlgorithmName?: string,
    body?: Array<number>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/{bundle}/split"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling splitNamespaceBundle."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling splitNamespaceBundle."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling splitNamespaceBundle."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (unload !== undefined) {
      localVarQueryParameters["unload"] = ObjectSerializer.serialize(
        unload,
        "boolean"
      );
    }

    if (splitAlgorithmName !== undefined) {
      localVarQueryParameters["splitAlgorithmName"] =
        ObjectSerializer.serialize(splitAlgorithmName, "string");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<number>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Unload an active namespace from the current broker serving it. Performing this operation will let the brokerremoves all producers, consumers, and connections using this namespace, and close all topics (includingtheir persistent store). During that operation, the namespace is marked as tentatively unavailable until thebroker completes the unloading action. This operation requires strictly super user privileges, since it wouldresult in non-persistent message loss and unexpected connection closure to the clients.
   * @summary Unload namespace
   * @param tenant
   * @param namespace
   * @param {*} [options] Override http request options.
   */
  public unloadNamespace(
    tenant: string,
    namespace: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/unload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling unloadNamespace."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling unloadNamespace."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Unload a namespace bundle
   * @param tenant
   * @param namespace
   * @param bundle
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public unloadNamespaceBundle(
    tenant: string,
    namespace: string,
    bundle: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/{bundle}/unload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling unloadNamespaceBundle."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling unloadNamespaceBundle."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling unloadNamespaceBundle."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Unsubscribes the given subscription on all topics on a namespace.
   * @param tenant
   * @param namespace
   * @param subscription
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public unsubscribeNamespace(
    tenant: string,
    namespace: string,
    subscription: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/unsubscribe/{subscription}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace(
          "{" + "subscription" + "}",
          encodeURIComponent(String(subscription))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling unsubscribeNamespace."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling unsubscribeNamespace."
      );
    }

    // verify required parameter 'subscription' is not null or undefined
    if (subscription === null || subscription === undefined) {
      throw new Error(
        "Required parameter subscription was null or undefined when calling unsubscribeNamespace."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Unsubscribes the given subscription on all topics on a namespace bundle.
   * @param tenant
   * @param namespace
   * @param subscription
   * @param bundle
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public unsubscribeNamespaceBundle(
    tenant: string,
    namespace: string,
    subscription: string,
    bundle: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/namespaces/{tenant}/{namespace}/{bundle}/unsubscribe/{subscription}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace(
          "{" + "subscription" + "}",
          encodeURIComponent(String(subscription))
        )
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling unsubscribeNamespaceBundle."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling unsubscribeNamespaceBundle."
      );
    }

    // verify required parameter 'subscription' is not null or undefined
    if (subscription === null || subscription === undefined) {
      throw new Error(
        "Required parameter subscription was null or undefined when calling unsubscribeNamespaceBundle."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling unsubscribeNamespaceBundle."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum NonPersistentTopicApiApiKeys {}

export class NonPersistentTopicApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: NonPersistentTopicApiApiKeys, value: string) {
    (this.authentications as any)[NonPersistentTopicApiApiKeys[key]].apiKey =
      value;
  }
  /**
   *
   * @summary Trigger a compaction operation on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public compact(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/compaction"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling compact."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling compact."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling compact."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the status of a compaction operation for a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public compactionStatus(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: LongRunningProcessStatus;
  }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/compaction"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling compactionStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling compactionStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling compactionStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: LongRunningProcessStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "LongRunningProcessStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create missed partitions of an existing partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param {*} [options] Override http request options.
   */
  public createMissedPartitions(
    tenant: string,
    namespace: string,
    topic: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/createMissedPartitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createMissedPartitions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createMissedPartitions."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createMissedPartitions."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This is the only REST endpoint from which non-partitioned topics could be created.
   * @summary Create a non-partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param body Key value pair properties for the topic metadata
   * @param {*} [options] Override http request options.
   */
  public createNonPartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    body?: any,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createNonPartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createNonPartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createNonPartitionedTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "any"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It needs to be called before creating a producer on a partitioned topic.
   * @summary Create a partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param body The metadata for the topic
   * @param createLocalTopicOnly
   * @param {*} [options] Override http request options.
   */
  public createPartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    body: PartitionedTopicMetadata,
    createLocalTopicOnly?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createPartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createPartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createPartitionedTopic."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling createPartitionedTopic."
      );
    }

    if (createLocalTopicOnly !== undefined) {
      localVarQueryParameters["createLocalTopicOnly"] =
        ObjectSerializer.serialize(createLocalTopicOnly, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PartitionedTopicMetadata"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Creates a subscription on the topic at the specified message id
   * @summary Create a subscription on the topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subscriptionName Subscription to create position on
   * @param authoritative Is authentication required to perform this operation
   * @param messageId messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
   * @param replicated Is replicated required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public createSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    subscriptionName: string,
    authoritative?: boolean,
    messageId?: ResetCursorData,
    replicated?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace(
          "{" + "subscriptionName" + "}",
          encodeURIComponent(String(subscriptionName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createSubscription."
      );
    }

    // verify required parameter 'subscriptionName' is not null or undefined
    if (subscriptionName === null || subscriptionName === undefined) {
      throw new Error(
        "Required parameter subscriptionName was null or undefined when calling createSubscription."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (replicated !== undefined) {
      localVarQueryParameters["replicated"] = ObjectSerializer.serialize(
        replicated,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(messageId, "ResetCursorData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete deduplicationSnapshotInterval config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteDeduplicationSnapshotInterval."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set delayed delivery messages config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteDelayedDeliveryPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete inactive topic policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteInactiveTopicPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteInactiveTopicPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete max unacked messages per consumer config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteMaxUnackedMessagesOnConsumer(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnConsumer."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete max unacked messages per subscription config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteMaxUnackedMessagesOnSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It will also delete all the partitions of the topic if it exists.
   * @summary Delete a partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param force Stop all producer/consumer/replicator and delete topic forcefully
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deletePartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deletePartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deletePartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deletePartitionedTopic."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
   * @summary Delete a subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to be deleted
   * @param force Disconnect and close all consumers and delete subscription forcefully
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteSubscription."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling deleteSubscription."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
   * @summary Delete a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param force Stop all producer/consumer/replicator and delete topic forcefully
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteTopic(
    tenant: string,
    namespace: string,
    topic: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteTopic."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param initialPosition Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
   * @param messagePosition The position of messages (default 1)
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public examineMessage(
    tenant: string,
    namespace: string,
    topic: string,
    initialPosition?: "latest" | "earliest",
    messagePosition?: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/examinemessage"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling examineMessage."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling examineMessage."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling examineMessage."
      );
    }

    if (initialPosition !== undefined) {
      localVarQueryParameters["initialPosition"] = ObjectSerializer.serialize(
        initialPosition,
        "'latest' | 'earliest'"
      );
    }

    if (messagePosition !== undefined) {
      localVarQueryParameters["messagePosition"] = ObjectSerializer.serialize(
        messagePosition,
        "number"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Expiry messages on all subscriptions of topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param expireTimeInSeconds Expires beyond the specified number of seconds
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public expireMessagesForAllSubscriptions(
    tenant: string,
    namespace: string,
    topic: string,
    expireTimeInSeconds: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace(
          "{" + "expireTimeInSeconds" + "}",
          encodeURIComponent(String(expireTimeInSeconds))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    // verify required parameter 'expireTimeInSeconds' is not null or undefined
    if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
      throw new Error(
        "Required parameter expireTimeInSeconds was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Expiry messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to be Expiry messages on
   * @param authoritative Is authentication required to perform this operation
   * @param messageId messageId to reset back to (ledgerId:entryId)
   * @param {*} [options] Override http request options.
   */
  public expireTopicMessages(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    messageId?: ResetCursorData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling expireTopicMessages."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling expireTopicMessages."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling expireTopicMessages."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling expireTopicMessages."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(messageId, "ResetCursorData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Expiry messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to be Expiry messages on
   * @param expireTimeInSeconds Expires beyond the specified number of seconds
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public expireTopicMessages_1(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    expireTimeInSeconds: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "expireTimeInSeconds" + "}",
          encodeURIComponent(String(expireTimeInSeconds))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'expireTimeInSeconds' is not null or undefined
    if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
      throw new Error(
        "Required parameter expireTimeInSeconds was null or undefined when calling expireTopicMessages_1."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get estimated backlog for offline topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getBacklog(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: PersistentOfflineTopicStats;
  }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/backlog"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBacklog."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBacklog."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getBacklog."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: PersistentOfflineTopicStats;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "PersistentOfflineTopicStats"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get backlog quota map on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param {*} [options] Override http request options.
   */
  public getBacklogQuotaMap(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    isGlobal?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBacklogQuotaMap."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBacklogQuotaMap."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getBacklogQuotaMap."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Calculate backlog size by a message ID (in bytes).
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getBacklogSizeByMessageId(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/backlogSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBacklogSizeByMessageId."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBacklogSizeByMessageId."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getBacklogSizeByMessageId."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get compaction threshold configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getCompactionThreshold(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getCompactionThreshold."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getCompactionThreshold."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get deduplication configuration of a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDeduplication(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDeduplication."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDeduplication."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get deduplicationSnapshotInterval config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get delayed delivery messages config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDispatchRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get inactive topic policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the internal stats for the topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param metadata
   * @param {*} [options] Override http request options.
   */
  public getInternalStats(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    metadata?: boolean,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: PersistentTopicInternalStats;
  }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/internalStats"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getInternalStats."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getInternalStats."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getInternalStats."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (metadata !== undefined) {
      localVarQueryParameters["metadata"] = ObjectSerializer.serialize(
        metadata,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: PersistentTopicInternalStats;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "PersistentTopicInternalStats"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Return the last commit message id of topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getLastMessageId(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/lastMessageId"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getLastMessageId."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getLastMessageId."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getLastMessageId."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of non-persistent topics under a namespace.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param bundle Specify the bundle name
   * @param includeSystemTopic Include system topic
   * @param {*} [options] Override http request options.
   */
  public getList(
    tenant: string,
    namespace: string,
    bundle?: string,
    includeSystemTopic?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getList."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getList."
      );
    }

    if (bundle !== undefined) {
      localVarQueryParameters["bundle"] = ObjectSerializer.serialize(
        bundle,
        "string"
      );
    }

    if (includeSystemTopic !== undefined) {
      localVarQueryParameters["includeSystemTopic"] =
        ObjectSerializer.serialize(includeSystemTopic, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of non-persistent topics under a namespace bundle.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param bundle Bundle range of a topic
   * @param {*} [options] Override http request options.
   */
  public getListFromBundle(
    tenant: string,
    namespace: string,
    bundle: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{bundle}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getListFromBundle."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getListFromBundle."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling getListFromBundle."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the stored topic metadata.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getManagedLedgerInfo(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/internal-info"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getManagedLedgerInfo."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getManagedLedgerInfo."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getManagedLedgerInfo."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxConsumers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxConsumers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxConsumers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxConsumers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxConsumers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get max consumers per subscription configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxMessageSize config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxMessageSize(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxMessageSize."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxMessageSize."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxMessageSize."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxProducers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxProducers(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxProducers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxProducers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxProducers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxProducers."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxSubscriptionsPerTopic config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get max unacked messages per consumer config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxUnackedMessagesOnConsumer(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnConsumer."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get max unacked messages per subscription config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxUnackedMessagesOnSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnSubscription."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message by its messageId.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param ledgerId The ledger id
   * @param entryId The entry id
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMessageById(
    tenant: string,
    namespace: string,
    topic: string,
    ledgerId: number,
    entryId: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "ledgerId" + "}", encodeURIComponent(String(ledgerId)))
        .replace("{" + "entryId" + "}", encodeURIComponent(String(entryId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'ledgerId' is not null or undefined
    if (ledgerId === null || ledgerId === undefined) {
      throw new Error(
        "Required parameter ledgerId was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'entryId' is not null or undefined
    if (entryId === null || entryId === undefined) {
      throw new Error(
        "Required parameter entryId was null or undefined when calling getMessageById."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message ID published at or just after this absolute timestamp (in ms).
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param timestamp Specify the timestamp
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMessageIdByTimestamp(
    tenant: string,
    namespace: string,
    topic: string,
    timestamp: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/messageid/{timestamp}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace(
          "{" + "timestamp" + "}",
          encodeURIComponent(String(timestamp))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    // verify required parameter 'timestamp' is not null or undefined
    if (timestamp === null || timestamp === undefined) {
      throw new Error(
        "Required parameter timestamp was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message TTL in seconds for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMessageTTL(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMessageTTL."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMessageTTL."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get offload policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getOffloadPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getOffloadPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getOffloadPolicies."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get partitioned topic metadata.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param checkAllowAutoCreation Is check configuration required to automatically create topic
   * @param {*} [options] Override http request options.
   */
  public getPartitionedMetadata(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    checkAllowAutoCreation?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPartitionedMetadata."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPartitionedMetadata."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPartitionedMetadata."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (checkAllowAutoCreation !== undefined) {
      localVarQueryParameters["checkAllowAutoCreation"] =
        ObjectSerializer.serialize(checkAllowAutoCreation, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the stats for the partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param perPartition Get per partition stats
   * @param authoritative Is authentication required to perform this operation
   * @param getPreciseBacklog If return precise backlog or imprecise backlog
   * @param subscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
   * @param getEarliestTimeInBacklog If return the earliest time in backlog
   * @param {*} [options] Override http request options.
   */
  public getPartitionedStats(
    tenant: string,
    namespace: string,
    topic: string,
    perPartition?: boolean,
    authoritative?: boolean,
    getPreciseBacklog?: boolean,
    subscriptionBacklogSize?: boolean,
    getEarliestTimeInBacklog?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/partitioned-stats"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPartitionedStats."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPartitionedStats."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPartitionedStats."
      );
    }

    if (perPartition !== undefined) {
      localVarQueryParameters["perPartition"] = ObjectSerializer.serialize(
        perPartition,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (getPreciseBacklog !== undefined) {
      localVarQueryParameters["getPreciseBacklog"] = ObjectSerializer.serialize(
        getPreciseBacklog,
        "boolean"
      );
    }

    if (subscriptionBacklogSize !== undefined) {
      localVarQueryParameters["subscriptionBacklogSize"] =
        ObjectSerializer.serialize(subscriptionBacklogSize, "boolean");
    }

    if (getEarliestTimeInBacklog !== undefined) {
      localVarQueryParameters["getEarliestTimeInBacklog"] =
        ObjectSerializer.serialize(getEarliestTimeInBacklog, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of partitioned topics under a namespace.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param includeSystemTopic Include system topic
   * @param {*} [options] Override http request options.
   */
  public getPartitionedTopicList(
    tenant: string,
    namespace: string,
    includeSystemTopic?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/partitioned"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPartitionedTopicList."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPartitionedTopicList."
      );
    }

    if (includeSystemTopic !== undefined) {
      localVarQueryParameters["includeSystemTopic"] =
        ObjectSerializer.serialize(includeSystemTopic, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
   * @summary Get permissions on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param {*} [options] Override http request options.
   */
  public getPermissionsOnTopic(
    tenant: string,
    namespace: string,
    topic: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/permissions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPermissionsOnTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPermissionsOnTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPermissionsOnTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get configuration of persistence policies for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getPersistence(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPersistence."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPersistence."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get publish rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getPublishRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/publishRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPublishRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPublishRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPublishRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get replicated subscription status on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getReplicatedSubscriptionStatus(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the replication clusters for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getReplicationClusters(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getReplicationClusters."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getReplicationClusters."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get replicatorDispatchRate config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get retention configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getRetention(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getRetention."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getRetention."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get schema compatibility strategy on a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the cluster
   * @param topic Specify topic name
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get schema validation enforced flag for topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSchemaValidationEnforced(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchemaValidationEnforced."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchemaValidationEnforced."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSchemaValidationEnforced."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the stats for the topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param getPreciseBacklog If return precise backlog or imprecise backlog
   * @param subscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
   * @param getEarliestTimeInBacklog If return time of the earliest message in backlog
   * @param {*} [options] Override http request options.
   */
  public getStats(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    getPreciseBacklog?: boolean,
    subscriptionBacklogSize?: boolean,
    getEarliestTimeInBacklog?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/stats"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getStats."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getStats."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getStats."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (getPreciseBacklog !== undefined) {
      localVarQueryParameters["getPreciseBacklog"] = ObjectSerializer.serialize(
        getPreciseBacklog,
        "boolean"
      );
    }

    if (subscriptionBacklogSize !== undefined) {
      localVarQueryParameters["subscriptionBacklogSize"] =
        ObjectSerializer.serialize(subscriptionBacklogSize, "boolean");
    }

    if (getEarliestTimeInBacklog !== undefined) {
      localVarQueryParameters["getEarliestTimeInBacklog"] =
        ObjectSerializer.serialize(getEarliestTimeInBacklog, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get subscribe rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscribeRate(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscribeRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscribeRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get subscription message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message dispatch rate configuration for specified subscription.
   * @param tenant
   * @param namespace
   * @param topic
   * @param subName
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionLevelDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get is enable sub type fors specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of persistent subscriptions for a given topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscriptions(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscriptions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptions."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptions."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Grant a new permission to a role on a single topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param role Client role to which grant permissions
   * @param body Actions to be granted (produce,functions,consume)
   * @param {*} [options] Override http request options.
   */
  public grantPermissionsOnTopic(
    tenant: string,
    namespace: string,
    topic: string,
    role: string,
    body?: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "role" + "}", encodeURIComponent(String(role)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        "Required parameter role was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Offload a prefix of a topic to long term storage
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public offloadStatus(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/offload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling offloadStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling offloadStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling offloadStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Peek nth message on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscribed message expired
   * @param messagePosition The number of messages (default 1)
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public peekNthMessage(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    messagePosition: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "messagePosition" + "}",
          encodeURIComponent(String(messagePosition))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'messagePosition' is not null or undefined
    if (messagePosition === null || messagePosition === undefined) {
      throw new Error(
        "Required parameter messagePosition was null or undefined when calling peekNthMessage."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove a backlog quota policy from a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param backlogQuotaType
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param {*} [options] Override http request options.
   */
  public removeBacklogQuota(
    tenant: string,
    namespace: string,
    topic: string,
    backlogQuotaType?: "destination_storage" | "message_age",
    authoritative?: boolean,
    isGlobal?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/backlogQuota"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeBacklogQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeBacklogQuota."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeBacklogQuota."
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove compaction threshold configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeCompactionThreshold(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeCompactionThreshold."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeCompactionThreshold."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove deduplication configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeDeduplication(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeDeduplication."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeDeduplication."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxConsumers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxConsumers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxConsumers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxConsumers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxConsumers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove max consumers per subscription configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxMessageSize config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxMessageSize(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxMessageSize."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxMessageSize."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxMessageSize."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxProducers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxProducers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxProducers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxProducers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxProducers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxProducers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxSubscriptionsPerTopic config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message TTL in seconds for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeMessageTTL(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMessageTTL."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMessageTTL."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete offload policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeOffloadPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeOffloadPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeOffloadPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove configuration of persistence policies for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removePersistence(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removePersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removePersistence."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removePersistence."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message publish rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removePublishRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/publishRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removePublishRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removePublishRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removePublishRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove the replication clusters from a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param backlogQuotaType
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeReplicationClusters(
    tenant: string,
    namespace: string,
    topic: string,
    backlogQuotaType?: "destination_storage" | "message_age",
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeReplicationClusters."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeReplicationClusters."
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove replicatorDispatchRate config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove retention configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeRetention(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeRetention."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeRetention."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove schema compatibility strategy on a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param body Strategy used to check the compatibility of new schema
   * @param {*} [options] Override http request options.
   */
  public removeSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    body?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSchemaCompatibilityStrategy."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove subscribe rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative
   * @param body Subscribe rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public removeSubscribeRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: SubscribeRate,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscribeRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscribeRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "SubscribeRate"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove subscription message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscriptionDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message dispatch rate configuration for specified subscription.
   * @param tenant
   * @param namespace
   * @param topic
   * @param subName
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionLevelDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove subscription types enabled for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It fence cursor and disconnects all active consumers before reseting cursor.
   * @summary Reset subscription to message position closest to absolute timestamp (in ms).
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to reset position on
   * @param timestamp the timestamp to reset back
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public resetCursor(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    timestamp: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "timestamp" + "}",
          encodeURIComponent(String(timestamp))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'timestamp' is not null or undefined
    if (timestamp === null || timestamp === undefined) {
      throw new Error(
        "Required parameter timestamp was null or undefined when calling resetCursor."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It fence cursor and disconnects all active consumers before reseting cursor.
   * @summary Reset subscription to message position closest to given position.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to reset position on
   * @param authoritative Is authentication required to perform this operation
   * @param messageId messageId to reset back to (ledgerId:entryId)
   * @param {*} [options] Override http request options.
   */
  public resetCursorOnPosition(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    messageId?: ResetCursorData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling resetCursorOnPosition."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling resetCursorOnPosition."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling resetCursorOnPosition."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling resetCursorOnPosition."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(messageId, "ResetCursorData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
   * @summary Revoke permissions on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param role Client role to which grant permissions
   * @param {*} [options] Override http request options.
   */
  public revokePermissionsOnTopic(
    tenant: string,
    namespace: string,
    topic: string,
    role: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "role" + "}", encodeURIComponent(String(role)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        "Required parameter role was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set a backlog quota for a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param backlogQuotaType
   * @param {*} [options] Override http request options.
   */
  public setBacklogQuota(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    backlogQuotaType?: "destination_storage" | "message_age",
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/backlogQuota"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setBacklogQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setBacklogQuota."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setBacklogQuota."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set compaction threshold configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setCompactionThreshold(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setCompactionThreshold."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setCompactionThreshold."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set deduplication enabled on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param body DeduplicationEnabled policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setDeduplication(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDeduplication."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDeduplication."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set deduplicationSnapshotInterval config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param body Interval to take deduplication snapshot for the specified topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    topic: string,
    body?: number,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set delayed delivery messages config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Delayed delivery policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: DelayedDeliveryPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DelayedDeliveryPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDispatchRate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set inactive topic policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body inactive topic policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: InactiveTopicPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "InactiveTopicPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxConsumers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body The max consumers of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxConsumers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxConsumers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxConsumers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxConsumers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set max consumers per subscription configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxMessageSize config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body The max message size of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxMessageSize(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxMessageSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxMessageSize."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxMessageSize."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxMessageSize."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxProducers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body The max producers of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxProducers(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxProducers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxProducers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxProducers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxProducers."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxSubscriptionsPerTopic config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body The max subscriptions of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set max unacked messages per consumer config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Max unacked messages on consumer policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setMaxUnackedMessagesOnConsumer(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnConsumer."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set max unacked messages per subscription config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Max unacked messages on subscription policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setMaxUnackedMessagesOnSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message TTL in seconds for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param messageTTL TTL in seconds for the specified namespace
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setMessageTTL(
    tenant: string,
    namespace: string,
    topic: string,
    messageTTL: number,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMessageTTL."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMessageTTL."
      );
    }

    // verify required parameter 'messageTTL' is not null or undefined
    if (messageTTL === null || messageTTL === undefined) {
      throw new Error(
        "Required parameter messageTTL was null or undefined when calling setMessageTTL."
      );
    }

    if (messageTTL !== undefined) {
      localVarQueryParameters["messageTTL"] = ObjectSerializer.serialize(
        messageTTL,
        "number"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set offload policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Offload policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setOffloadPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: OffloadPoliciesImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setOffloadPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setOffloadPolicies."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "OffloadPoliciesImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set configuration of persistence policies for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Bookkeeper persistence policies for specified topic
   * @param {*} [options] Override http request options.
   */
  public setPersistence(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: PersistencePolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setPersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setPersistence."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setPersistence."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PersistencePolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message publish rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setPublishRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: PublishRate,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/publishRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setPublishRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setPublishRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setPublishRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PublishRate"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Enable or disable a replicated subscription on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param body Whether to enable replicated subscription
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setReplicatedSubscriptionStatus(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    body: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set the replication clusters for a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param body List of replication clusters
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setReplicationClusters(
    tenant: string,
    namespace: string,
    topic: string,
    body: Array<string>,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setReplicationClusters."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setReplicationClusters."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setReplicationClusters."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set replicatorDispatchRate config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Replicator dispatch rate of the topic
   * @param {*} [options] Override http request options.
   */
  public setReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set retention configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Retention policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setRetention(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: RetentionPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setRetention."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setRetention."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RetentionPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set schema compatibility strategy on a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param body Strategy used to check the compatibility of new schema
   * @param {*} [options] Override http request options.
   */
  public setSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    body?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set schema validation enforced flag on topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param body
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setSchemaValidationEnforced(
    tenant: string,
    namespace: string,
    topic: string,
    body: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set subscribe rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Subscribe rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscribeRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: SubscribeRate,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscribeRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscribeRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "SubscribeRate"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set subscription message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Subscription message dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message dispatch rate configuration for specified subscription.
   * @param tenant
   * @param namespace
   * @param topic
   * @param subName
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Subscription message dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionLevelDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set is enable sub types for specified topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param body Enable sub types for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Completely clears the backlog on the subscription.
   * @summary Skip all messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public skipAllMessages(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling skipAllMessages."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling skipAllMessages."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling skipAllMessages."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling skipAllMessages."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Skipping messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param numMessages The number of messages to skip
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public skipMessages(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    numMessages: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "numMessages" + "}",
          encodeURIComponent(String(numMessages))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'numMessages' is not null or undefined
    if (numMessages === null || numMessages === undefined) {
      throw new Error(
        "Required parameter numMessages was null or undefined when calling skipMessages."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public terminate(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: MessageId }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/terminate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling terminate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling terminate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling terminate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: MessageId }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "MessageId");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public terminatePartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/terminate/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling terminatePartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling terminatePartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling terminatePartitionedTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Offload a prefix of a topic to long term storage
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public triggerOffload(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/offload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling triggerOffload."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling triggerOffload."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling triggerOffload."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * NonPersistentTopic does not support truncate.
   * @summary Truncate a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public truncateTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/truncate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling truncateTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling truncateTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling truncateTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Unload a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public unloadTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/unload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling unloadTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling unloadTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling unloadTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It only increments partitions of existing non-global partitioned-topic
   * @summary Increment partitions of an existing partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param body The number of partitions for the topic
   * @param updateLocalTopicOnly
   * @param authoritative Is authentication required to perform this operation
   * @param force
   * @param {*} [options] Override http request options.
   */
  public updatePartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    body: number,
    updateLocalTopicOnly?: boolean,
    authoritative?: boolean,
    force?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/non-persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling updatePartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling updatePartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling updatePartitionedTopic."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling updatePartitionedTopic."
      );
    }

    if (updateLocalTopicOnly !== undefined) {
      localVarQueryParameters["updateLocalTopicOnly"] =
        ObjectSerializer.serialize(updateLocalTopicOnly, "boolean");
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum PersistentTopicApiApiKeys {}

export class PersistentTopicApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: PersistentTopicApiApiKeys, value: string) {
    (this.authentications as any)[PersistentTopicApiApiKeys[key]].apiKey =
      value;
  }
  /**
   *
   * @summary Trigger a compaction operation on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public compact(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/compaction"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling compact."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling compact."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling compact."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the status of a compaction operation for a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public compactionStatus(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: LongRunningProcessStatus;
  }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/compaction"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling compactionStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling compactionStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling compactionStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: LongRunningProcessStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "LongRunningProcessStatus");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create missed partitions of an existing partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param {*} [options] Override http request options.
   */
  public createMissedPartitions(
    tenant: string,
    namespace: string,
    topic: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/createMissedPartitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createMissedPartitions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createMissedPartitions."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createMissedPartitions."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This is the only REST endpoint from which non-partitioned topics could be created.
   * @summary Create a non-partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param body Key value pair properties for the topic metadata
   * @param {*} [options] Override http request options.
   */
  public createNonPartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    body?: any,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createNonPartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createNonPartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createNonPartitionedTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "any"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It needs to be called before creating a producer on a partitioned topic.
   * @summary Create a partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param body The metadata for the topic
   * @param createLocalTopicOnly
   * @param {*} [options] Override http request options.
   */
  public createPartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    body: PartitionedTopicMetadata,
    createLocalTopicOnly?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createPartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createPartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createPartitionedTopic."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling createPartitionedTopic."
      );
    }

    if (createLocalTopicOnly !== undefined) {
      localVarQueryParameters["createLocalTopicOnly"] =
        ObjectSerializer.serialize(createLocalTopicOnly, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PartitionedTopicMetadata"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Creates a subscription on the topic at the specified message id
   * @summary Create a subscription on the topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subscriptionName Subscription to create position on
   * @param authoritative Is authentication required to perform this operation
   * @param messageId messageId where to create the subscription. It can be &#39;latest&#39;, &#39;earliest&#39; or (ledgerId:entryId)
   * @param replicated Is replicated required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public createSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    subscriptionName: string,
    authoritative?: boolean,
    messageId?: ResetCursorData,
    replicated?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subscriptionName}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace(
          "{" + "subscriptionName" + "}",
          encodeURIComponent(String(subscriptionName))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling createSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling createSubscription."
      );
    }

    // verify required parameter 'subscriptionName' is not null or undefined
    if (subscriptionName === null || subscriptionName === undefined) {
      throw new Error(
        "Required parameter subscriptionName was null or undefined when calling createSubscription."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (replicated !== undefined) {
      localVarQueryParameters["replicated"] = ObjectSerializer.serialize(
        replicated,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(messageId, "ResetCursorData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete deduplicationSnapshotInterval config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteDeduplicationSnapshotInterval."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set delayed delivery messages config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteDelayedDeliveryPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete inactive topic policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteInactiveTopicPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteInactiveTopicPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete max unacked messages per consumer config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteMaxUnackedMessagesOnConsumer(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnConsumer."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete max unacked messages per subscription config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteMaxUnackedMessagesOnSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteMaxUnackedMessagesOnSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It will also delete all the partitions of the topic if it exists.
   * @summary Delete a partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param force Stop all producer/consumer/replicator and delete topic forcefully
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deletePartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deletePartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deletePartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deletePartitionedTopic."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The subscription cannot be deleted if delete is not forcefully and there are any active consumers attached to it. Force delete ignores connected consumers and deletes subscription by explicitly closing them.
   * @summary Delete a subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to be deleted
   * @param force Disconnect and close all consumers and delete subscription forcefully
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteSubscription."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling deleteSubscription."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The topic cannot be deleted if delete is not forcefully and there's any active subscription or producer connected to the it. Force delete ignores connected clients and deletes topic by explicitly closing them.
   * @summary Delete a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param force Stop all producer/consumer/replicator and delete topic forcefully
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public deleteTopic(
    tenant: string,
    namespace: string,
    topic: string,
    force?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteTopic."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Examine a specific message on a topic by position relative to the earliest or the latest message.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param initialPosition Relative start position to examine message.It can be &#39;latest&#39; or &#39;earliest&#39;
   * @param messagePosition The position of messages (default 1)
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public examineMessage(
    tenant: string,
    namespace: string,
    topic: string,
    initialPosition?: "latest" | "earliest",
    messagePosition?: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/examinemessage"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling examineMessage."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling examineMessage."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling examineMessage."
      );
    }

    if (initialPosition !== undefined) {
      localVarQueryParameters["initialPosition"] = ObjectSerializer.serialize(
        initialPosition,
        "'latest' | 'earliest'"
      );
    }

    if (messagePosition !== undefined) {
      localVarQueryParameters["messagePosition"] = ObjectSerializer.serialize(
        messagePosition,
        "number"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Expiry messages on all subscriptions of topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param expireTimeInSeconds Expires beyond the specified number of seconds
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public expireMessagesForAllSubscriptions(
    tenant: string,
    namespace: string,
    topic: string,
    expireTimeInSeconds: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/all_subscription/expireMessages/{expireTimeInSeconds}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace(
          "{" + "expireTimeInSeconds" + "}",
          encodeURIComponent(String(expireTimeInSeconds))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    // verify required parameter 'expireTimeInSeconds' is not null or undefined
    if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
      throw new Error(
        "Required parameter expireTimeInSeconds was null or undefined when calling expireMessagesForAllSubscriptions."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Expiry messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to be Expiry messages on
   * @param authoritative Is authentication required to perform this operation
   * @param messageId messageId to reset back to (ledgerId:entryId)
   * @param {*} [options] Override http request options.
   */
  public expireTopicMessages(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    messageId?: ResetCursorData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling expireTopicMessages."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling expireTopicMessages."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling expireTopicMessages."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling expireTopicMessages."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(messageId, "ResetCursorData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Expiry messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to be Expiry messages on
   * @param expireTimeInSeconds Expires beyond the specified number of seconds
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public expireTopicMessages_1(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    expireTimeInSeconds: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/expireMessages/{expireTimeInSeconds}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "expireTimeInSeconds" + "}",
          encodeURIComponent(String(expireTimeInSeconds))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling expireTopicMessages_1."
      );
    }

    // verify required parameter 'expireTimeInSeconds' is not null or undefined
    if (expireTimeInSeconds === null || expireTimeInSeconds === undefined) {
      throw new Error(
        "Required parameter expireTimeInSeconds was null or undefined when calling expireTopicMessages_1."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get estimated backlog for offline topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getBacklog(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: PersistentOfflineTopicStats;
  }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/backlog"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBacklog."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBacklog."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getBacklog."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: PersistentOfflineTopicStats;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "PersistentOfflineTopicStats"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get backlog quota map on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param {*} [options] Override http request options.
   */
  public getBacklogQuotaMap(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    isGlobal?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/backlogQuotaMap"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBacklogQuotaMap."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBacklogQuotaMap."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getBacklogQuotaMap."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Calculate backlog size by a message ID (in bytes).
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getBacklogSizeByMessageId(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/backlogSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getBacklogSizeByMessageId."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getBacklogSizeByMessageId."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getBacklogSizeByMessageId."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get compaction threshold configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getCompactionThreshold(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getCompactionThreshold."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getCompactionThreshold."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get deduplication configuration of a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDeduplication(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDeduplication."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDeduplication."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get deduplicationSnapshotInterval config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDeduplicationSnapshotInterval."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get delayed delivery messages config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDelayedDeliveryPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getDispatchRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get inactive topic policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getInactiveTopicPolicies."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the internal stats for the topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param metadata
   * @param {*} [options] Override http request options.
   */
  public getInternalStats(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    metadata?: boolean,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: PersistentTopicInternalStats;
  }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/internalStats"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getInternalStats."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getInternalStats."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getInternalStats."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (metadata !== undefined) {
      localVarQueryParameters["metadata"] = ObjectSerializer.serialize(
        metadata,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: PersistentTopicInternalStats;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "PersistentTopicInternalStats"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Return the last commit message id of topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getLastMessageId(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/lastMessageId"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getLastMessageId."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getLastMessageId."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getLastMessageId."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of topics under a namespace.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param bundle Specify the bundle name
   * @param includeSystemTopic Include system topic
   * @param {*} [options] Override http request options.
   */
  public getList(
    tenant: string,
    namespace: string,
    bundle?: string,
    includeSystemTopic?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getList."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getList."
      );
    }

    if (bundle !== undefined) {
      localVarQueryParameters["bundle"] = ObjectSerializer.serialize(
        bundle,
        "string"
      );
    }

    if (includeSystemTopic !== undefined) {
      localVarQueryParameters["includeSystemTopic"] =
        ObjectSerializer.serialize(includeSystemTopic, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the stored topic metadata.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getManagedLedgerInfo(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/internal-info"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getManagedLedgerInfo."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getManagedLedgerInfo."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getManagedLedgerInfo."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxConsumers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxConsumers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxConsumers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxConsumers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxConsumers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxConsumers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get max consumers per subscription configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxConsumersPerSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxMessageSize config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxMessageSize(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxMessageSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxMessageSize."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxMessageSize."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxMessageSize."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxProducers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxProducers(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxProducers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxProducers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxProducers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxProducers."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get maxSubscriptionsPerTopic config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxSubscriptionsPerTopic."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get max unacked messages per consumer config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxUnackedMessagesOnConsumer(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnConsumer."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get max unacked messages per subscription config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMaxUnackedMessagesOnSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMaxUnackedMessagesOnSubscription."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message by its messageId.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param ledgerId The ledger id
   * @param entryId The entry id
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMessageById(
    tenant: string,
    namespace: string,
    topic: string,
    ledgerId: number,
    entryId: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/ledger/{ledgerId}/entry/{entryId}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "ledgerId" + "}", encodeURIComponent(String(ledgerId)))
        .replace("{" + "entryId" + "}", encodeURIComponent(String(entryId)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'ledgerId' is not null or undefined
    if (ledgerId === null || ledgerId === undefined) {
      throw new Error(
        "Required parameter ledgerId was null or undefined when calling getMessageById."
      );
    }

    // verify required parameter 'entryId' is not null or undefined
    if (entryId === null || entryId === undefined) {
      throw new Error(
        "Required parameter entryId was null or undefined when calling getMessageById."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message ID published at or just after this absolute timestamp (in ms).
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param timestamp Specify the timestamp
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMessageIdByTimestamp(
    tenant: string,
    namespace: string,
    topic: string,
    timestamp: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/messageid/{timestamp}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace(
          "{" + "timestamp" + "}",
          encodeURIComponent(String(timestamp))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    // verify required parameter 'timestamp' is not null or undefined
    if (timestamp === null || timestamp === undefined) {
      throw new Error(
        "Required parameter timestamp was null or undefined when calling getMessageIdByTimestamp."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message TTL in seconds for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getMessageTTL(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getMessageTTL."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getMessageTTL."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get offload policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getOffloadPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getOffloadPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getOffloadPolicies."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get partitioned topic metadata.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param checkAllowAutoCreation Is check configuration required to automatically create topic
   * @param {*} [options] Override http request options.
   */
  public getPartitionedMetadata(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    checkAllowAutoCreation?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPartitionedMetadata."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPartitionedMetadata."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPartitionedMetadata."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (checkAllowAutoCreation !== undefined) {
      localVarQueryParameters["checkAllowAutoCreation"] =
        ObjectSerializer.serialize(checkAllowAutoCreation, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the stats for the partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param perPartition Get per partition stats
   * @param authoritative Is authentication required to perform this operation
   * @param getPreciseBacklog If return precise backlog or imprecise backlog
   * @param subscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
   * @param getEarliestTimeInBacklog If return the earliest time in backlog
   * @param {*} [options] Override http request options.
   */
  public getPartitionedStats(
    tenant: string,
    namespace: string,
    topic: string,
    perPartition?: boolean,
    authoritative?: boolean,
    getPreciseBacklog?: boolean,
    subscriptionBacklogSize?: boolean,
    getEarliestTimeInBacklog?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/partitioned-stats"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPartitionedStats."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPartitionedStats."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPartitionedStats."
      );
    }

    if (perPartition !== undefined) {
      localVarQueryParameters["perPartition"] = ObjectSerializer.serialize(
        perPartition,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (getPreciseBacklog !== undefined) {
      localVarQueryParameters["getPreciseBacklog"] = ObjectSerializer.serialize(
        getPreciseBacklog,
        "boolean"
      );
    }

    if (subscriptionBacklogSize !== undefined) {
      localVarQueryParameters["subscriptionBacklogSize"] =
        ObjectSerializer.serialize(subscriptionBacklogSize, "boolean");
    }

    if (getEarliestTimeInBacklog !== undefined) {
      localVarQueryParameters["getEarliestTimeInBacklog"] =
        ObjectSerializer.serialize(getEarliestTimeInBacklog, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of partitioned topics under a namespace.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param includeSystemTopic Include system topic
   * @param {*} [options] Override http request options.
   */
  public getPartitionedTopicList(
    tenant: string,
    namespace: string,
    includeSystemTopic?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/partitioned"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace(
          "{" + "namespace" + "}",
          encodeURIComponent(String(namespace))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPartitionedTopicList."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPartitionedTopicList."
      );
    }

    if (includeSystemTopic !== undefined) {
      localVarQueryParameters["includeSystemTopic"] =
        ObjectSerializer.serialize(includeSystemTopic, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Retrieve the effective permissions for a topic. These permissions are defined by the permissions set at thenamespace level combined (union) with any eventual specific permission set on the topic.
   * @summary Get permissions on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param {*} [options] Override http request options.
   */
  public getPermissionsOnTopic(
    tenant: string,
    namespace: string,
    topic: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/permissions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPermissionsOnTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPermissionsOnTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPermissionsOnTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get configuration of persistence policies for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getPersistence(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPersistence."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPersistence."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get publish rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getPublishRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/publishRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getPublishRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getPublishRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getPublishRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get replicated subscription status on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getReplicatedSubscriptionStatus(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling getReplicatedSubscriptionStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the replication clusters for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getReplicationClusters(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getReplicationClusters."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getReplicationClusters."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get replicatorDispatchRate config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getReplicatorDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get retention configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getRetention(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getRetention."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getRetention."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get schema compatibility strategy on a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the cluster
   * @param topic Specify topic name
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSchemaCompatibilityStrategy."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get schema validation enforced flag for topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param applied
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSchemaValidationEnforced(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchemaValidationEnforced."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchemaValidationEnforced."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSchemaValidationEnforced."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the stats for the topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param getPreciseBacklog If return precise backlog or imprecise backlog
   * @param subscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there&#39;s heavy traffic.
   * @param getEarliestTimeInBacklog If return time of the earliest message in backlog
   * @param {*} [options] Override http request options.
   */
  public getStats(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    getPreciseBacklog?: boolean,
    subscriptionBacklogSize?: boolean,
    getEarliestTimeInBacklog?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/stats"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getStats."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getStats."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getStats."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (getPreciseBacklog !== undefined) {
      localVarQueryParameters["getPreciseBacklog"] = ObjectSerializer.serialize(
        getPreciseBacklog,
        "boolean"
      );
    }

    if (subscriptionBacklogSize !== undefined) {
      localVarQueryParameters["subscriptionBacklogSize"] =
        ObjectSerializer.serialize(subscriptionBacklogSize, "boolean");
    }

    if (getEarliestTimeInBacklog !== undefined) {
      localVarQueryParameters["getEarliestTimeInBacklog"] =
        ObjectSerializer.serialize(getEarliestTimeInBacklog, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get subscribe rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscribeRate(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscribeRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscribeRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get subscription message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptionDispatchRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get message dispatch rate configuration for specified subscription.
   * @param tenant
   * @param namespace
   * @param topic
   * @param subName
   * @param applied
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionLevelDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    applied?: boolean,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling getSubscriptionLevelDispatchRate."
      );
    }

    if (applied !== undefined) {
      localVarQueryParameters["applied"] = ObjectSerializer.serialize(
        applied,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get is enable sub type fors specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public getSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptionTypesEnabled."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of persistent subscriptions for a given topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public getSubscriptions(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscriptions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSubscriptions."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSubscriptions."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSubscriptions."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Grant a new permission to a role on a single topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param role Client role to which grant permissions
   * @param body Actions to be granted (produce,functions,consume)
   * @param {*} [options] Override http request options.
   */
  public grantPermissionsOnTopic(
    tenant: string,
    namespace: string,
    topic: string,
    role: string,
    body?: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "role" + "}", encodeURIComponent(String(role)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        "Required parameter role was null or undefined when calling grantPermissionsOnTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Offload a prefix of a topic to long term storage
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public offloadStatus(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/offload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling offloadStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling offloadStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling offloadStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Peek nth message on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscribed message expired
   * @param messagePosition The number of messages (default 1)
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public peekNthMessage(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    messagePosition: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/position/{messagePosition}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "messagePosition" + "}",
          encodeURIComponent(String(messagePosition))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling peekNthMessage."
      );
    }

    // verify required parameter 'messagePosition' is not null or undefined
    if (messagePosition === null || messagePosition === undefined) {
      throw new Error(
        "Required parameter messagePosition was null or undefined when calling peekNthMessage."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove a backlog quota policy from a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param backlogQuotaType
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param {*} [options] Override http request options.
   */
  public removeBacklogQuota(
    tenant: string,
    namespace: string,
    topic: string,
    backlogQuotaType?: "destination_storage" | "message_age",
    authoritative?: boolean,
    isGlobal?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/backlogQuota"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeBacklogQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeBacklogQuota."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeBacklogQuota."
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove compaction threshold configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeCompactionThreshold(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeCompactionThreshold."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeCompactionThreshold."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove deduplication configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeDeduplication(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeDeduplication."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeDeduplication."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxConsumers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxConsumers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxConsumers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxConsumers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxConsumers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxConsumers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove max consumers per subscription configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxConsumersPerSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxMessageSize config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxMessageSize(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxMessageSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxMessageSize."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxMessageSize."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxMessageSize."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxProducers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxProducers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxProducers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxProducers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxProducers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxProducers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove maxSubscriptionsPerTopic config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMaxSubscriptionsPerTopic."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message TTL in seconds for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeMessageTTL(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeMessageTTL."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeMessageTTL."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete offload policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeOffloadPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeOffloadPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeOffloadPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove configuration of persistence policies for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removePersistence(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removePersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removePersistence."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removePersistence."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message publish rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removePublishRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/publishRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removePublishRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removePublishRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removePublishRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove the replication clusters from a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param backlogQuotaType
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeReplicationClusters(
    tenant: string,
    namespace: string,
    topic: string,
    backlogQuotaType?: "destination_storage" | "message_age",
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeReplicationClusters."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeReplicationClusters."
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove replicatorDispatchRate config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeReplicatorDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove retention configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeRetention(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeRetention."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeRetention."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove schema compatibility strategy on a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param body Strategy used to check the compatibility of new schema
   * @param {*} [options] Override http request options.
   */
  public removeSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    body?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSchemaCompatibilityStrategy."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove subscribe rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative
   * @param body Subscribe rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public removeSubscribeRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: SubscribeRate,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscribeRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscribeRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "SubscribeRate"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove subscription message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscriptionDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove message dispatch rate configuration for specified subscription.
   * @param tenant
   * @param namespace
   * @param topic
   * @param subName
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionLevelDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling removeSubscriptionLevelDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove subscription types enabled for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public removeSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling removeSubscriptionTypesEnabled."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It fence cursor and disconnects all active consumers before reseting cursor.
   * @summary Reset subscription to message position closest to absolute timestamp (in ms).
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to reset position on
   * @param timestamp the timestamp to reset back
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public resetCursor(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    timestamp: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor/{timestamp}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "timestamp" + "}",
          encodeURIComponent(String(timestamp))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling resetCursor."
      );
    }

    // verify required parameter 'timestamp' is not null or undefined
    if (timestamp === null || timestamp === undefined) {
      throw new Error(
        "Required parameter timestamp was null or undefined when calling resetCursor."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It fence cursor and disconnects all active consumers before reseting cursor.
   * @summary Reset subscription to message position closest to given position.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Subscription to reset position on
   * @param authoritative Is authentication required to perform this operation
   * @param messageId messageId to reset back to (ledgerId:entryId)
   * @param {*} [options] Override http request options.
   */
  public resetCursorOnPosition(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    messageId?: ResetCursorData,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/resetcursor"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling resetCursorOnPosition."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling resetCursorOnPosition."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling resetCursorOnPosition."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling resetCursorOnPosition."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(messageId, "ResetCursorData"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Revoke permissions to a role on a single topic. If the permission was not set at the topiclevel, but rather at the namespace level, this operation will return an error (HTTP status code 412).
   * @summary Revoke permissions on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param role Client role to which grant permissions
   * @param {*} [options] Override http request options.
   */
  public revokePermissionsOnTopic(
    tenant: string,
    namespace: string,
    topic: string,
    role: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/permissions/{role}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "role" + "}", encodeURIComponent(String(role)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    // verify required parameter 'role' is not null or undefined
    if (role === null || role === undefined) {
      throw new Error(
        "Required parameter role was null or undefined when calling revokePermissionsOnTopic."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set a backlog quota for a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param backlogQuotaType
   * @param {*} [options] Override http request options.
   */
  public setBacklogQuota(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    backlogQuotaType?: "destination_storage" | "message_age",
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/backlogQuota"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setBacklogQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setBacklogQuota."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setBacklogQuota."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (backlogQuotaType !== undefined) {
      localVarQueryParameters["backlogQuotaType"] = ObjectSerializer.serialize(
        backlogQuotaType,
        "'destination_storage' | 'message_age'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set compaction threshold configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setCompactionThreshold(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/compactionThreshold"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setCompactionThreshold."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setCompactionThreshold."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setCompactionThreshold."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set deduplication enabled on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param body DeduplicationEnabled policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setDeduplication(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/deduplicationEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDeduplication."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDeduplication."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDeduplication."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set deduplicationSnapshotInterval config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param body Interval to take deduplication snapshot for the specified topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setDeduplicationSnapshotInterval(
    tenant: string,
    namespace: string,
    topic: string,
    body?: number,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/deduplicationSnapshotInterval"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDeduplicationSnapshotInterval."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set delayed delivery messages config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Delayed delivery policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setDelayedDeliveryPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: DelayedDeliveryPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/delayedDelivery"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDelayedDeliveryPolicies."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DelayedDeliveryPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setDispatchRate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set inactive topic policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body inactive topic policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setInactiveTopicPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: InactiveTopicPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/inactiveTopicPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setInactiveTopicPolicies."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "InactiveTopicPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxConsumers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body The max consumers of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxConsumers(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxConsumers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxConsumers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxConsumers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxConsumers."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set max consumers per subscription configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setMaxConsumersPerSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxConsumersPerSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxConsumersPerSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxMessageSize config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body The max message size of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxMessageSize(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxMessageSize"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxMessageSize."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxMessageSize."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxMessageSize."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxProducers config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body The max producers of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxProducers(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxProducers"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxProducers."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxProducers."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxProducers."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set maxSubscriptionsPerTopic config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body The max subscriptions of the topic
   * @param {*} [options] Override http request options.
   */
  public setMaxSubscriptionsPerTopic(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxSubscriptionsPerTopic"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxSubscriptionsPerTopic."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set max unacked messages per consumer config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Max unacked messages on consumer policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setMaxUnackedMessagesOnConsumer(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnConsumer"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnConsumer."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnConsumer."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set max unacked messages per subscription config on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Max unacked messages on subscription policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setMaxUnackedMessagesOnSubscription(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: number,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/maxUnackedMessagesOnSubscription"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMaxUnackedMessagesOnSubscription."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMaxUnackedMessagesOnSubscription."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message TTL in seconds for a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param messageTTL TTL in seconds for the specified namespace
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setMessageTTL(
    tenant: string,
    namespace: string,
    topic: string,
    messageTTL: number,
    isGlobal?: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/messageTTL"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setMessageTTL."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setMessageTTL."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setMessageTTL."
      );
    }

    // verify required parameter 'messageTTL' is not null or undefined
    if (messageTTL === null || messageTTL === undefined) {
      throw new Error(
        "Required parameter messageTTL was null or undefined when calling setMessageTTL."
      );
    }

    if (messageTTL !== undefined) {
      localVarQueryParameters["messageTTL"] = ObjectSerializer.serialize(
        messageTTL,
        "number"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set offload policies on a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Offload policies for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setOffloadPolicies(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: OffloadPoliciesImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/offloadPolicies"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setOffloadPolicies."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setOffloadPolicies."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setOffloadPolicies."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "OffloadPoliciesImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set configuration of persistence policies for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Bookkeeper persistence policies for specified topic
   * @param {*} [options] Override http request options.
   */
  public setPersistence(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: PersistencePolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/persistence"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setPersistence."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setPersistence."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setPersistence."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PersistencePolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message publish rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setPublishRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: PublishRate,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/publishRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setPublishRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setPublishRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setPublishRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PublishRate"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Enable or disable a replicated subscription on a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param body Whether to enable replicated subscription
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setReplicatedSubscriptionStatus(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    body: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/replicatedSubscriptionStatus"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setReplicatedSubscriptionStatus."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set the replication clusters for a topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param body List of replication clusters
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setReplicationClusters(
    tenant: string,
    namespace: string,
    topic: string,
    body: Array<string>,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/replication"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setReplicationClusters."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setReplicationClusters."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setReplicationClusters."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setReplicationClusters."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set replicatorDispatchRate config for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Replicator dispatch rate of the topic
   * @param {*} [options] Override http request options.
   */
  public setReplicatorDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/replicatorDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setReplicatorDispatchRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set retention configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Retention policies for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setRetention(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: RetentionPolicies,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/retention"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setRetention."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setRetention."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setRetention."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "RetentionPolicies"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set schema compatibility strategy on a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param body Strategy used to check the compatibility of new schema
   * @param {*} [options] Override http request options.
   */
  public setSchemaCompatibilityStrategy(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    body?: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/schemaCompatibilityStrategy"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSchemaCompatibilityStrategy."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "string"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set schema validation enforced flag on topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param body
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public setSchemaValidationEnforced(
    tenant: string,
    namespace: string,
    topic: string,
    body: boolean,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/schemaValidationEnforced"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling setSchemaValidationEnforced."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "boolean"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set subscribe rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal
   * @param authoritative Is authentication required to perform this operation
   * @param body Subscribe rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscribeRate(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: SubscribeRate,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscribeRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscribeRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscribeRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscribeRate."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "SubscribeRate"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set subscription message dispatch rate configuration for specified topic.
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Subscription message dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscriptionDispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscriptionDispatchRate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set message dispatch rate configuration for specified subscription.
   * @param tenant
   * @param namespace
   * @param topic
   * @param subName
   * @param authoritative Is authentication required to perform this operation
   * @param isGlobal
   * @param body Subscription message dispatch rate for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionLevelDispatchRate(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    isGlobal?: boolean,
    body?: DispatchRateImpl,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/{subName}/dispatchRate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling setSubscriptionLevelDispatchRate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "DispatchRateImpl"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set is enable sub types for specified topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param isGlobal Is authentication required to perform this operation
   * @param authoritative
   * @param body Enable sub types for the specified topic
   * @param {*} [options] Override http request options.
   */
  public setSubscriptionTypesEnabled(
    tenant: string,
    namespace: string,
    topic: string,
    isGlobal?: boolean,
    authoritative?: boolean,
    body?: Array<string>,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscriptionTypesEnabled"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling setSubscriptionTypesEnabled."
      );
    }

    if (isGlobal !== undefined) {
      localVarQueryParameters["isGlobal"] = ObjectSerializer.serialize(
        isGlobal,
        "boolean"
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Array<string>"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Completely clears the backlog on the subscription.
   * @summary Skip all messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public skipAllMessages(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip_all"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling skipAllMessages."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling skipAllMessages."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling skipAllMessages."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling skipAllMessages."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Skipping messages on a topic subscription.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param subName Name of subscription
   * @param numMessages The number of messages to skip
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public skipMessages(
    tenant: string,
    namespace: string,
    topic: string,
    subName: string,
    numMessages: number,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/subscription/{subName}/skip/{numMessages}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "subName" + "}", encodeURIComponent(String(subName)))
        .replace(
          "{" + "numMessages" + "}",
          encodeURIComponent(String(numMessages))
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'subName' is not null or undefined
    if (subName === null || subName === undefined) {
      throw new Error(
        "Required parameter subName was null or undefined when calling skipMessages."
      );
    }

    // verify required parameter 'numMessages' is not null or undefined
    if (numMessages === null || numMessages === undefined) {
      throw new Error(
        "Required parameter numMessages was null or undefined when calling skipMessages."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Terminate a topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public terminate(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: MessageId }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/terminate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling terminate."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling terminate."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling terminate."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: MessageId }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "MessageId");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Terminate all partitioned topic. A topic that is terminated will not accept any more messages to be published and will let consumer to drain existing messages in backlog
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public terminatePartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/terminate/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling terminatePartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling terminatePartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling terminatePartitionedTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Offload a prefix of a topic to long term storage
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public triggerOffload(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/offload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling triggerOffload."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling triggerOffload."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling triggerOffload."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * The truncate operation will move all cursors to the end of the topic and delete all inactive ledgers.
   * @summary Truncate a topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public truncateTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/truncate"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling truncateTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling truncateTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling truncateTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Unload a topic
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param authoritative Is authentication required to perform this operation
   * @param {*} [options] Override http request options.
   */
  public unloadTopic(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/unload"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling unloadTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling unloadTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling unloadTopic."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It only increments partitions of existing non-global partitioned-topic
   * @summary Increment partitions of an existing partitioned topic.
   * @param tenant Specify the tenant
   * @param namespace Specify the namespace
   * @param topic Specify topic name
   * @param body The number of partitions for the topic
   * @param updateLocalTopicOnly
   * @param authoritative Is authentication required to perform this operation
   * @param force
   * @param {*} [options] Override http request options.
   */
  public updatePartitionedTopic(
    tenant: string,
    namespace: string,
    topic: string,
    body: number,
    updateLocalTopicOnly?: boolean,
    authoritative?: boolean,
    force?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/persistent/{tenant}/{namespace}/{topic}/partitions"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling updatePartitionedTopic."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling updatePartitionedTopic."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling updatePartitionedTopic."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling updatePartitionedTopic."
      );
    }

    if (updateLocalTopicOnly !== undefined) {
      localVarQueryParameters["updateLocalTopicOnly"] =
        ObjectSerializer.serialize(updateLocalTopicOnly, "boolean");
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "number"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ResourceQuotasApiApiKeys {}

export class ResourceQuotasApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ResourceQuotasApiApiKeys, value: string) {
    (this.authentications as any)[ResourceQuotasApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get the default quota
   * @param {*} [options] Override http request options.
   */
  public getDefaultResourceQuota(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath = this.basePath + "/resource-quotas";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get resource quota of a namespace bundle.
   * @param tenant Tenant name
   * @param namespace Namespace name within the specified tenant
   * @param bundle Namespace bundle range
   * @param {*} [options] Override http request options.
   */
  public getNamespaceBundleResourceQuota(
    tenant: string,
    namespace: string,
    bundle: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/resource-quotas/{tenant}/{namespace}/{bundle}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getNamespaceBundleResourceQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getNamespaceBundleResourceQuota."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling getNamespaceBundleResourceQuota."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove resource quota for a namespace.
   * @param tenant Tenant name
   * @param namespace Namespace name within the specified tenant
   * @param bundle Namespace bundle range
   * @param {*} [options] Override http request options.
   */
  public removeNamespaceBundleResourceQuota(
    tenant: string,
    namespace: string,
    bundle: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/resource-quotas/{tenant}/{namespace}/{bundle}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling removeNamespaceBundleResourceQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling removeNamespaceBundleResourceQuota."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling removeNamespaceBundleResourceQuota."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set the default quota
   * @param body Default resource quota
   * @param {*} [options] Override http request options.
   */
  public setDefaultResourceQuota(
    body?: ResourceQuota,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath = this.basePath + "/resource-quotas";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "ResourceQuota"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Set resource quota on a namespace.
   * @param tenant Tenant name
   * @param namespace Namespace name within the specified tenant
   * @param bundle Namespace bundle range
   * @param body Resource quota for the specified namespace
   * @param {*} [options] Override http request options.
   */
  public setNamespaceBundleResourceQuota(
    tenant: string,
    namespace: string,
    bundle: string,
    body?: ResourceQuota,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/resource-quotas/{tenant}/{namespace}/{bundle}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "bundle" + "}", encodeURIComponent(String(bundle)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling setNamespaceBundleResourceQuota."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling setNamespaceBundleResourceQuota."
      );
    }

    // verify required parameter 'bundle' is not null or undefined
    if (bundle === null || bundle === undefined) {
      throw new Error(
        "Required parameter bundle was null or undefined when calling setNamespaceBundleResourceQuota."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "ResourceQuota"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ResourcegroupsApiApiKeys {}

export class ResourcegroupsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ResourcegroupsApiApiKeys, value: string) {
    (this.authentications as any)[ResourcegroupsApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Creates a new resourcegroup with the specified rate limiters
   * @param resourcegroup
   * @param body Rate limiters for the resourcegroup
   * @param {*} [options] Override http request options.
   */
  public createOrUpdateResourceGroup(
    resourcegroup: string,
    body?: ResourceGroup,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/resourcegroups/{resourcegroup}".replace(
        "{" + "resourcegroup" + "}",
        encodeURIComponent(String(resourcegroup))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'resourcegroup' is not null or undefined
    if (resourcegroup === null || resourcegroup === undefined) {
      throw new Error(
        "Required parameter resourcegroup was null or undefined when calling createOrUpdateResourceGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "ResourceGroup"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a resourcegroup.
   * @param resourcegroup
   * @param {*} [options] Override http request options.
   */
  public deleteResourceGroup(
    resourcegroup: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/resourcegroups/{resourcegroup}".replace(
        "{" + "resourcegroup" + "}",
        encodeURIComponent(String(resourcegroup))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'resourcegroup' is not null or undefined
    if (resourcegroup === null || resourcegroup === undefined) {
      throw new Error(
        "Required parameter resourcegroup was null or undefined when calling deleteResourceGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the rate limiters specified for a resourcegroup.
   * @param resourcegroup
   * @param {*} [options] Override http request options.
   */
  public getResourceGroup(
    resourcegroup: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: ResourceGroup }> {
    const localVarPath =
      this.basePath +
      "/resourcegroups/{resourcegroup}".replace(
        "{" + "resourcegroup" + "}",
        encodeURIComponent(String(resourcegroup))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'resourcegroup' is not null or undefined
    if (resourcegroup === null || resourcegroup === undefined) {
      throw new Error(
        "Required parameter resourcegroup was null or undefined when calling getResourceGroup."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: ResourceGroup }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "ResourceGroup");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of all the resourcegroups.
   * @param {*} [options] Override http request options.
   */
  public getResourceGroups(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath = this.basePath + "/resourcegroups";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum SchemasApiApiKeys {}

export class SchemasApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: SchemasApiApiKeys, value: string) {
    (this.authentications as any)[SchemasApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Delete the schema of a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative
   * @param force
   * @param {*} [options] Override http request options.
   */
  public deleteSchema(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    force?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: DeleteSchemaResponse }> {
    const localVarPath =
      this.basePath +
      "/schemas/{tenant}/{namespace}/{topic}/schema"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteSchema."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling deleteSchema."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling deleteSchema."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: DeleteSchemaResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "DeleteSchemaResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the all schemas of a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public getAllSchemas(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{
    response: http.ClientResponse;
    body: GetAllVersionsSchemaResponse;
  }> {
    const localVarPath =
      this.basePath +
      "/schemas/{tenant}/{namespace}/{topic}/schemas"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getAllSchemas."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getAllSchemas."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getAllSchemas."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: GetAllVersionsSchemaResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetAllVersionsSchemaResponse"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the schema of a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public getSchema(
    tenant: string,
    namespace: string,
    topic: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: GetSchemaResponse }> {
    const localVarPath =
      this.basePath +
      "/schemas/{tenant}/{namespace}/{topic}/schema"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchema."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchema."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSchema."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: GetSchemaResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSchemaResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the schema of a topic at a given version
   * @param tenant
   * @param namespace
   * @param topic
   * @param version
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public getSchema_1(
    tenant: string,
    namespace: string,
    topic: string,
    version: string,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: GetSchemaResponse }> {
    const localVarPath =
      this.basePath +
      "/schemas/{tenant}/{namespace}/{topic}/schema/{version}"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)))
        .replace("{" + "version" + "}", encodeURIComponent(String(version)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getSchema_1."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getSchema_1."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getSchema_1."
      );
    }

    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined) {
      throw new Error(
        "Required parameter version was null or undefined when calling getSchema_1."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: GetSchemaResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSchemaResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary get the version of the schema
   * @param tenant
   * @param namespace
   * @param topic
   * @param body A JSON value presenting a schema playload. An example of the expected schema can be found down here.
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public getVersionBySchema(
    tenant: string,
    namespace: string,
    topic: string,
    body?: PostSchemaPayload,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: LongSchemaVersion }> {
    const localVarPath =
      this.basePath +
      "/schemas/{tenant}/{namespace}/{topic}/version"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getVersionBySchema."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling getVersionBySchema."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling getVersionBySchema."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PostSchemaPayload"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: LongSchemaVersion;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "LongSchemaVersion");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Update the schema of a topic
   * @param tenant
   * @param namespace
   * @param topic
   * @param body A JSON value presenting a schema playload. An example of the expected schema can be found down here.
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public postSchema(
    tenant: string,
    namespace: string,
    topic: string,
    body?: PostSchemaPayload,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: PostSchemaResponse }> {
    const localVarPath =
      this.basePath +
      "/schemas/{tenant}/{namespace}/{topic}/schema"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling postSchema."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling postSchema."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling postSchema."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PostSchemaPayload"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: PostSchemaResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "PostSchemaResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary test the schema compatibility
   * @param tenant
   * @param namespace
   * @param topic
   * @param body A JSON value presenting a schema playload. An example of the expected schema can be found down here.
   * @param authoritative
   * @param {*} [options] Override http request options.
   */
  public testCompatibility(
    tenant: string,
    namespace: string,
    topic: string,
    body?: PostSchemaPayload,
    authoritative?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: IsCompatibilityResponse }> {
    const localVarPath =
      this.basePath +
      "/schemas/{tenant}/{namespace}/{topic}/compatibility"
        .replace("{" + "tenant" + "}", encodeURIComponent(String(tenant)))
        .replace("{" + "namespace" + "}", encodeURIComponent(String(namespace)))
        .replace("{" + "topic" + "}", encodeURIComponent(String(topic)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling testCompatibility."
      );
    }

    // verify required parameter 'namespace' is not null or undefined
    if (namespace === null || namespace === undefined) {
      throw new Error(
        "Required parameter namespace was null or undefined when calling testCompatibility."
      );
    }

    // verify required parameter 'topic' is not null or undefined
    if (topic === null || topic === undefined) {
      throw new Error(
        "Required parameter topic was null or undefined when calling testCompatibility."
      );
    }

    if (authoritative !== undefined) {
      localVarQueryParameters["authoritative"] = ObjectSerializer.serialize(
        authoritative,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "PostSchemaPayload"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.ClientResponse;
      body: IsCompatibilityResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "IsCompatibilityResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum TenantsApiApiKeys {}

export class TenantsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TenantsApiApiKeys, value: string) {
    (this.authentications as any)[TenantsApiApiKeys[key]].apiKey = value;
  }
  /**
   * This operation requires Pulsar super-user privileges.
   * @summary Create a new tenant.
   * @param tenant The tenant name
   * @param body TenantInfo
   * @param {*} [options] Override http request options.
   */
  public createTenant(
    tenant: string,
    body?: TenantInfo,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/tenants/{tenant}".replace(
        "{" + "tenant" + "}",
        encodeURIComponent(String(tenant))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling createTenant."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "TenantInfo"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a tenant and all namespaces and topics under it.
   * @param tenant The tenant name
   * @param force
   * @param {*} [options] Override http request options.
   */
  public deleteTenant(
    tenant: string,
    force?: boolean,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/tenants/{tenant}".replace(
        "{" + "tenant" + "}",
        encodeURIComponent(String(tenant))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling deleteTenant."
      );
    }

    if (force !== undefined) {
      localVarQueryParameters["force"] = ObjectSerializer.serialize(
        force,
        "boolean"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the admin configuration for a given tenant.
   * @param tenant The tenant name
   * @param {*} [options] Override http request options.
   */
  public getTenantAdmin(
    tenant: string,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/tenants/{tenant}".replace(
        "{" + "tenant" + "}",
        encodeURIComponent(String(tenant))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling getTenantAdmin."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of existing tenants.
   * @param {*} [options] Override http request options.
   */
  public getTenants(
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body: Array<string> }> {
    const localVarPath = this.basePath + "/tenants";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string> }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Array<string>");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This operation requires Pulsar super-user privileges.
   * @summary Update the admins for a tenant.
   * @param tenant The tenant name
   * @param body TenantInfo
   * @param {*} [options] Override http request options.
   */
  public updateTenant(
    tenant: string,
    body?: TenantInfo,
    options: any = {}
  ): Promise<{ response: http.ClientResponse; body?: any }> {
    const localVarPath =
      this.basePath +
      "/tenants/{tenant}".replace(
        "{" + "tenant" + "}",
        encodeURIComponent(String(tenant))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'tenant' is not null or undefined
    if (tenant === null || tenant === undefined) {
      throw new Error(
        "Required parameter tenant was null or undefined when calling updateTenant."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "TenantInfo"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
